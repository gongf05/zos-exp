(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("Debugger", [], factory);
	else if(typeof exports === 'object')
		exports["Debugger"] = factory();
	else
		root["Debugger"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 32);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("debug");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.prefixName = prefixName;
exports.keccak256 = keccak256;
exports.stableKeccak256 = stableKeccak256;
exports.isCallMnemonic = isCallMnemonic;

var _truffleDecodeUtils = __webpack_require__(10);

var utils = _interopRequireWildcard(_truffleDecodeUtils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

const stringify = __webpack_require__(41);

function prefixName(prefix, fn) {
  Object.defineProperty(fn, "name", {
    value: `${prefix}.${fn.name}`,
    configurable: true
  });

  return fn;
}

/**
 * @return 0x-prefix string of keccak256 hash
 */
function keccak256(...args) {
  return utils.Conversion.toHexString(utils.EVM.keccak256(...args));
}

/**
 * Given an object, return a stable hash by first running it through a stable
 * stringify operation before hashing
 */
function stableKeccak256(obj) {
  return keccak256(stringify(obj));
}

/*
 * Given a mmemonic, determine whether it's the mnemonic of a calling
 * instruction (does NOT include creation instructions)
 */
function isCallMnemonic(op) {
  const calls = ["CALL", "DELEGATECALL", "STATICCALL", "CALLCODE"];
  return calls.includes(op);
}

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = require("reselect-tree");

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = require("redux-saga/effects");

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/entries");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/assign");

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = require("redux");

/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/helpers/extends");

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(7);

var _extends3 = _interopRequireDefault(_extends2);

var _entries = __webpack_require__(4);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(5);

var _assign2 = _interopRequireDefault(_assign);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(2);

var _truffleSolidityUtils = __webpack_require__(45);

var _truffleSolidityUtils2 = _interopRequireDefault(_truffleSolidityUtils);

var _truffleCodeUtils = __webpack_require__(46);

var _truffleCodeUtils2 = _interopRequireDefault(_truffleCodeUtils);

var _truffleDecodeUtils = __webpack_require__(10);

var TruffleDecodeUtils = _interopRequireWildcard(_truffleDecodeUtils);

var _map = __webpack_require__(24);

var _jsonPointer = __webpack_require__(14);

var _jsonPointer2 = _interopRequireDefault(_jsonPointer);

var _selectors = __webpack_require__(9);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:solidity:selectors");

const semver = __webpack_require__(50);

function getSourceRange(instruction = {}) {
  return {
    start: instruction.start || 0,
    length: instruction.length || 0,
    lines: instruction.range || {
      start: {
        line: 0,
        column: 0
      },
      end: {
        line: 0,
        column: 0
      }
    }
  };
}

let solidity = (0, _reselectTree.createSelectorTree)({
  /**
   * solidity.state
   */
  state: state => state.solidity,

  /**
   * solidity.info
   */
  info: {
    /**
     * solidity.info.sources
     */
    sources: (0, _reselectTree.createLeaf)(["/state"], state => state.info.sources.byId),

    /**
     * solidity.info.sourceMaps
     */
    sourceMaps: (0, _reselectTree.createLeaf)(["/state"], state => state.info.sourceMaps.byContext)
  },

  /**
   * solidity.current
   */
  current: {
    /**
     * solidity.current.sourceMap
     */
    sourceMap: (0, _reselectTree.createLeaf)([_selectors2.default.current.context, "/info/sourceMaps"], ({ context }, sourceMaps) => sourceMaps[context] || {}),

    /**
     * solidity.current.functionDepth
     */
    functionDepth: state => state.solidity.proc.functionDepth,

    /**
     * solidity.current.instructions
     */
    instructions: (0, _reselectTree.createLeaf)(["/info/sources", _selectors2.default.current.context, "./sourceMap"], (sources, { binary }, { sourceMap }) => {
      if (!binary) {
        return [];
      }

      let instructions = _truffleCodeUtils2.default.parseCode(binary);

      if (!sourceMap) {
        // Let's create a source map to use since none exists. This source map
        // maps just as many ranges as there are instructions, and ensures every
        // instruction is marked as "jumping out". This will ensure all
        // available debugger commands step one instruction at a time.
        //
        // This is kindof a hack; perhaps this should be broken out into separate
        // context types. TODO
        sourceMap = "";
        for (var i = 0; i < instructions.length; i++) {
          sourceMap += i + ":" + i + ":1:-1;";
        }
      }

      var lineAndColumnMappings = (0, _assign2.default)({}, ...(0, _entries2.default)(sources).map(([id, { source }]) => ({
        [id]: _truffleSolidityUtils2.default.getCharacterOffsetToLineAndColumnMapping(source || "")
      })));
      var humanReadableSourceMap = _truffleSolidityUtils2.default.getHumanReadableSourceMap(sourceMap);

      let primaryFile = humanReadableSourceMap[0].file;
      debug("primaryFile %o", primaryFile);

      return instructions.map((instruction, index) => {
        // lookup source map by index and add `index` property to
        // instruction
        //

        const sourceMap = humanReadableSourceMap[index] || {};

        return {
          instruction: (0, _extends3.default)({}, instruction, { index }),
          sourceMap
        };
      }).map(({ instruction, sourceMap }) => {
        // add source map information to instruction, or defaults
        //

        const {
          jump,
          start = 0,
          length = 0,
          file = primaryFile
        } = sourceMap;
        const lineAndColumnMapping = lineAndColumnMappings[file] || {};
        const range = {
          start: lineAndColumnMapping[start] || {
            line: null,
            column: null
          },
          end: lineAndColumnMapping[start + length] || {
            line: null,
            column: null
          }
        };

        if (range.start.line === null) {
          debug("sourceMap %o", sourceMap);
        }

        return (0, _extends3.default)({}, instruction, {

          jump,
          start,
          length,
          file,
          range
        });
      });
    }),

    /**
     * solidity.current.instructionAtProgramCounter
     */
    instructionAtProgramCounter: (0, _reselectTree.createLeaf)(["./instructions"], instructions => {
      let map = [];
      instructions.forEach(function (instruction) {
        map[instruction.pc] = instruction;
      });

      // fill in gaps in map by defaulting to the last known instruction
      let lastSeen = null;
      for (let [pc, instruction] of map.entries()) {
        if (instruction) {
          lastSeen = instruction;
        } else {
          map[pc] = lastSeen;
        }
      }
      return map;
    }),

    /**
     * solidity.current.instruction
     */
    instruction: (0, _reselectTree.createLeaf)(["./instructionAtProgramCounter", _selectors2.default.current.step.programCounter], (map, pc) => map[pc] || {}),

    /**
     * solidity.current.source
     */
    source: (0, _reselectTree.createLeaf)(["/info/sources", "./instruction"], (sources, { file: id }) => sources[id] || {}),

    /**
     * solidity.current.sourceRange
     */
    sourceRange: (0, _reselectTree.createLeaf)(["./instruction"], getSourceRange),

    /**
     * solidity.current.isSourceRangeFinal
     */
    isSourceRangeFinal: (0, _reselectTree.createLeaf)(["./instructionAtProgramCounter", _selectors2.default.current.step.programCounter, _selectors2.default.next.step.programCounter], (map, current, next) => {
      if (!map[next]) {
        return true;
      }

      current = map[current];
      next = map[next];

      return current.start != next.start || current.length != next.length || current.file != next.file;
    }),

    /**
     * solidity.current.isMultiline
     */
    isMultiline: (0, _reselectTree.createLeaf)(["./sourceRange"], ({ lines }) => lines.start.line != lines.end.line),

    /**
     * solidity.current.willJump
     */
    willJump: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.isJump], isJump => isJump),

    /**
     * solidity.current.jumpDirection
     */
    jumpDirection: (0, _reselectTree.createLeaf)(["./instruction"], (i = {}) => i.jump || "-"),

    /**
     * solidity.current.willCall
     */
    willCall: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.isCall], x => x),

    /**
     * solidity.current.willCreate
     */
    willCreate: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.isCreate], x => x),

    /**
     * solidity.current.callsPrecompile
     */
    callsPrecompile: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.callsPrecompile], x => x),

    /**
     * solidity.current.willReturn
     */
    willReturn: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.isHalting], isHalting => isHalting),

    //HACK: DUPLICATE CODE FOLLOWS
    //The following code duplicates some selectors in ast.
    //This exists to suppor the solidity.current.contractCall workaround below.
    //This should be cleaned up later.

    /**
     * solidity.current.pointer
     * HACK duplicates ast.current.pointer
     */
    pointer: (0, _reselectTree.createLeaf)(["./source", "./sourceRange"], ({ ast }, range) => (0, _map.findRange)(ast, range.start, range.length)),

    /**
     * solidity.current.node
     * HACK duplicates ast.current.node
     */
    node: (0, _reselectTree.createLeaf)(["./source", "./pointer"], ({ ast }, pointer) => pointer ? _jsonPointer2.default.get(ast, pointer) : _jsonPointer2.default.get(ast, "")),

    /**
     * solidity.current.isContractCall
     * HACK WORKAROUND (only applies to solc version <0.5.1)
     * this selector exists to work around a problem in solc
     * it attempts to detect whether the current node is a contract method call
     * (or library method call)
     * it will not successfully detect this if the method was first placed in a
     * function variable, only if it is being called directly
     */
    isContractCall: (0, _reselectTree.createLeaf)(["./node"], node => node !== undefined && node.nodeType === "FunctionCall" && node.expression !== undefined && node.expression.nodeType === "MemberAccess" && node.expression.expression !== undefined && (TruffleDecodeUtils.Definition.isContract(node.expression.expression) || TruffleDecodeUtils.Definition.isContractType(node.expression.expression))),

    /**
     * solidity.current.needsFunctionDepthWorkaround
     * HACK
     * Determines if the solidity version used for the contract about to be
     * called was <0.5.1, to determine whether to use the above workaround
     * Only call this if the current step is a call or create!
     */
    needsFunctionDepthWorkaround: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.callContext], context => context.compiler !== undefined && //would be undefined for e.g. a precompile
    context.compiler.name === "solc" && semver.satisfies(context.compiler.version, "<0.5.1"))
  }
});

exports.default = solidity;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = __webpack_require__(4);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(5);

var _assign2 = _interopRequireDefault(_assign);

var _extends2 = __webpack_require__(7);

var _extends3 = _interopRequireDefault(_extends2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(2);

var _fastLevenshtein = __webpack_require__(49);

var _fastLevenshtein2 = _interopRequireDefault(_fastLevenshtein);

var _selectors = __webpack_require__(16);

var _selectors2 = _interopRequireDefault(_selectors);

var _helpers = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:evm:selectors"); // eslint-disable-line no-unused-vars

function findContext({ address, binary }, instances, search, contexts) {
  let record;
  if (address) {
    record = instances[address];
    if (!record) {
      return { address };
    }
    binary = record.binary;
  } else {
    record = search(binary);
  }

  let context = contexts[(record || {}).context];

  return (0, _extends3.default)({}, context, {
    binary
  });
}

/**
 * create EVM-level selectors for a given trace step selector
 * may specify additional selectors to include
 */
function createStepSelectors(step, state = null) {
  let base = {
    /**
     * .trace
     *
     * trace step info related to operation
     */
    trace: (0, _reselectTree.createLeaf)([step], ({ gasCost, op, pc }) => ({ gasCost, op, pc })),

    /**
     * .programCounter
     */
    programCounter: (0, _reselectTree.createLeaf)(["./trace"], step => step.pc),

    /**
     * .isJump
     */
    isJump: (0, _reselectTree.createLeaf)(["./trace"], step => step.op != "JUMPDEST" && step.op.indexOf("JUMP") == 0),

    /**
     * .isCall
     *
     * whether the opcode will switch to another calling context
     */
    isCall: (0, _reselectTree.createLeaf)(["./trace"], step => (0, _helpers.isCallMnemonic)(step.op)),

    /**
     * .isCreate
     */
    isCreate: (0, _reselectTree.createLeaf)(["./trace"], step => step.op == "CREATE"),

    /**
     * .isHalting
     *
     * whether the instruction halts or returns from a calling context
     */
    isHalting: (0, _reselectTree.createLeaf)(["./trace"], step => step.op == "STOP" || step.op == "RETURN")
  };

  if (state) {
    const isRelative = path => typeof path == "string" && (path.startsWith("./") || path.startsWith("../"));

    if (isRelative(state)) {
      state = `../${state}`;
    }

    (0, _assign2.default)(base, {
      /**
       * .callAddress
       *
       * address transferred to by call operation
       */
      callAddress: (0, _reselectTree.createLeaf)(["./isCall", "./trace", state], (matches, step, { stack }) => {
        if (!matches) return null;

        let address = stack[stack.length - 2];
        address = "0x" + address.substring(24);
        return address;
      }),

      /**
       * .createBinary
       *
       * binary code to execute via create operation
       */
      createBinary: (0, _reselectTree.createLeaf)(["./isCreate", "./trace", state], (matches, step, { stack, memory }) => {
        if (!matches) return null;

        // Get the code that's going to be created from memory.
        // Note we multiply by 2 because these offsets are in bytes.
        const offset = parseInt(stack[stack.length - 2], 16) * 2;
        const length = parseInt(stack[stack.length - 3], 16) * 2;

        return "0x" + memory.join("").substring(offset, offset + length);
      }),

      /**
       * .callContext
       *
       * context for what we're about to call into (or create)
       */
      callContext: (0, _reselectTree.createLeaf)(["./callAddress", "./createBinary", "/info/instances", "/info/binaries/search", "/info/contexts"], (address, binary, instances, search, contexts) => findContext({ address, binary }, instances, search, contexts)),

      /**
       * .callsPrecompile
       *
       * is the call address to a precompiled contract?
       * HACK
       */
      callsPrecompile: (0, _reselectTree.createLeaf)(["./callAddress", "/info/contexts", "/info/instances"], (address, contexts, instances) => {
        if (!address) return null;

        let { context } = instances[address] || {};
        let { binary } = contexts[context] || {};
        return !binary;
      })
    });
  }

  return base;
}

const evm = (0, _reselectTree.createSelectorTree)({
  /**
   * evm.state
   */
  state: state => state.evm,

  /**
   * evm.info
   */
  info: {
    /**
     * evm.info.contexts
     */
    contexts: (0, _reselectTree.createLeaf)(["/state"], state => state.info.contexts.byContext),

    /**
     * evm.info.instances
     */
    instances: (0, _reselectTree.createLeaf)(["/state"], state => state.info.instances.byAddress),

    /**
     * evm.info.binaries
     */
    binaries: {
      _: (0, _reselectTree.createLeaf)(["/state"], state => state.info.contexts.byBinary),

      /**
       * evm.info.binaries.search
       *
       * returns function (binary) => context
       */
      search: (0, _reselectTree.createLeaf)(["./_"], binaries => binary => {
        // search for a given binary based on levenshtein distances to
        // existing (known) context binaries.
        //
        // levenshtein distance is the number of textual modifications
        // (insert, change, delete) required to convert string a to b
        //
        // filter by a percentage threshold
        const threshold = 0.25;

        // skip levenshtein check for undefined binaries
        if (!binary || binary == "0x0") {
          return {};
        }

        const results = (0, _entries2.default)(binaries).map(([knownBinary, { context }]) => ({
          context,
          distance: _fastLevenshtein2.default.get(knownBinary, binary)
        })).filter(({ distance }) => distance <= binary.length * threshold).sort(({ distance: a }, { distance: b }) => a - b);

        if (results[0]) {
          const { context } = results[0];
          return { context };
        }

        return {};
      })
    }
  },

  /**
   * evm.current
   */
  current: {
    /**
     * evm.current.callstack
     */
    callstack: state => state.evm.proc.callstack,

    /**
     * evm.current.call
     */
    call: (0, _reselectTree.createLeaf)(["./callstack"], stack => stack.length ? stack[stack.length - 1] : {}),

    /**
     * evm.current.creationDepth
     * how many creation calls are currently on the call stack?
     */
    creationDepth: (0, _reselectTree.createLeaf)(["./callstack"], stack => stack.filter(call => call.address === undefined).length),

    /**
     * evm.current.context
     */
    context: (0, _reselectTree.createLeaf)(["./call", "/info/instances", "/info/binaries/search", "/info/contexts"], findContext),

    /**
     * evm.current.state
     *
     * evm state info: as of last operation, before op defined in step
     */
    state: (0, _assign2.default)({}, ...["depth", "error", "gas", "memory", "stack", "storage"].map(param => ({
      [param]: (0, _reselectTree.createLeaf)([_selectors2.default.step], step => step[param])
    }))),

    /**
     * evm.current.step
     */
    step: createStepSelectors(_selectors2.default.step, "./state")
  },

  /**
   * evm.next
   */
  next: {
    /**
     * evm.next.state
     *
     * evm state as a result of next step operation
     */
    state: (0, _assign2.default)({}, ...["depth", "error", "gas", "memory", "stack", "storage"].map(param => ({
      [param]: (0, _reselectTree.createLeaf)([_selectors2.default.next], step => step[param])
    }))),

    step: createStepSelectors(_selectors2.default.next, "./state")
  }
});

exports.default = evm;

/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = require("truffle-decode-utils");

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.saveSteps = saveSteps;
exports.receiveAddresses = receiveAddresses;
exports.next = next;
exports.tick = tick;
exports.tock = tock;
exports.endTrace = endTrace;
exports.reset = reset;
const SAVE_STEPS = exports.SAVE_STEPS = "SAVE_STEPS";
function saveSteps(steps) {
  return {
    type: SAVE_STEPS,
    steps
  };
}

const RECEIVE_ADDRESSES = exports.RECEIVE_ADDRESSES = "RECEIVE_ADDRESSES";
function receiveAddresses(addresses) {
  return {
    type: RECEIVE_ADDRESSES,
    addresses
  };
}

const NEXT = exports.NEXT = "NEXT";
function next() {
  return { type: NEXT };
}

const TICK = exports.TICK = "TICK";
function tick() {
  return { type: TICK };
}

const TOCK = exports.TOCK = "TOCK";
function tock() {
  return { type: TOCK };
}

const END_OF_TRACE = exports.END_OF_TRACE = "EOT";
function endTrace() {
  return { type: END_OF_TRACE };
}

const RESET = exports.RESET = "TRACE_RESET";
function reset() {
  return { type: RESET };
}

/***/ }),
/* 12 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/helpers/asyncToGenerator");

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.start = start;
exports.ready = ready;
exports.error = error;
exports.recordContracts = recordContracts;
exports.saveTransaction = saveTransaction;
exports.saveReceipt = saveReceipt;
const START = exports.START = "SESSION_START";
function start(txHash, provider) {
  return {
    type: START,
    txHash,
    provider
  };
}

const READY = exports.READY = "SESSION_READY";
function ready() {
  return {
    type: READY
  };
}

const ERROR = exports.ERROR = "SESSION_ERROR";
function error(error) {
  return {
    type: ERROR,
    error
  };
}

const RECORD_CONTRACTS = exports.RECORD_CONTRACTS = "RECORD_CONTRACTS";
function recordContracts(contexts, sources) {
  return {
    type: RECORD_CONTRACTS,
    contexts,
    sources
  };
}

const SAVE_TRANSACTION = exports.SAVE_TRANSACTION = "SAVE_TRANSACTION";
function saveTransaction(transaction) {
  return {
    type: SAVE_TRANSACTION,
    transaction
  };
}

const SAVE_RECEIPT = exports.SAVE_RECEIPT = "SAVE_RECEIPT";
function saveReceipt(receipt) {
  return {
    type: SAVE_RECEIPT,
    receipt
  };
}

/***/ }),
/* 14 */
/***/ (function(module, exports) {

module.exports = require("json-pointer");

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(2);

var _jsonPointer = __webpack_require__(14);

var _jsonPointer2 = _interopRequireDefault(_jsonPointer);

var _selectors = __webpack_require__(8);

var _selectors2 = _interopRequireDefault(_selectors);

var _map = __webpack_require__(24);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:ast:selectors");

/**
 * ast
 */
const ast = (0, _reselectTree.createSelectorTree)({
  /**
   * ast.views
   */
  views: {
    /**
     * ast.views.sources
     */
    sources: (0, _reselectTree.createLeaf)([_selectors2.default.info.sources], sources => sources)
  },

  /**
   * ast.current
   */
  current: {

    /**
     * ast.current.tree
     *
     * ast for current source
     */
    tree: (0, _reselectTree.createLeaf)([_selectors2.default.current.source], ({ ast }) => ast),

    /**
     * ast.current.index
     *
     * source ID
     */
    index: (0, _reselectTree.createLeaf)([_selectors2.default.current.source], ({ id }) => id),

    /**
     * ast.current.pointer
     *
     * jsonpointer for current ast node
     */
    pointer: (0, _reselectTree.createLeaf)(["./tree", _selectors2.default.current.sourceRange], (ast, range) => (0, _map.findRange)(ast, range.start, range.length)),

    /**
     * ast.current.node
     *
     * current ast node to execute
     */
    node: (0, _reselectTree.createLeaf)(["./tree", "./pointer"], (ast, pointer) => pointer ? _jsonPointer2.default.get(ast, pointer) : _jsonPointer2.default.get(ast, ""))

  }
});

exports.default = ast;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _reselectTree = __webpack_require__(2);

let trace = (0, _reselectTree.createSelectorTree)({
  /**
   * trace.index
   *
   * current step index
   */
  index: state => state.trace.proc.index,

  /**
   * trace.finished
   *
   * is the trace finished?
   */
  finished: state => state.trace.proc.finished,

  /**
   * trace.steps
   *
   * all trace steps
   */
  steps: state => state.trace.info.steps,

  /**
   * trace.stepsRemaining
   *
   * number of steps remaining in trace
   */
  stepsRemaining: (0, _reselectTree.createLeaf)(["./steps", "./index"], (steps, index) => steps.length - index),

  /**
   * trace.step
   *
   * current trace step
   */
  step: (0, _reselectTree.createLeaf)(["./steps", "./index"], (steps, index) => steps[index]),

  /**
   * trace.next
   *
   * next trace step
   * HACK: if at the end,
   * we will return the *same* trace step
   */
  next: (0, _reselectTree.createLeaf)(["./steps", "./index"], (steps, index) => index < steps.length - 1 ? steps[index + 1] : steps[index])
});

exports.default = trace;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(7);

var _extends3 = _interopRequireDefault(_extends2);

var _assign = __webpack_require__(5);

var _assign2 = _interopRequireDefault(_assign);

exports.scope = scope;
exports.declare = declare;
exports.reset = reset;
exports.learnAddressSaga = learnAddressSaga;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(3);

var _jsonPointer = __webpack_require__(14);

var _jsonPointer2 = _interopRequireDefault(_jsonPointer);

var _helpers = __webpack_require__(1);

var _actions = __webpack_require__(11);

var _actions2 = __webpack_require__(25);

var actions = _interopRequireWildcard(_actions2);

var _selectors = __webpack_require__(21);

var _selectors2 = _interopRequireDefault(_selectors);

var _truffleDecodeUtils = __webpack_require__(10);

var TruffleDecodeUtils = _interopRequireWildcard(_truffleDecodeUtils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:data:sagas"); // eslint-disable-line no-unused-vars

function* scope(nodeId, pointer, parentId, sourceId) {
  yield (0, _effects.put)(actions.scope(nodeId, pointer, parentId, sourceId));
}

function* declare(node) {
  yield (0, _effects.put)(actions.declare(node));
}

function* tickSaga() {
  let { tree, id: treeId, node, pointer } = yield (0, _effects.select)(_selectors2.default.views.ast);

  let decode = yield (0, _effects.select)(_selectors2.default.views.decoder);
  let scopes = yield (0, _effects.select)(_selectors2.default.info.scopes);
  let definitions = yield (0, _effects.select)(_selectors2.default.views.scopes.inlined);
  let currentAssignments = yield (0, _effects.select)(_selectors2.default.proc.assignments);
  let currentDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
  let address = yield (0, _effects.select)(_selectors2.default.current.address); //may be undefined
  let dummyAddress = yield (0, _effects.select)(_selectors2.default.current.dummyAddress);

  let stack = yield (0, _effects.select)(_selectors2.default.next.state.stack);
  if (!stack) {
    return;
  }

  let top = stack.length - 1;
  var parameters, returnParameters, assignment, assignments;

  if (!node) {
    return;
  }

  // stack is only ready for interpretation after the last step of each
  // source range
  //
  // the data module always looks at the result of a particular opcode
  // (i.e., the following trace step's stack/memory/storage), so this
  // asserts that the _current_ operation is the final one before
  // proceeding
  if (!(yield (0, _effects.select)(_selectors2.default.views.atLastInstructionForSourceRange))) {
    return;
  }

  switch (node.nodeType) {
    case "FunctionDefinition":
      parameters = node.parameters.parameters.map((p, i) => `${pointer}/parameters/parameters/${i}`);

      returnParameters = node.returnParameters.parameters.map((p, i) => `${pointer}/returnParameters/parameters/${i}`);

      assignments = {
        byId: (0, _assign2.default)({}, ...returnParameters.concat(parameters).reverse().map(pointer => _jsonPointer2.default.get(tree, pointer).id)
        //note: depth may be off by 1 but it doesn't matter
        .map((id, i) => makeAssignment({ astId: id, stackframe: currentDepth }, { stack: top - i })).map(assignment => {
          return { [assignment.id]: assignment };
          //awkward, but seems to be only way to return an object literal
        }))
      };
      debug("Function definition case");
      debug("assignments %O", assignments);

      yield (0, _effects.put)(actions.assign(treeId, assignments));
      break;

    case "ContractDefinition":
      let storageVars = scopes[node.id].variables || [];
      debug("storage vars %o", storageVars);

      let allocation = TruffleDecodeUtils.Allocation.allocateDeclarations(storageVars, definitions);
      debug("Contract definition case");
      debug("allocation %O", allocation);
      assignments = { byId: {} };
      for (let id in allocation.children) {
        id = Number(id); //not sure why we're getting them as strings, but...
        let idObj;
        if (address !== undefined) {
          idObj = { astId: id, address };
        } else {
          idObj = { astId: id, dummyAddress };
        }
        let fullId = (0, _helpers.stableKeccak256)(idObj);
        //we don't use makeAssignment here as we had to compute the ID anyway
        assignment = (0, _extends3.default)({}, idObj, {
          id: fullId,
          ref: (0, _extends3.default)({}, (currentAssignments.byId[fullId] || {}).ref || {}, {
            storage: allocation.children[id]
          })
        });
        assignments.byId[fullId] = assignment;
      }
      debug("assignments %O", assignments);

      yield (0, _effects.put)(actions.assign(treeId, assignments));
      break;

    case "VariableDeclaration":
      let varId = _jsonPointer2.default.get(tree, pointer).id;
      debug("Variable declaration case");
      debug("currentDepth %d varId %d", currentDepth, varId);

      //NOTE: We're going to make the assignment conditional here; here's why.
      //There's a bug where calling the autogenerated accessor for a public
      //contract variable causes the debugger to see two additional
      //declarations for that variable... which this code reads as local
      //variable declarations.  Rather than prevent this at the source, we're
      //just going to check for it here, by not adding a local variable if said
      //variable is already a contract variable.

      if (currentAssignments.byAstId[varId] !== undefined && currentAssignments.byAstId[varId].some(id => currentAssignments.byId[id].address !== undefined || currentAssignments.byId[id].dummyAddress !== undefined)) {
        break;
      }

      //otherwise, go ahead and make the assignment
      assignment = makeAssignment({ astId: varId, stackframe: currentDepth }, { stack: top });
      assignments = { byId: { [assignment.id]: assignment } };
      yield (0, _effects.put)(actions.assign(treeId, assignments));
      break;

    case "IndexAccess":
      // to track `mapping` types known indexes
      yield (0, _effects.put)(actions.mapKeyDecoding(true));

      let {
        baseExpression: { referencedDeclaration: baseDeclarationId },
        indexExpression: { id: indexId }
      } = node;

      //indices need to be identified by stackframe
      let indexIdObj = { astId: indexId, stackframe: currentDepth };
      let fullIndexId = (0, _helpers.stableKeccak256)(indexIdObj);

      debug("Index access case");

      const indexAssignment = (currentAssignments.byId[fullIndexId] || {}).ref;
      debug("indexAssignment %O", indexAssignment);
      // HACK because string literal AST nodes are not sourcemapped to directly
      // value appears to be available in `node.indexExpression.hexValue`
      // [observed with solc v0.4.24]
      let indexValue;
      if (indexAssignment) {
        indexValue = yield (0, _effects.call)(decode, node.indexExpression, indexAssignment);
      } else if (TruffleDecodeUtils.Definition.typeClass(node.indexExpression) == "stringliteral") {
        indexValue = yield (0, _effects.call)(decode, node.indexExpression, {
          literal: TruffleDecodeUtils.Conversion.toBytes(node.indexExpression.hexValue)
        });
      }

      debug("index value %O", indexValue);
      if (indexValue !== undefined) {
        yield (0, _effects.put)(actions.mapKey(baseDeclarationId, indexValue));
      }

      yield (0, _effects.put)(actions.mapKeyDecoding(false));

      break;

    case "Assignment":
      break;

    default:
      if (node.typeDescriptions == undefined) {
        break;
      }

      debug("decoding expression value %O", node.typeDescriptions);
      let literal = stack[top];

      debug("default case");
      debug("currentDepth %d node.id %d", currentDepth, node.id);
      assignment = makeAssignment({ astId: node.id, stackframe: currentDepth }, { literal });
      assignments = { byId: { [assignment.id]: assignment } };
      yield (0, _effects.put)(actions.assign(treeId, assignments));
      break;
  }
}

function* reset() {
  yield (0, _effects.put)(actions.reset());
}

function* learnAddressSaga(dummyAddress, address) {
  debug("about to learn an address");
  yield (0, _effects.put)(actions.learnAddress(dummyAddress, address));
  debug("address learnt");
}

function makeAssignment(idObj, ref) {
  let id = (0, _helpers.stableKeccak256)(idObj);
  return (0, _extends3.default)({}, idObj, { id, ref });
}

function* saga() {
  yield (0, _effects.takeEvery)(_actions.TICK, function* () {
    try {
      yield* tickSaga();
    } catch (e) {
      debug("ERROR: %O", e);
    }
  });
}

exports.default = (0, _helpers.prefixName)("data", saga);

/***/ }),
/* 18 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/set");

/***/ }),
/* 19 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/promise");

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.beginStep = beginStep;
exports.advance = advance;
exports.stepNext = stepNext;
exports.stepOver = stepOver;
exports.stepInto = stepInto;
exports.stepOut = stepOut;
exports.reset = reset;
exports.interrupt = interrupt;
exports.continueUntilBreakpoint = continueUntilBreakpoint;
exports.addBreakpoint = addBreakpoint;
exports.removeBreakpoint = removeBreakpoint;
exports.removeAllBreakpoints = removeAllBreakpoints;
const BEGIN_STEP = exports.BEGIN_STEP = "BEGIN_STEP";
function beginStep(type) {
  return {
    type: BEGIN_STEP,
    stepType: type
  };
}

const ADVANCE = exports.ADVANCE = "ADVANCE";
function advance() {
  return { type: ADVANCE };
}

const STEP_NEXT = exports.STEP_NEXT = "STEP_NEXT";
function stepNext() {
  return { type: STEP_NEXT };
}

const STEP_OVER = exports.STEP_OVER = "STEP_OVER";
function stepOver() {
  return { type: STEP_OVER };
}

const STEP_INTO = exports.STEP_INTO = "STEP_INTO";
function stepInto() {
  return { type: STEP_INTO };
}

const STEP_OUT = exports.STEP_OUT = "STEP_OUT";
function stepOut() {
  return { type: STEP_OUT };
}

const RESET = exports.RESET = "RESET";
function reset() {
  return { type: RESET };
}

const INTERRUPT = exports.INTERRUPT = "INTERRUPT";
function interrupt() {
  return { type: INTERRUPT };
}

const CONTINUE = exports.CONTINUE = "CONTINUE";
function continueUntilBreakpoint() {
  //"continue" is not a legal name
  return { type: CONTINUE };
}

const ADD_BREAKPOINT = exports.ADD_BREAKPOINT = "ADD_BREAKPOINT";
function addBreakpoint(breakpoint) {
  return {
    type: ADD_BREAKPOINT,
    breakpoint
  };
}

const REMOVE_BREAKPOINT = exports.REMOVE_BREAKPOINT = "REMOVE_BREAKPOINT";
function removeBreakpoint(breakpoint) {
  return {
    type: REMOVE_BREAKPOINT,
    breakpoint
  };
}

const REMOVE_ALL_BREAKPOINTS = exports.REMOVE_ALL_BREAKPOINTS = "REMOVE_ALL_BREAKPOINTS";
function removeAllBreakpoints() {
  return {
    type: REMOVE_ALL_BREAKPOINTS
  };
}

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = __webpack_require__(19);

var _promise2 = _interopRequireDefault(_promise);

var _asyncToGenerator2 = __webpack_require__(12);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _extends2 = __webpack_require__(7);

var _extends3 = _interopRequireDefault(_extends2);

var _entries = __webpack_require__(4);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(5);

var _assign2 = _interopRequireDefault(_assign);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(2);

var _jsonPointer = __webpack_require__(14);

var _jsonPointer2 = _interopRequireDefault(_jsonPointer);

var _helpers = __webpack_require__(1);

var _selectors = __webpack_require__(15);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(9);

var _selectors4 = _interopRequireDefault(_selectors3);

var _selectors5 = __webpack_require__(8);

var _selectors6 = _interopRequireDefault(_selectors5);

var _truffleDecodeUtils = __webpack_require__(10);

var TruffleDecodeUtils = _interopRequireWildcard(_truffleDecodeUtils);

var _truffleDecoder = __webpack_require__(51);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:data:selectors"); // eslint-disable-line no-unused-vars

/**
 * @private
 */
const identity = x => x;

function createStateSelectors({ stack, memory, storage }) {
  return {
    /**
     * .stack
     */
    stack: (0, _reselectTree.createLeaf)([stack], words => (words || []).map(word => TruffleDecodeUtils.Conversion.toBytes(TruffleDecodeUtils.Conversion.toBN(word, TruffleDecodeUtils.EVM.WORD_SIZE)))),

    /**
     * .memory
     */
    memory: (0, _reselectTree.createLeaf)([memory], words => new Uint8Array((words.join("").match(/.{1,2}/g) || []).map(byte => parseInt(byte, 16)))),

    /**
     * .storage
     */
    storage: (0, _reselectTree.createLeaf)([storage], mapping => (0, _assign2.default)({}, ...(0, _entries2.default)(mapping).map(([address, word]) => ({
      [`0x${address}`]: new Uint8Array((word.match(/.{1,2}/g) || []).map(byte => parseInt(byte, 16)))
    }))))
  };
}

const data = (0, _reselectTree.createSelectorTree)({
  state: state => state.data,

  /**
   * data.views
   */
  views: {
    ast: (0, _reselectTree.createLeaf)([_selectors2.default.current], tree => tree),

    atLastInstructionForSourceRange: (0, _reselectTree.createLeaf)([_selectors6.default.current.isSourceRangeFinal], final => final),

    /**
     * data.views.scopes
     */
    scopes: {
      /**
       * data.views.scopes.inlined
       */
      inlined: (0, _reselectTree.createLeaf)(["/info/scopes", _selectors6.default.info.sources], (scopes, sources) => (0, _assign2.default)({}, ...(0, _entries2.default)(scopes).map(([id, entry]) => ({
        [id]: (0, _extends3.default)({}, entry, {

          definition: _jsonPointer2.default.get(sources[entry.sourceId].ast, entry.pointer)
        })
      }))))
    },

    /**
     * data.views.decoder
     *
     * selector returns (ast node definition, data reference) => Promise<value>
     */
    decoder: (0, _reselectTree.createLeaf)(["/views/scopes/inlined", "/next/state", "/proc/mappingKeys"], (scopes, state, mappingKeys) => (definition, ref) => (0, _truffleDecoder.forEvmState)(definition, ref, {
      scopes,
      state,
      mappingKeys
    }))
  },

  /**
   * data.info
   */
  info: {
    /**
     * data.info.scopes
     */
    scopes: (0, _reselectTree.createLeaf)(["/state"], state => state.info.scopes.byId)
  },

  /**
   * data.proc
   */
  proc: {
    /**
     * data.proc.assignments
     */
    assignments: (0, _reselectTree.createLeaf)(["/state"], state => state.proc.assignments
    //note: this no longer fetches just the byId, but rather the whole
    //assignments object
    ),

    /**
     * data.proc.mappingKeys
     *
     * known keys for each mapping (identified by node ID)
     */
    mappingKeys: (0, _reselectTree.createLeaf)(["/state"], state => state.proc.mappingKeys.byId),

    /**
     * data.proc.decodingMappingKeys
     *
     * number of mapping keys that are still decoding
     */
    decodingMappingKeys: (0, _reselectTree.createLeaf)(["/state"], state => state.proc.mappingKeys.decodingStarted)
  },

  /**
   * data.current
   */
  current: {
    /**
     *
     * data.current.scope
     */
    scope: {
      /**
       * data.current.scope.id
       */
      id: (0, _reselectTree.createLeaf)([_selectors2.default.current.node], node => node.id)
    },

    /**
     * data.current.state
     */
    state: createStateSelectors(_selectors4.default.current.state),

    /**
     * data.current.functionDepth
     */

    functionDepth: (0, _reselectTree.createLeaf)([_selectors6.default.current.functionDepth], identity),

    /**
     * data.current.address
     * Note: May be undefined (if in an initializer)
     */

    address: (0, _reselectTree.createLeaf)([_selectors4.default.current.call], call => call.address),

    /**
     * data.current.dummyAddress
     */

    dummyAddress: (0, _reselectTree.createLeaf)([_selectors4.default.current.creationDepth], identity),

    /**
     * data.current.identifiers (namespace)
     */
    identifiers: {
      /**
       * data.current.identifiers (selector)
       *
       * returns identifers and corresponding definition node ID
       */
      _: (0, _reselectTree.createLeaf)(["/views/scopes/inlined", "/current/scope"], (scopes, scope) => {
        let cur = scope.id;
        let variables = {};

        do {
          variables = (0, _assign2.default)(variables, ...(scopes[cur].variables || []).filter(v => v.name !== "") //exclude anonymous output params
          .filter(v => variables[v.name] == undefined).map(v => ({ [v.name]: v.id })));

          cur = scopes[cur].parentId;
        } while (cur != null);

        return variables;
      }),

      /**
       * data.current.identifiers.definitions
       *
       * current variable definitions
       */
      definitions: (0, _reselectTree.createLeaf)(["/views/scopes/inlined", "./_"], (scopes, identifiers) => (0, _assign2.default)({}, ...(0, _entries2.default)(identifiers).map(([identifier, id]) => {
        let { definition } = scopes[id];

        return { [identifier]: definition };
      }))),

      /**
       * data.current.identifiers.refs
       *
       * current variables' value refs
       */
      refs: (0, _reselectTree.createLeaf)(["/proc/assignments", "./_", _selectors6.default.current.functionDepth, //for pruning things too deep on stack
      "/current/address", //for contract variables
      "/current/dummyAddress" //for contract vars when in creation call
      ], (assignments, identifiers, currentDepth, address, dummyAddress) => (0, _assign2.default)({}, ...(0, _entries2.default)(identifiers).map(([identifier, astId]) => {
        //note: this needs tweaking for specials later
        let id;

        //first, check if it's a contract var
        if (address !== undefined) {
          let matchIds = (assignments.byAstId[astId] || []).filter(idHash => assignments.byId[idHash].address === address);
          if (matchIds.length > 0) {
            id = matchIds[0]; //there should only be one!
          }
        } else {
          let matchIds = (assignments.byAstId[astId] || []).filter(idHash => assignments.byId[idHash].dummyAddress === dummyAddress);
          if (matchIds.length > 0) {
            id = matchIds[0]; //again, there should only be one!
          }
        }

        //if not contract, it's local, so find the innermost
        //(but not beyond current depth)
        if (id === undefined) {
          let matchFrames = (assignments.byAstId[astId] || []).map(id => assignments.byId[id].stackframe).filter(stackframe => stackframe !== undefined);

          if (matchFrames.length > 0) {
            //this check isn't *really*
            //necessary, but may as well prevent stupid stuff
            let maxMatch = Math.min(currentDepth, Math.max(...matchFrames));
            id = (0, _helpers.stableKeccak256)({ astId, stackframe: maxMatch });
          }
        }

        //if we still didn't find it, oh well

        let { ref } = assignments.byId[id] || {};
        if (!ref) {
          return undefined;
        }

        return {
          [identifier]: ref
        };
      }))),

      /**
       * data.current.identifiers.decoded
       *
       * Returns an object with values as Promises
       */
      decoded: (0, _reselectTree.createLeaf)(["/views/decoder", "./definitions", "./refs"], (() => {
        var _ref = (0, _asyncToGenerator3.default)(function* (decode, definitions, refs) {
          const keyedPromises = (0, _entries2.default)(refs).map((() => {
            var _ref2 = (0, _asyncToGenerator3.default)(function* ([identifier, ref]) {
              return {
                [identifier]: yield decode(definitions[identifier], ref)
              };
            });

            return function (_x4) {
              return _ref2.apply(this, arguments);
            };
          })());
          const keyedResults = yield _promise2.default.all(keyedPromises);
          return TruffleDecodeUtils.Conversion.cleanMappings((0, _assign2.default)({}, ...keyedResults));
        });

        return function (_x, _x2, _x3) {
          return _ref.apply(this, arguments);
        };
      })()),

      /**
       * data.current.identifiers.native
       *
       * Returns an object with values as Promises
       */
      native: (0, _reselectTree.createLeaf)(["./decoded"], (() => {
        var _ref3 = (0, _asyncToGenerator3.default)(function* (decoded) {
          return TruffleDecodeUtils.Conversion.cleanBNs((yield decoded));
        });

        return function (_x5) {
          return _ref3.apply(this, arguments);
        };
      })())
    }
  },

  /**
   * data.next
   */
  next: {
    /**
     * data.next.state
     */
    state: createStateSelectors(_selectors4.default.next.state)
  }
});

exports.default = data;

/***/ }),
/* 22 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/keys");

/***/ }),
/* 23 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/object/values");

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = __webpack_require__(22);

var _keys2 = _interopRequireDefault(_keys);

exports.getRange = getRange;
exports.rangeNodes = rangeNodes;
exports.findRange = findRange;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _nodeIntervalTree = __webpack_require__(47);

var _nodeIntervalTree2 = _interopRequireDefault(_nodeIntervalTree);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:ast:map");

/**
 * @private
 */
function getRange(node) {
  // src: "<start>:<length>:<_>"
  // returns [start, end]
  let [start, length] = node.src.split(":").slice(0, 2).map(i => parseInt(i));

  return [start, start + length];
}

/**
 * @private
 */
function rangeNodes(node, pointer = "") {
  if (node instanceof Array) {
    return [].concat(...node.map((sub, i) => rangeNodes(sub, `${pointer}/${i}`)));
  } else if (node instanceof Object) {
    let results = [];

    if (node.src) {
      results.push({ pointer, range: getRange(node) });
    }

    return results.concat(...(0, _keys2.default)(node).map(key => rangeNodes(node[key], `${pointer}/${key}`)));
  } else {
    return [];
  }
}

/**
 * @private
 */
function findRange(node, sourceStart, sourceLength) {
  let ranges = rangeNodes(node);
  let tree = new _nodeIntervalTree2.default();

  ranges.forEach(({ range, pointer }) => {
    let [start, end] = range;

    tree.insert(start, end, { range, pointer });
  });

  let sourceEnd = sourceStart + sourceLength;

  let overlapping = tree.search(sourceStart, sourceEnd);

  // find nodes that fully contain requested range,
  // return longest pointer
  return overlapping.filter(({ range }) => sourceStart >= range[0] && sourceEnd <= range[1]).map(({ pointer }) => pointer).reduce((a, b) => a.length > b.length ? a : b, "");
}

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.scope = scope;
exports.declare = declare;
exports.assign = assign;
exports.mapKey = mapKey;
exports.mapKeyDecoding = mapKeyDecoding;
exports.reset = reset;
exports.learnAddress = learnAddress;
const SCOPE = exports.SCOPE = "SCOPE";
function scope(id, pointer, parentId, sourceId) {
  return {
    type: SCOPE,
    id,
    pointer,
    parentId,
    sourceId
  };
}

const DECLARE = exports.DECLARE = "DECLARE_VARIABLE";
function declare(node) {
  return {
    type: DECLARE,
    node
  };
}

const ASSIGN = exports.ASSIGN = "ASSIGN";
function assign(context, assignments) {
  return {
    type: ASSIGN,
    context,
    assignments
  };
}

const MAP_KEY = exports.MAP_KEY = "MAP_KEY";
function mapKey(id, key) {
  return {
    type: MAP_KEY,
    id,
    key
  };
}

const MAP_KEY_DECODING = exports.MAP_KEY_DECODING = "MAP_KEY_DECODING";
function mapKeyDecoding(started) {
  return {
    type: MAP_KEY_DECODING,
    started
  };
}

const RESET = exports.RESET = "DATA_RESET";
function reset() {
  return { type: RESET };
}

const LEARN_ADDRESS = exports.LEARN_ADDRESS = "LEARN_ADDRESS";
function learnAddress(dummyAddress, address) {
  return {
    type: LEARN_ADDRESS,
    dummyAddress,
    address
  };
}

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = __webpack_require__(18);

var _set2 = _interopRequireDefault(_set);

exports.advance = advance;
exports.processTrace = processTrace;
exports.reset = reset;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(3);

var _helpers = __webpack_require__(1);

var _actions = __webpack_require__(11);

var actions = _interopRequireWildcard(_actions);

var _selectors = __webpack_require__(16);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:trace:sagas");

function* waitForTrace() {
  let { steps } = yield (0, _effects.take)(actions.SAVE_STEPS);

  let addresses = [...new _set2.default(steps.filter(({ op }) => (0, _helpers.isCallMnemonic)(op)).map(({ stack }) => "0x" + stack[stack.length - 2].substring(24)))];

  yield (0, _effects.put)(actions.receiveAddresses(addresses));
}

function* advance() {
  yield (0, _effects.put)(actions.next());

  debug("TOCK to take");
  yield (0, _effects.take)([actions.TOCK, actions.END_OF_TRACE]);
  debug("TOCK taken");
}

function* next() {
  let remaining = yield (0, _effects.select)(_selectors2.default.stepsRemaining);
  debug("remaining: %o", remaining);
  let steps = yield (0, _effects.select)(_selectors2.default.steps);
  debug("total steps: %o", steps.length);

  if (remaining > 0) {
    debug("putting TICK");
    // updates state for current step
    yield (0, _effects.put)(actions.tick());
    debug("put TICK");

    remaining--; // local update, just for convenience
  }

  if (remaining) {
    debug("putting TOCK");
    // updates step to next step in trace
    yield (0, _effects.put)(actions.tock());
    debug("put TOCK");
  } else {
    debug("putting END_OF_TRACE");
    yield (0, _effects.put)(actions.endTrace());
    debug("put END_OF_TRACE");
  }
}

function* processTrace(trace) {
  yield (0, _effects.put)(actions.saveSteps(trace));

  let { addresses } = yield (0, _effects.take)(actions.RECEIVE_ADDRESSES);
  debug("received addresses");

  return addresses;
}

function* reset() {
  yield (0, _effects.put)(actions.reset());
}

function* saga() {
  // wait for trace to be defined
  yield* waitForTrace();

  yield (0, _effects.takeEvery)(actions.NEXT, next);
}

exports.default = (0, _helpers.prefixName)("trace", saga);

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addContext = addContext;
exports.addInstance = addInstance;
exports.begin = begin;
exports.callstackSaga = callstackSaga;
exports.reset = reset;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(3);

var _helpers = __webpack_require__(1);

var _truffleDecodeUtils = __webpack_require__(10);

var TruffleDecodeUtils = _interopRequireWildcard(_truffleDecodeUtils);

var _actions = __webpack_require__(11);

var _actions2 = __webpack_require__(28);

var actions = _interopRequireWildcard(_actions2);

var _selectors = __webpack_require__(9);

var _selectors2 = _interopRequireDefault(_selectors);

var _sagas = __webpack_require__(17);

var data = _interopRequireWildcard(_sagas);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:evm:sagas");

/**
 * Adds EVM bytecode context
 *
 * @return {string} ID (0x-prefixed keccak of binary)
 */
function* addContext(contractName, { address, binary }, compiler) {
  const raw = binary || address;
  const context = (0, _helpers.keccak256)(raw);

  yield (0, _effects.put)(actions.addContext(contractName, raw, compiler));

  if (binary) {
    yield (0, _effects.put)(actions.addBinary(context, binary));
  }

  return context;
}

/**
 * Adds known deployed instance of binary at address
 *
 * @param {string} binary - may be undefined (e.g. precompiles)
 * @return {string} ID (0x-prefixed keccak of binary)
 */
function* addInstance(address, binary) {
  let search = yield (0, _effects.select)(_selectors2.default.info.binaries.search);
  let { context } = search(binary);

  // in case binary is unknown, add context for address
  if (!context) {
    context = yield* addContext(undefined, { address }, undefined);
  }

  yield (0, _effects.put)(actions.addInstance(address, context, binary));

  return context;
}

function* begin({ address, binary }) {
  if (address) {
    yield (0, _effects.put)(actions.call(address));
  } else {
    yield (0, _effects.put)(actions.create(binary));
  }
}

function* callstackSaga() {
  while (true) {
    yield (0, _effects.take)(_actions.TICK);

    if (yield (0, _effects.select)(_selectors2.default.current.step.isCall)) {
      debug("got call");
      let address = yield (0, _effects.select)(_selectors2.default.current.step.callAddress);

      // if there is no binary (e.g. in the case of precompiled contracts),
      // then there will be no trace steps for the called code, and so we
      // shouldn't tell the debugger that we're entering another execution
      // context
      if (yield (0, _effects.select)(_selectors2.default.current.step.callsPrecompile)) {
        continue;
      }

      yield (0, _effects.put)(actions.call(address));
    } else if (yield (0, _effects.select)(_selectors2.default.current.step.isCreate)) {
      debug("got create");
      let binary = yield (0, _effects.select)(_selectors2.default.current.step.createBinary);

      yield (0, _effects.put)(actions.create(binary));
    } else if (yield (0, _effects.select)(_selectors2.default.current.step.isHalting)) {
      debug("got return");

      let callstack = yield (0, _effects.select)(_selectors2.default.current.callstack);

      //if the program's not ending, and we just returned from a constructor,
      //learn the address of what we just initialized
      //(do this before we put the return action to avoid off-by-one error)
      if (callstack.length > 1 && callstack[callstack.length - 1].address === undefined) {
        let dummyAddress = yield (0, _effects.select)(_selectors2.default.current.creationDepth);
        debug("dummyAddress %d", dummyAddress);

        let stack = yield (0, _effects.select)(_selectors2.default.next.state.stack);
        let createdAddress = TruffleDecodeUtils.Conversion.toHexString(TruffleDecodeUtils.Conversion.toBytes(TruffleDecodeUtils.Conversion.toBN(stack[stack.length - 1], TruffleDecodeUtils.EVM.WORD_SIZE)), true);
        debug("createdAddress %s", createdAddress);

        yield* data.learnAddressSaga(dummyAddress, createdAddress);
        debug("address learnt");
      }

      yield (0, _effects.put)(actions.returnCall());
    }
  }
}

function* reset() {
  yield (0, _effects.put)(actions.reset());
}

function* saga() {
  yield (0, _effects.call)(callstackSaga);
}

exports.default = (0, _helpers.prefixName)("evm", saga);

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addContext = addContext;
exports.addBinary = addBinary;
exports.addInstance = addInstance;
exports.call = call;
exports.create = create;
exports.returnCall = returnCall;
exports.reset = reset;
const ADD_CONTEXT = exports.ADD_CONTEXT = "EVM_ADD_CONTEXT";
function addContext(contractName, raw, compiler) {
  return {
    type: ADD_CONTEXT,
    contractName,
    raw,
    compiler
  };
}

const ADD_BINARY = exports.ADD_BINARY = "EVM_ADD_BINARY";
function addBinary(context, binary) {
  return {
    type: ADD_BINARY,
    context,
    binary
  };
}

const ADD_INSTANCE = exports.ADD_INSTANCE = "EVM_ADD_INSTANCE";
function addInstance(address, context, binary) {
  return {
    type: ADD_INSTANCE,
    address,
    context,
    binary
  };
}

const CALL = exports.CALL = "CALL";
function call(address) {
  return {
    type: CALL,
    address
  };
}

const CREATE = exports.CREATE = "CREATE";
function create(binary) {
  return {
    type: CREATE,
    binary
  };
}

const RETURN = exports.RETURN = "RETURN";
function returnCall() {
  return {
    type: RETURN
  };
}

const RESET = exports.RESET = "EVM_RESET";
function reset() {
  return { type: RESET };
}

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addSource = addSource;
exports.addSourceMap = addSourceMap;
exports.reset = reset;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(3);

var _helpers = __webpack_require__(1);

var _actions = __webpack_require__(30);

var actions = _interopRequireWildcard(_actions);

var _actions2 = __webpack_require__(11);

var _selectors = __webpack_require__(8);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:solidity:sagas");

function* addSource(source, sourcePath, ast) {
  yield (0, _effects.put)(actions.addSource(source, sourcePath, ast));
}

function* addSourceMap(binary, sourceMap) {
  yield (0, _effects.put)(actions.addSourceMap(binary, sourceMap));
}

function* tickSaga() {
  while (true) {
    yield (0, _effects.take)(_actions2.TICK);
    debug("got TICK");

    yield* functionDepthSaga();
  }
}

function* functionDepthSaga() {
  if (yield (0, _effects.select)(_selectors2.default.current.willJump)) {
    let jumpDirection = yield (0, _effects.select)(_selectors2.default.current.jumpDirection);
    yield (0, _effects.put)(actions.jump(jumpDirection));
  } else if (yield (0, _effects.select)(_selectors2.default.current.willCall)) {
    //we have several cases here:
    //1. precompile -- *don't* put any jump
    //2. workaround case -- put a double jump (see below)
    //3. general case -- put a single jump as expected

    debug("about to call");
    if (yield (0, _effects.select)(_selectors2.default.current.callsPrecompile)) {
      //call to precompile; do nothing
    } else if ((yield (0, _effects.select)(_selectors2.default.current.needsFunctionDepthWorkaround)) && (yield (0, _effects.select)(_selectors2.default.current.isContractCall))) {
      //all these parentheses are necessary
      //HACK WORKAROUND
      //because of the problem in solc <0.5.1 where contract method calls
      //essentially return twice, we compensate by putting *two* inward jumps
      //for such a call.
      //Note that this won't work if the contract method was previously placed
      //in a function variable!  Those will continue to screw things up!  But
      //if a contract call is being made directly, we can detect that.
      //Of course, all of this should work fine as of solidity 0.5.1, with no
      //workaround necessary; this branch should only get take on old
      //contracts.
      debug("workaround invoked!");
      yield (0, _effects.put)(actions.jump("2"));
    } else {
      //an ordinary call, not to a precompile & with no workaround needed
      yield (0, _effects.put)(actions.jump("i"));
    }
  } else if (yield (0, _effects.select)(_selectors2.default.current.willCreate)) {
    //this case, thankfully, needs no further breakdown
    yield (0, _effects.put)(actions.jump("i"));
  } else if (yield (0, _effects.select)(_selectors2.default.current.willReturn)) {
    yield (0, _effects.put)(actions.jump("o"));
  }
}

function* reset() {
  yield (0, _effects.put)(actions.reset());
}

function* saga() {
  yield (0, _effects.call)(tickSaga);
}

exports.default = (0, _helpers.prefixName)("solidity", saga);

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addSource = addSource;
exports.addSourceMap = addSourceMap;
exports.jump = jump;
exports.reset = reset;
const ADD_SOURCE = exports.ADD_SOURCE = "SOLIDITY_ADD_SOURCE";
function addSource(source, sourcePath, ast) {
  return {
    type: ADD_SOURCE,
    source,
    sourcePath,
    ast
  };
}

const ADD_SOURCEMAP = exports.ADD_SOURCEMAP = "SOLIDITY_ADD_SOURCEMAP";
function addSourceMap(binary, sourceMap) {
  return {
    type: ADD_SOURCEMAP,
    binary,
    sourceMap
  };
}

const JUMP = exports.JUMP = "JUMP";
function jump(jumpDirection) {
  return {
    type: JUMP,
    jumpDirection
  };
}

const RESET = exports.RESET = "SOLIDITY_RESET";
function reset() {
  return { type: RESET };
}

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(2);

var _selectors = __webpack_require__(9);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(8);

var _selectors4 = _interopRequireDefault(_selectors3);

var _selectors5 = __webpack_require__(15);

var _selectors6 = _interopRequireDefault(_selectors5);

var _selectors7 = __webpack_require__(16);

var _selectors8 = _interopRequireDefault(_selectors7);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:controller:sagas");

/**
 * @private
 */
const identity = x => x;

/**
 * controller
 */
const controller = (0, _reselectTree.createSelectorTree)({

  /**
   * controller.state
   */
  state: state => state.controller,
  /**
   * controller.current
   */
  current: {
    /**
     * controller.current.functionDepth
     */
    functionDepth: (0, _reselectTree.createLeaf)([_selectors4.default.current.functionDepth], identity),

    /**
     * controller.current.executionContext
     */
    executionContext: (0, _reselectTree.createLeaf)([_selectors2.default.current.call], identity),

    /**
     * controller.current.willJump
     */
    willJump: (0, _reselectTree.createLeaf)([_selectors2.default.current.step.isJump], identity),

    /**
     * controller.current.location
     */
    location: {
      /**
       * controller.current.location.sourceRange
       */
      sourceRange: (0, _reselectTree.createLeaf)([_selectors4.default.current.sourceRange], identity),

      /**
       * controller.current.location.source
       */
      source: (0, _reselectTree.createLeaf)([_selectors4.default.current.source], identity),

      /**
       * controller.current.location.node
       */
      node: (0, _reselectTree.createLeaf)([_selectors6.default.current.node], identity),

      /**
       * controller.current.location.isMultiline
       */
      isMultiline: (0, _reselectTree.createLeaf)([_selectors4.default.current.isMultiline], identity)
    }
  },

  /**
   * controller.breakpoints
   */
  breakpoints: (0, _reselectTree.createLeaf)(["./state"], state => state.breakpoints),

  /**
   * controller.finished
   */
  finished: (0, _reselectTree.createLeaf)([_selectors8.default.finished], identity)

});

exports.default = controller;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

var Debugger = __webpack_require__(33).default;

module.exports = Debugger;



/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _asyncToGenerator2 = __webpack_require__(12);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _truffleExpect = __webpack_require__(34);

var _truffleExpect2 = _interopRequireDefault(_truffleExpect);

var _session = __webpack_require__(35);

var _session2 = _interopRequireDefault(_session);

var _reselectTree = __webpack_require__(2);

var _selectors = __webpack_require__(21);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(15);

var _selectors4 = _interopRequireDefault(_selectors3);

var _selectors5 = __webpack_require__(16);

var _selectors6 = _interopRequireDefault(_selectors5);

var _selectors7 = __webpack_require__(9);

var _selectors8 = _interopRequireDefault(_selectors7);

var _selectors9 = __webpack_require__(8);

var _selectors10 = _interopRequireDefault(_selectors9);

var _selectors11 = __webpack_require__(67);

var _selectors12 = _interopRequireDefault(_selectors11);

var _selectors13 = __webpack_require__(31);

var _selectors14 = _interopRequireDefault(_selectors13);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger");

/**
 * @example
 * let session = Debugger
 *   .forTx(<txHash>, {
 *     contracts: [<contract obj>, ...],
 *     provider: <provider instance>
 *   })
 *   .connect();
 */
class Debugger {
  /**
   * @param {Session} session - debugger session
   * @private
   */
  constructor(session) {
    /**
     * @private
     */
    this._session = session;
  }

  /**
   * Instantiates a Debugger for a given transaction hash.
   *
   * @param {String} txHash - transaction hash with leading "0x"
   * @param {{contracts: Array<Contract>, files: Array<String>, provider: Web3Provider}} options -
   * @return {Debugger} instance
   */
  static forTx(txHash, options = {}) {
    var _this = this;

    return (0, _asyncToGenerator3.default)(function* () {
      _truffleExpect2.default.options(options, ["contracts", "provider"]);

      let session = new _session2.default(options.contracts, options.files, txHash, options.provider);

      try {
        yield session.ready();
      } catch (e) {
        throw e;
      }

      return new _this(session);
    })();
  }

  /**
   * Connects to the instantiated Debugger.
   *
   * @return {Session} session instance
   */
  connect() {
    return this._session;
  }

  /**
   * Exported selectors
   *
   * See individual selector docs for full listing
   *
   * @example
   * Debugger.selectors.ast.current.tree
   *
   * @example
   * Debugger.selectors.solidity.current.instruction
   *
   * @example
   * Debugger.selectors.trace.steps
   */
  static get selectors() {
    return (0, _reselectTree.createNestedSelector)({
      ast: _selectors4.default,
      data: _selectors2.default,
      trace: _selectors6.default,
      evm: _selectors8.default,
      solidity: _selectors10.default,
      session: _selectors12.default,
      controller: _selectors14.default
    });
  }
}

exports.default = Debugger; /**
                             * @typedef {Object} Contract
                             * @property {string} contractName contract name
                             * @property {string} source solidity source code
                             * @property {string} sourcePath path to source file
                             * @property {string} binary 0x-prefixed hex string with create bytecode
                             * @property {string} sourceMap solidity source map for create bytecode
                             * @property {Object} ast Abstract Syntax Tree from Solidity
                             * @property {string} deployedBinary 0x-prefixed compiled binary (on chain)
                             * @property {string} deployedSourceMap solidity source map for on-chain bytecode
                             */

/***/ }),
/* 34 */
/***/ (function(module, exports) {

module.exports = require("truffle-expect");

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _asyncToGenerator2 = __webpack_require__(12);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _values = __webpack_require__(23);

var _values2 = _interopRequireDefault(_values);

var _promise = __webpack_require__(19);

var _promise2 = _interopRequireDefault(_promise);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _store = __webpack_require__(36);

var _store2 = _interopRequireDefault(_store);

var _actions = __webpack_require__(20);

var controller = _interopRequireWildcard(_actions);

var _actions2 = __webpack_require__(13);

var actions = _interopRequireWildcard(_actions2);

var _selectors = __webpack_require__(21);

var _selectors2 = _interopRequireDefault(_selectors);

var _sagas = __webpack_require__(52);

var _sagas2 = _interopRequireDefault(_sagas);

var _reducers = __webpack_require__(60);

var _reducers2 = _interopRequireDefault(_reducers);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:session"); //eslint-disable-line no-unused-vars

/**
 * Debugger Session
 */
class Session {
  /**
   * @param {Array<Contract>} contracts - contract definitions
   * @param {Array<String>} files - array of filenames for sourceMap indexes
   * @param {string} txHash - transaction hash
   * @param {Web3Provider} provider - web3 provider
   * @private
   */
  constructor(contracts, files, txHash, provider) {
    /**
     * @private
     */
    this._store = (0, _store2.default)(_reducers2.default, _sagas2.default);

    let { contexts, sources } = Session.normalize(contracts, files);

    // record contracts
    this._store.dispatch(actions.recordContracts(contexts, sources));

    this._store.dispatch(actions.start(txHash, provider));
  }

  ready() {
    return new _promise2.default((accept, reject) => {
      this._store.subscribe(() => {
        if (this.state.session.status == "ACTIVE") {
          accept();
        } else if (typeof this.state.session.status == "object") {
          reject(this.state.session.status.error);
        }
      });
    });
  }

  /**
   * Split up artifacts into "contexts" and "sources", dividing artifact
   * data into appropriate buckets.
   *
   * Multiple contracts can be defined in the same source file, but have
   * different bytecodes.
   *
   * This iterates over the contracts and collects binaries separately
   * from sources, using the optional `files` argument to force
   * source ordering.
   * @private
   */
  static normalize(contracts, files = null) {
    let sourcesByPath = {};
    let contexts = [];
    let sources;

    for (let contract of contracts) {
      let {
        contractName,
        binary,
        sourceMap,
        deployedBinary,
        deployedSourceMap,
        sourcePath,
        source,
        ast,
        compiler
      } = contract;

      debug("sourceMap %o", sourceMap);
      debug("compiler %o", compiler);

      sourcesByPath[sourcePath] = { sourcePath, source, ast };

      if (binary && binary != "0x") {
        contexts.push({
          contractName,
          binary,
          sourceMap
        });
      }

      if (deployedBinary && deployedBinary != "0x") {
        contexts.push({
          contractName,
          binary: deployedBinary,
          sourceMap: deployedSourceMap,
          compiler
        });
      }
    }

    if (!files) {
      sources = (0, _values2.default)(sourcesByPath);
    } else {
      sources = files.map(file => sourcesByPath[file]);
    }

    return { contexts, sources };
  }

  get state() {
    return this._store.getState();
  }

  view(selector) {
    return selector(this.state);
  }

  dispatch(action) {
    this._store.dispatch(action);

    return true;
  }

  interrupt() {
    return this.dispatch(controller.interrupt());
  }

  advance() {
    return this.dispatch(controller.advance());
  }

  stepNext() {
    return this.dispatch(controller.stepNext());
  }

  stepOver() {
    return this.dispatch(controller.stepOver());
  }

  stepInto() {
    return this.dispatch(controller.stepInto());
  }

  stepOut() {
    return this.dispatch(controller.stepOut());
  }

  reset() {
    return this.dispatch(controller.reset());
  }

  continueUntilBreakpoint() {
    return this.dispatch(controller.continueUntilBreakpoint());
  }

  addBreakpoint(breakpoint) {
    return this.dispatch(controller.addBreakpoint(breakpoint));
  }

  removeBreakpoint(breakpoint) {
    return this.dispatch(controller.removeBreakpoint(breakpoint));
  }

  removeAllBreakpoints() {
    return this.dispatch(controller.removeAllBreakpoints());
  }

  decodeReady() {
    var _this = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return new _promise2.default(function (resolve) {
        let haveResolved = false;
        const unsubscribe = _this._store.subscribe(function () {
          const subscriptionDecodingStarted = _this.view(_selectors2.default.proc.decodingMappingKeys);

          debug("following decoding started: %d", subscriptionDecodingStarted);

          if (subscriptionDecodingStarted <= 0 && !haveResolved) {
            haveResolved = true;
            unsubscribe();
            resolve();
          }
        });

        const decodingStarted = _this.view(_selectors2.default.proc.decodingMappingKeys);

        debug("initial decoding started: %d", decodingStarted);

        if (decodingStarted <= 0) {
          haveResolved = true;
          unsubscribe();
          resolve();
        }
      });
    })();
  }

  variable(name) {
    var _this2 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      yield _this2.decodeReady();

      const definitions = _this2.view(_selectors2.default.current.identifiers.definitions);
      const refs = _this2.view(_selectors2.default.current.identifiers.refs);

      const decode = _this2.view(_selectors2.default.views.decoder);
      return yield decode(definitions[name], refs[name]);
    })();
  }

  variables() {
    var _this3 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      yield _this3.decodeReady();

      return yield _this3.view(_selectors2.default.current.identifiers.decoded);
    })();
  }
}
exports.default = Session;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (true) {
  module.exports = __webpack_require__(37);
} else if (process.env.NODE_ENV == "test") {
  module.exports = require("./test");
} else {
  module.exports = require("./development");
}

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _common = __webpack_require__(38);

var _common2 = _interopRequireDefault(_common);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _common2.default;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = __webpack_require__(4);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(5);

var _assign2 = _interopRequireDefault(_assign);

exports.abbreviateValues = abbreviateValues;
exports.default = configureStore;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _redux = __webpack_require__(6);

var _reduxSaga = __webpack_require__(39);

var _reduxSaga2 = _interopRequireDefault(_reduxSaga);

var _reduxCliLogger = __webpack_require__(40);

var _reduxCliLogger2 = _interopRequireDefault(_reduxCliLogger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:store:common");
const reduxDebug = (0, _debug2.default)("debugger:redux");

function abbreviateValues(value, options = {}, depth = 0) {
  options.stringLimit = options.stringLimit || 66;
  options.arrayLimit = options.arrayLimit || 8;
  options.recurseLimit = options.recurseLimit || 4;

  if (depth > options.recurseLimit) {
    return "...";
  }

  const recurse = child => abbreviateValues(child, options, depth + 1);

  if (value instanceof Array) {
    if (value.length > options.arrayLimit) {
      value = [...value.slice(0, options.arrayLimit / 2), "...", ...value.slice(value.length - options.arrayLimit / 2 + 1)];
    }

    return value.map(recurse);
  } else if (value instanceof Object) {
    return (0, _assign2.default)({}, ...(0, _entries2.default)(value).map(([k, v]) => ({ [recurse(k)]: recurse(v) })));
  } else if (typeof value === "string" && value.length > options.stringLimit) {
    let inner = "...";
    let extractAmount = (options.stringLimit - inner.length) / 2;
    let leading = value.slice(0, Math.ceil(extractAmount));
    let trailing = value.slice(value.length - Math.floor(extractAmount));
    return `${leading}${inner}${trailing}`;
  } else {
    return value;
  }
}

function configureStore(reducer, saga, initialState, composeEnhancers) {
  const sagaMiddleware = (0, _reduxSaga2.default)();

  if (!composeEnhancers) {
    composeEnhancers = _redux.compose;
  }

  const loggerMiddleware = (0, _reduxCliLogger2.default)({
    log: reduxDebug,
    stateTransformer: state => abbreviateValues(state, {
      arrayLimit: 4,
      recurseLimit: 3
    }),
    actionTransformer: abbreviateValues
  });

  let store = (0, _redux.createStore)(reducer, initialState, composeEnhancers((0, _redux.applyMiddleware)(sagaMiddleware, loggerMiddleware)));

  sagaMiddleware.run(saga);

  return store;
}

/***/ }),
/* 39 */
/***/ (function(module, exports) {

module.exports = require("redux-saga");

/***/ }),
/* 40 */
/***/ (function(module, exports) {

module.exports = require("redux-cli-logger");

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

var json = typeof JSON !== 'undefined' ? JSON : __webpack_require__(42);

module.exports = function (obj, opts) {
    if (!opts) opts = {};
    if (typeof opts === 'function') opts = { cmp: opts };
    var space = opts.space || '';
    if (typeof space === 'number') space = Array(space+1).join(' ');
    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;
    var replacer = opts.replacer || function(key, value) { return value; };

    var cmp = opts.cmp && (function (f) {
        return function (node) {
            return function (a, b) {
                var aobj = { key: a, value: node[a] };
                var bobj = { key: b, value: node[b] };
                return f(aobj, bobj);
            };
        };
    })(opts.cmp);

    var seen = [];
    return (function stringify (parent, key, node, level) {
        var indent = space ? ('\n' + new Array(level + 1).join(space)) : '';
        var colonSeparator = space ? ': ' : ':';

        if (node && node.toJSON && typeof node.toJSON === 'function') {
            node = node.toJSON();
        }

        node = replacer.call(parent, key, node);

        if (node === undefined) {
            return;
        }
        if (typeof node !== 'object' || node === null) {
            return json.stringify(node);
        }
        if (isArray(node)) {
            var out = [];
            for (var i = 0; i < node.length; i++) {
                var item = stringify(node, i, node[i], level+1) || json.stringify(null);
                out.push(indent + space + item);
            }
            return '[' + out.join(',') + indent + ']';
        }
        else {
            if (seen.indexOf(node) !== -1) {
                if (cycles) return json.stringify('__cycle__');
                throw new TypeError('Converting circular structure to JSON');
            }
            else seen.push(node);

            var keys = objectKeys(node).sort(cmp && cmp(node));
            var out = [];
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var value = stringify(node, key, node[key], level+1);

                if(!value) continue;

                var keyValue = json.stringify(key)
                    + colonSeparator
                    + value;
                ;
                out.push(indent + space + keyValue);
            }
            seen.splice(seen.indexOf(node), 1);
            return '{' + out.join(',') + indent + '}';
        }
    })({ '': obj }, '', obj, 0);
};

var isArray = Array.isArray || function (x) {
    return {}.toString.call(x) === '[object Array]';
};

var objectKeys = Object.keys || function (obj) {
    var has = Object.prototype.hasOwnProperty || function () { return true };
    var keys = [];
    for (var key in obj) {
        if (has.call(obj, key)) keys.push(key);
    }
    return keys;
};


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

exports.parse = __webpack_require__(43);
exports.stringify = __webpack_require__(44);


/***/ }),
/* 43 */
/***/ (function(module, exports) {

var at, // The index of the current character
    ch, // The current character
    escapee = {
        '"':  '"',
        '\\': '\\',
        '/':  '/',
        b:    '\b',
        f:    '\f',
        n:    '\n',
        r:    '\r',
        t:    '\t'
    },
    text,

    error = function (m) {
        // Call error when something is wrong.
        throw {
            name:    'SyntaxError',
            message: m,
            at:      at,
            text:    text
        };
    },
    
    next = function (c) {
        // If a c parameter is provided, verify that it matches the current character.
        if (c && c !== ch) {
            error("Expected '" + c + "' instead of '" + ch + "'");
        }
        
        // Get the next character. When there are no more characters,
        // return the empty string.
        
        ch = text.charAt(at);
        at += 1;
        return ch;
    },
    
    number = function () {
        // Parse a number value.
        var number,
            string = '';
        
        if (ch === '-') {
            string = '-';
            next('-');
        }
        while (ch >= '0' && ch <= '9') {
            string += ch;
            next();
        }
        if (ch === '.') {
            string += '.';
            while (next() && ch >= '0' && ch <= '9') {
                string += ch;
            }
        }
        if (ch === 'e' || ch === 'E') {
            string += ch;
            next();
            if (ch === '-' || ch === '+') {
                string += ch;
                next();
            }
            while (ch >= '0' && ch <= '9') {
                string += ch;
                next();
            }
        }
        number = +string;
        if (!isFinite(number)) {
            error("Bad number");
        } else {
            return number;
        }
    },
    
    string = function () {
        // Parse a string value.
        var hex,
            i,
            string = '',
            uffff;
        
        // When parsing for string values, we must look for " and \ characters.
        if (ch === '"') {
            while (next()) {
                if (ch === '"') {
                    next();
                    return string;
                } else if (ch === '\\') {
                    next();
                    if (ch === 'u') {
                        uffff = 0;
                        for (i = 0; i < 4; i += 1) {
                            hex = parseInt(next(), 16);
                            if (!isFinite(hex)) {
                                break;
                            }
                            uffff = uffff * 16 + hex;
                        }
                        string += String.fromCharCode(uffff);
                    } else if (typeof escapee[ch] === 'string') {
                        string += escapee[ch];
                    } else {
                        break;
                    }
                } else {
                    string += ch;
                }
            }
        }
        error("Bad string");
    },

    white = function () {

// Skip whitespace.

        while (ch && ch <= ' ') {
            next();
        }
    },

    word = function () {

// true, false, or null.

        switch (ch) {
        case 't':
            next('t');
            next('r');
            next('u');
            next('e');
            return true;
        case 'f':
            next('f');
            next('a');
            next('l');
            next('s');
            next('e');
            return false;
        case 'n':
            next('n');
            next('u');
            next('l');
            next('l');
            return null;
        }
        error("Unexpected '" + ch + "'");
    },

    value,  // Place holder for the value function.

    array = function () {

// Parse an array value.

        var array = [];

        if (ch === '[') {
            next('[');
            white();
            if (ch === ']') {
                next(']');
                return array;   // empty array
            }
            while (ch) {
                array.push(value());
                white();
                if (ch === ']') {
                    next(']');
                    return array;
                }
                next(',');
                white();
            }
        }
        error("Bad array");
    },

    object = function () {

// Parse an object value.

        var key,
            object = {};

        if (ch === '{') {
            next('{');
            white();
            if (ch === '}') {
                next('}');
                return object;   // empty object
            }
            while (ch) {
                key = string();
                white();
                next(':');
                if (Object.hasOwnProperty.call(object, key)) {
                    error('Duplicate key "' + key + '"');
                }
                object[key] = value();
                white();
                if (ch === '}') {
                    next('}');
                    return object;
                }
                next(',');
                white();
            }
        }
        error("Bad object");
    };

value = function () {

// Parse a JSON value. It could be an object, an array, a string, a number,
// or a word.

    white();
    switch (ch) {
    case '{':
        return object();
    case '[':
        return array();
    case '"':
        return string();
    case '-':
        return number();
    default:
        return ch >= '0' && ch <= '9' ? number() : word();
    }
};

// Return the json_parse function. It will have access to all of the above
// functions and variables.

module.exports = function (source, reviver) {
    var result;
    
    text = source;
    at = 0;
    ch = ' ';
    result = value();
    white();
    if (ch) {
        error("Syntax error");
    }

    // If there is a reviver function, we recursively walk the new structure,
    // passing each name/value pair to the reviver function for possible
    // transformation, starting with a temporary root object that holds the result
    // in an empty key. If there is not a reviver function, we simply return the
    // result.

    return typeof reviver === 'function' ? (function walk(holder, key) {
        var k, v, value = holder[key];
        if (value && typeof value === 'object') {
            for (k in value) {
                if (Object.prototype.hasOwnProperty.call(value, k)) {
                    v = walk(value, k);
                    if (v !== undefined) {
                        value[k] = v;
                    } else {
                        delete value[k];
                    }
                }
            }
        }
        return reviver.call(holder, key, value);
    }({'': result}, '')) : result;
};


/***/ }),
/* 44 */
/***/ (function(module, exports) {

var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    gap,
    indent,
    meta = {    // table of character substitutions
        '\b': '\\b',
        '\t': '\\t',
        '\n': '\\n',
        '\f': '\\f',
        '\r': '\\r',
        '"' : '\\"',
        '\\': '\\\\'
    },
    rep;

function quote(string) {
    // If the string contains no control characters, no quote characters, and no
    // backslash characters, then we can safely slap some quotes around it.
    // Otherwise we must also replace the offending characters with safe escape
    // sequences.
    
    escapable.lastIndex = 0;
    return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
        var c = meta[a];
        return typeof c === 'string' ? c :
            '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    }) + '"' : '"' + string + '"';
}

function str(key, holder) {
    // Produce a string from holder[key].
    var i,          // The loop counter.
        k,          // The member key.
        v,          // The member value.
        length,
        mind = gap,
        partial,
        value = holder[key];
    
    // If the value has a toJSON method, call it to obtain a replacement value.
    if (value && typeof value === 'object' &&
            typeof value.toJSON === 'function') {
        value = value.toJSON(key);
    }
    
    // If we were called with a replacer function, then call the replacer to
    // obtain a replacement value.
    if (typeof rep === 'function') {
        value = rep.call(holder, key, value);
    }
    
    // What happens next depends on the value's type.
    switch (typeof value) {
        case 'string':
            return quote(value);
        
        case 'number':
            // JSON numbers must be finite. Encode non-finite numbers as null.
            return isFinite(value) ? String(value) : 'null';
        
        case 'boolean':
        case 'null':
            // If the value is a boolean or null, convert it to a string. Note:
            // typeof null does not produce 'null'. The case is included here in
            // the remote chance that this gets fixed someday.
            return String(value);
            
        case 'object':
            if (!value) return 'null';
            gap += indent;
            partial = [];
            
            // Array.isArray
            if (Object.prototype.toString.apply(value) === '[object Array]') {
                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }
                
                // Join all of the elements together, separated with commas, and
                // wrap them in brackets.
                v = partial.length === 0 ? '[]' : gap ?
                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                    '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }
            
            // If the replacer is an array, use it to select the members to be
            // stringified.
            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    k = rep[i];
                    if (typeof k === 'string') {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            else {
                // Otherwise, iterate through all of the keys in the object.
                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            
        // Join all of the member texts together, separated with commas,
        // and wrap them in braces.

        v = partial.length === 0 ? '{}' : gap ?
            '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
            '{' + partial.join(',') + '}';
        gap = mind;
        return v;
    }
}

module.exports = function (value, replacer, space) {
    var i;
    gap = '';
    indent = '';
    
    // If the space parameter is a number, make an indent string containing that
    // many spaces.
    if (typeof space === 'number') {
        for (i = 0; i < space; i += 1) {
            indent += ' ';
        }
    }
    // If the space parameter is a string, it will be used as the indent string.
    else if (typeof space === 'string') {
        indent = space;
    }

    // If there is a replacer, it must be a function or an array.
    // Otherwise, throw an error.
    rep = replacer;
    if (replacer && typeof replacer !== 'function'
    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {
        throw new Error('JSON.stringify');
    }
    
    // Make a fake root object containing our value under the key of ''.
    // Return the result of stringifying the value.
    return str('', {'': value});
};


/***/ }),
/* 45 */
/***/ (function(module, exports) {

module.exports = require("truffle-solidity-utils");

/***/ }),
/* 46 */
/***/ (function(module, exports) {

module.exports = require("truffle-code-utils");

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// An augmented AVL Tree where each node maintains a list of records and their search intervals.
// Record is composed of an interval and its underlying data, sent by a client. This allows the
// interval tree to have the same interval inserted multiple times, as long its data is different.
// Both insertion and deletion require O(log n) time. Searching requires O(k*logn) time, where `k`
// is the number of intervals in the output list.
Object.defineProperty(exports, "__esModule", { value: true });
var isSame = __webpack_require__(48);
function height(node) {
    if (node === undefined) {
        return -1;
    }
    else {
        return node.height;
    }
}
var Node = /** @class */ (function () {
    function Node(intervalTree, record) {
        this.intervalTree = intervalTree;
        this.records = [];
        this.height = 0;
        this.key = record.low;
        this.max = record.high;
        // Save the array of all records with the same key for this node
        this.records.push(record);
    }
    // Gets the highest record.high value for this node
    Node.prototype.getNodeHigh = function () {
        var high = this.records[0].high;
        for (var i = 1; i < this.records.length; i++) {
            if (this.records[i].high > high) {
                high = this.records[i].high;
            }
        }
        return high;
    };
    // Updates height value of the node. Called during insertion, rebalance, removal
    Node.prototype.updateHeight = function () {
        this.height = Math.max(height(this.left), height(this.right)) + 1;
    };
    // Updates the max value of all the parents after inserting into already existing node, as well as
    // removing the node completely or removing the record of an already existing node. Starts with
    // the parent of an affected node and bubbles up to root
    Node.prototype.updateMaxOfParents = function () {
        if (this === undefined) {
            return;
        }
        var thisHigh = this.getNodeHigh();
        if (this.left !== undefined && this.right !== undefined) {
            this.max = Math.max(Math.max(this.left.max, this.right.max), thisHigh);
        }
        else if (this.left !== undefined && this.right === undefined) {
            this.max = Math.max(this.left.max, thisHigh);
        }
        else if (this.left === undefined && this.right !== undefined) {
            this.max = Math.max(this.right.max, thisHigh);
        }
        else {
            this.max = thisHigh;
        }
        if (this.parent) {
            this.parent.updateMaxOfParents();
        }
    };
    /*
    Left-Left case:
  
           z                                      y
          / \                                   /   \
         y   T4      Right Rotate (z)          x     z
        / \          - - - - - - - - ->       / \   / \
       x   T3                                T1 T2 T3 T4
      / \
    T1   T2
  
    Left-Right case:
  
         z                               z                           x
        / \                             / \                        /   \
       y   T4  Left Rotate (y)         x  T4  Right Rotate(z)     y     z
      / \      - - - - - - - - ->     / \      - - - - - - - ->  / \   / \
    T1   x                           y  T3                      T1 T2 T3 T4
        / \                         / \
      T2   T3                      T1 T2
    */
    // Handles Left-Left case and Left-Right case after rebalancing AVL tree
    Node.prototype._updateMaxAfterRightRotate = function () {
        var parent = this.parent;
        var left = parent.left;
        // Update max of left sibling (x in first case, y in second)
        var thisParentLeftHigh = left.getNodeHigh();
        if (left.left === undefined && left.right !== undefined) {
            left.max = Math.max(thisParentLeftHigh, left.right.max);
        }
        else if (left.left !== undefined && left.right === undefined) {
            left.max = Math.max(thisParentLeftHigh, left.left.max);
        }
        else if (left.left === undefined && left.right === undefined) {
            left.max = thisParentLeftHigh;
        }
        else {
            left.max = Math.max(Math.max(left.left.max, left.right.max), thisParentLeftHigh);
        }
        // Update max of itself (z)
        var thisHigh = this.getNodeHigh();
        if (this.left === undefined && this.right !== undefined) {
            this.max = Math.max(thisHigh, this.right.max);
        }
        else if (this.left !== undefined && this.right === undefined) {
            this.max = Math.max(thisHigh, this.left.max);
        }
        else if (this.left === undefined && this.right === undefined) {
            this.max = thisHigh;
        }
        else {
            this.max = Math.max(Math.max(this.left.max, this.right.max), thisHigh);
        }
        // Update max of parent (y in first case, x in second)
        parent.max = Math.max(Math.max(parent.left.max, parent.right.max), parent.getNodeHigh());
    };
    /*
    Right-Right case:
  
      z                               y
     / \                            /   \
    T1  y     Left Rotate(z)       z     x
       / \   - - - - - - - ->     / \   / \
      T2  x                      T1 T2 T3 T4
         / \
        T3 T4
  
    Right-Left case:
  
       z                            z                            x
      / \                          / \                         /   \
     T1  y   Right Rotate (y)     T1  x      Left Rotate(z)   z     y
        / \  - - - - - - - - ->      / \   - - - - - - - ->  / \   / \
       x  T4                        T2  y                   T1 T2 T3 T4
      / \                              / \
    T2   T3                           T3 T4
    */
    // Handles Right-Right case and Right-Left case in rebalancing AVL tree
    Node.prototype._updateMaxAfterLeftRotate = function () {
        var parent = this.parent;
        var right = parent.right;
        // Update max of right sibling (x in first case, y in second)
        var thisParentRightHigh = right.getNodeHigh();
        if (right.left === undefined && right.right !== undefined) {
            right.max = Math.max(thisParentRightHigh, right.right.max);
        }
        else if (right.left !== undefined && right.right === undefined) {
            right.max = Math.max(thisParentRightHigh, right.left.max);
        }
        else if (right.left === undefined && right.right === undefined) {
            right.max = thisParentRightHigh;
        }
        else {
            right.max = Math.max(Math.max(right.left.max, right.right.max), thisParentRightHigh);
        }
        // Update max of itself (z)
        var thisHigh = this.getNodeHigh();
        if (this.left === undefined && this.right !== undefined) {
            this.max = Math.max(thisHigh, this.right.max);
        }
        else if (this.left !== undefined && this.right === undefined) {
            this.max = Math.max(thisHigh, this.left.max);
        }
        else if (this.left === undefined && this.right === undefined) {
            this.max = thisHigh;
        }
        else {
            this.max = Math.max(Math.max(this.left.max, this.right.max), thisHigh);
        }
        // Update max of parent (y in first case, x in second)
        parent.max = Math.max(Math.max(parent.left.max, right.max), parent.getNodeHigh());
    };
    Node.prototype._leftRotate = function () {
        var rightChild = this.right;
        rightChild.parent = this.parent;
        if (rightChild.parent === undefined) {
            this.intervalTree.root = rightChild;
        }
        else {
            if (rightChild.parent.left === this) {
                rightChild.parent.left = rightChild;
            }
            else if (rightChild.parent.right === this) {
                rightChild.parent.right = rightChild;
            }
        }
        this.right = rightChild.left;
        if (this.right !== undefined) {
            this.right.parent = this;
        }
        rightChild.left = this;
        this.parent = rightChild;
        this.updateHeight();
        rightChild.updateHeight();
    };
    Node.prototype._rightRotate = function () {
        var leftChild = this.left;
        leftChild.parent = this.parent;
        if (leftChild.parent === undefined) {
            this.intervalTree.root = leftChild;
        }
        else {
            if (leftChild.parent.left === this) {
                leftChild.parent.left = leftChild;
            }
            else if (leftChild.parent.right === this) {
                leftChild.parent.right = leftChild;
            }
        }
        this.left = leftChild.right;
        if (this.left !== undefined) {
            this.left.parent = this;
        }
        leftChild.right = this;
        this.parent = leftChild;
        this.updateHeight();
        leftChild.updateHeight();
    };
    // Rebalances the tree if the height value between two nodes of the same parent is greater than
    // two. There are 4 cases that can happen which are outlined in the graphics above
    Node.prototype._rebalance = function () {
        if (height(this.left) >= 2 + height(this.right)) {
            var left = this.left;
            if (height(left.left) >= height(left.right)) {
                // Left-Left case
                this._rightRotate();
                this._updateMaxAfterRightRotate();
            }
            else {
                // Left-Right case
                left._leftRotate();
                this._rightRotate();
                this._updateMaxAfterRightRotate();
            }
        }
        else if (height(this.right) >= 2 + height(this.left)) {
            var right = this.right;
            if (height(right.right) >= height(right.left)) {
                // Right-Right case
                this._leftRotate();
                this._updateMaxAfterLeftRotate();
            }
            else {
                // Right-Left case
                right._rightRotate();
                this._leftRotate();
                this._updateMaxAfterLeftRotate();
            }
        }
    };
    Node.prototype.insert = function (record) {
        if (record.low < this.key) {
            // Insert into left subtree
            if (this.left === undefined) {
                this.left = new Node(this.intervalTree, record);
                this.left.parent = this;
            }
            else {
                this.left.insert(record);
            }
        }
        else {
            // Insert into right subtree
            if (this.right === undefined) {
                this.right = new Node(this.intervalTree, record);
                this.right.parent = this;
            }
            else {
                this.right.insert(record);
            }
        }
        // Update the max value of this ancestor if needed
        if (this.max < record.high) {
            this.max = record.high;
        }
        // Update height of each node
        this.updateHeight();
        // Rebalance the tree to ensure all operations are executed in O(logn) time. This is especially
        // important in searching, as the tree has a high chance of degenerating without the rebalancing
        this._rebalance();
    };
    Node.prototype._getOverlappingRecords = function (currentNode, low, high) {
        if (currentNode.key <= high && low <= currentNode.getNodeHigh()) {
            // Nodes are overlapping, check if individual records in the node are overlapping
            var tempResults = [];
            for (var i = 0; i < currentNode.records.length; i++) {
                if (currentNode.records[i].high >= low) {
                    tempResults.push(currentNode.records[i]);
                }
            }
            return tempResults;
        }
        return [];
    };
    Node.prototype.search = function (low, high) {
        // Don't search nodes that don't exist
        if (this === undefined) {
            return [];
        }
        var leftSearch = [];
        var ownSearch = [];
        var rightSearch = [];
        // If interval is to the right of the rightmost point of any interval in this node and all its
        // children, there won't be any matches
        if (low > this.max) {
            return [];
        }
        // Search left children
        if (this.left !== undefined && this.left.max >= low) {
            leftSearch = this.left.search(low, high);
        }
        // Check this node
        ownSearch = this._getOverlappingRecords(this, low, high);
        // If interval is to the left of the start of this interval, then it can't be in any child to
        // the right
        if (high < this.key) {
            return leftSearch.concat(ownSearch);
        }
        // Otherwise, search right children
        if (this.right !== undefined) {
            rightSearch = this.right.search(low, high);
        }
        // Return accumulated results, if any
        return leftSearch.concat(ownSearch, rightSearch);
    };
    // Searches for a node by a `key` value
    Node.prototype.searchExisting = function (low) {
        if (this === undefined) {
            return undefined;
        }
        if (this.key === low) {
            return this;
        }
        else if (low < this.key) {
            if (this.left !== undefined) {
                return this.left.searchExisting(low);
            }
        }
        else {
            if (this.right !== undefined) {
                return this.right.searchExisting(low);
            }
        }
        return undefined;
    };
    // Returns the smallest node of the subtree
    Node.prototype._minValue = function () {
        if (this.left === undefined) {
            return this;
        }
        else {
            return this.left._minValue();
        }
    };
    Node.prototype.remove = function (node) {
        var parent = this.parent;
        if (node.key < this.key) {
            // Node to be removed is on the left side
            if (this.left !== undefined) {
                return this.left.remove(node);
            }
            else {
                return undefined;
            }
        }
        else if (node.key > this.key) {
            // Node to be removed is on the right side
            if (this.right !== undefined) {
                return this.right.remove(node);
            }
            else {
                return undefined;
            }
        }
        else {
            if (this.left !== undefined && this.right !== undefined) {
                // Node has two children
                var minValue = this.right._minValue();
                this.key = minValue.key;
                this.records = minValue.records;
                return this.right.remove(this);
            }
            else if (parent.left === this) {
                // One child or no child case on left side
                if (this.right !== undefined) {
                    parent.left = this.right;
                    this.right.parent = parent;
                }
                else {
                    parent.left = this.left;
                    if (this.left !== undefined) {
                        this.left.parent = parent;
                    }
                }
                parent.updateMaxOfParents();
                parent.updateHeight();
                parent._rebalance();
                return this;
            }
            else if (parent.right === this) {
                // One child or no child case on right side
                if (this.right !== undefined) {
                    parent.right = this.right;
                    this.right.parent = parent;
                }
                else {
                    parent.right = this.left;
                    if (this.left !== undefined) {
                        this.left.parent = parent;
                    }
                }
                parent.updateMaxOfParents();
                parent.updateHeight();
                parent._rebalance();
                return this;
            }
        }
    };
    return Node;
}());
exports.Node = Node;
var IntervalTree = /** @class */ (function () {
    function IntervalTree() {
        this.count = 0;
    }
    IntervalTree.prototype.insert = function (record) {
        if (record.low > record.high) {
            throw new Error('`low` value must be lower or equal to `high` value');
        }
        if (this.root === undefined) {
            // Base case: Tree is empty, new node becomes root
            this.root = new Node(this, record);
            this.count++;
            return true;
        }
        else {
            // Otherwise, check if node already exists with the same key
            var node = this.root.searchExisting(record.low);
            if (node !== undefined) {
                // Check the records in this node if there already is the one with same low, high, data
                for (var i = 0; i < node.records.length; i++) {
                    if (isSame(node.records[i], record)) {
                        // This record is same as the one we're trying to insert; return false to indicate
                        // nothing has been inserted
                        return false;
                    }
                }
                // Add the record to the node
                node.records.push(record);
                // Update max of the node and its parents if necessary
                if (record.high > node.max) {
                    node.max = record.high;
                    if (node.parent) {
                        node.parent.updateMaxOfParents();
                    }
                }
                this.count++;
                return true;
            }
            else {
                // Node with this key doesn't already exist. Call insert function on root's node
                this.root.insert(record);
                this.count++;
                return true;
            }
        }
    };
    IntervalTree.prototype.search = function (low, high) {
        if (this.root === undefined) {
            // Tree is empty; return empty array
            return [];
        }
        else {
            return this.root.search(low, high);
        }
    };
    IntervalTree.prototype.remove = function (record) {
        if (this.root === undefined) {
            // Tree is empty; nothing to remove
            return false;
        }
        else {
            var node = this.root.searchExisting(record.low);
            if (node === undefined) {
                return false;
            }
            else if (node.records.length > 1) {
                var removedRecord = void 0;
                // Node with this key has 2 or more records. Find the one we need and remove it
                for (var i = 0; i < node.records.length; i++) {
                    if (isSame(node.records[i], record)) {
                        removedRecord = node.records[i];
                        node.records.splice(i, 1);
                        break;
                    }
                }
                if (removedRecord) {
                    removedRecord = undefined;
                    // Update max of that node and its parents if necessary
                    if (record.high === node.max) {
                        var nodeHigh = node.getNodeHigh();
                        if (node.left !== undefined && node.right !== undefined) {
                            node.max = Math.max(Math.max(node.left.max, node.right.max), nodeHigh);
                        }
                        else if (node.left !== undefined && node.right === undefined) {
                            node.max = Math.max(node.left.max, nodeHigh);
                        }
                        else if (node.left === undefined && node.right !== undefined) {
                            node.max = Math.max(node.right.max, nodeHigh);
                        }
                        else {
                            node.max = nodeHigh;
                        }
                        if (node.parent) {
                            node.parent.updateMaxOfParents();
                        }
                    }
                    this.count--;
                    return true;
                }
                else {
                    return false;
                }
            }
            else if (node.records.length === 1) {
                // Node with this key has only 1 record. Check if the remaining record in this node is
                // actually the one we want to remove
                if (isSame(node.records[0], record)) {
                    // The remaining record is the one we want to remove. Remove the whole node from the tree
                    if (this.root.key === node.key) {
                        // We're removing the root element. Create a dummy node that will temporarily take
                        // root's parent role
                        var rootParent = new Node(this, { low: record.low, high: record.low });
                        rootParent.left = this.root;
                        this.root.parent = rootParent;
                        var removedNode = this.root.remove(node);
                        this.root = rootParent.left;
                        if (this.root !== undefined) {
                            this.root.parent = undefined;
                        }
                        if (removedNode) {
                            removedNode = undefined;
                            this.count--;
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                    else {
                        var removedNode = this.root.remove(node);
                        if (removedNode) {
                            removedNode = undefined;
                            this.count--;
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                }
                else {
                    // The remaining record is not the one we want to remove
                    return false;
                }
            }
            else {
                // No records at all in this node?! Shouldn't happen
                return false;
            }
        }
    };
    IntervalTree.prototype.inOrder = function () {
        return new InOrder(this.root);
    };
    IntervalTree.prototype.preOrder = function () {
        return new PreOrder(this.root);
    };
    return IntervalTree;
}());
exports.IntervalTree = IntervalTree;
var DataIntervalTree = /** @class */ (function () {
    function DataIntervalTree() {
        this.tree = new IntervalTree();
    }
    DataIntervalTree.prototype.insert = function (low, high, data) {
        return this.tree.insert({ low: low, high: high, data: data });
    };
    DataIntervalTree.prototype.remove = function (low, high, data) {
        return this.tree.remove({ low: low, high: high, data: data });
    };
    DataIntervalTree.prototype.search = function (low, high) {
        return this.tree.search(low, high).map(function (v) { return v.data; });
    };
    DataIntervalTree.prototype.inOrder = function () {
        return this.tree.inOrder();
    };
    DataIntervalTree.prototype.preOrder = function () {
        return this.tree.preOrder();
    };
    Object.defineProperty(DataIntervalTree.prototype, "count", {
        get: function () {
            return this.tree.count;
        },
        enumerable: true,
        configurable: true
    });
    return DataIntervalTree;
}());
exports.default = DataIntervalTree;
var InOrder = /** @class */ (function () {
    function InOrder(startNode) {
        this.stack = [];
        if (startNode !== undefined) {
            this.push(startNode);
        }
    }
    InOrder.prototype.next = function () {
        // Will only happen if stack is empty and pop is called
        if (this.currentNode === undefined) {
            return {
                done: true,
                value: undefined,
            };
        }
        // Process this node
        if (this.i < this.currentNode.records.length) {
            return {
                done: false,
                value: this.currentNode.records[this.i++],
            };
        }
        if (this.currentNode.right !== undefined) {
            this.push(this.currentNode.right);
        }
        else {
            // Might pop the last and set this.currentNode = undefined
            this.pop();
        }
        return this.next();
    };
    InOrder.prototype.push = function (node) {
        this.currentNode = node;
        this.i = 0;
        while (this.currentNode.left !== undefined) {
            this.stack.push(this.currentNode);
            this.currentNode = this.currentNode.left;
        }
    };
    InOrder.prototype.pop = function () {
        this.currentNode = this.stack.pop();
        this.i = 0;
    };
    return InOrder;
}());
exports.InOrder = InOrder;
if (typeof Symbol === 'function') {
    InOrder.prototype[Symbol.iterator] = function () { return this; };
}
var PreOrder = /** @class */ (function () {
    function PreOrder(startNode) {
        this.stack = [];
        this.i = 0;
        this.currentNode = startNode;
    }
    PreOrder.prototype.next = function () {
        // Will only happen if stack is empty and pop is called,
        // which only happens if there is no right node (i.e we are done)
        if (this.currentNode === undefined) {
            return {
                done: true,
                value: undefined,
            };
        }
        // Process this node
        if (this.i < this.currentNode.records.length) {
            return {
                done: false,
                value: this.currentNode.records[this.i++],
            };
        }
        if (this.currentNode.right !== undefined) {
            this.push(this.currentNode.right);
        }
        if (this.currentNode.left !== undefined) {
            this.push(this.currentNode.left);
        }
        this.pop();
        return this.next();
    };
    PreOrder.prototype.push = function (node) {
        this.stack.push(node);
    };
    PreOrder.prototype.pop = function () {
        this.currentNode = this.stack.pop();
        this.i = 0;
    };
    return PreOrder;
}());
exports.PreOrder = PreOrder;
if (typeof Symbol === 'function') {
    PreOrder.prototype[Symbol.iterator] = function () { return this; };
}
//# sourceMappingURL=index.js.map

/***/ }),
/* 48 */
/***/ (function(module, exports) {

//

module.exports = function shallowEqual(objA, objB, compare, compareContext) {
  var ret = compare ? compare.call(compareContext, objA, objB) : void 0;

  if (ret !== void 0) {
    return !!ret;
  }

  if (objA === objB) {
    return true;
  }

  if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);

  // Test for A's keys different from B.
  for (var idx = 0; idx < keysA.length; idx++) {
    var key = keysA[idx];

    if (!bHasOwnProperty(key)) {
      return false;
    }

    var valueA = objA[key];
    var valueB = objB[key];

    ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;

    if (ret === false || (ret === void 0 && valueA !== valueB)) {
      return false;
    }
  }

  return true;
};


/***/ }),
/* 49 */
/***/ (function(module, exports) {

module.exports = require("fast-levenshtein");

/***/ }),
/* 50 */
/***/ (function(module, exports) {

exports = module.exports = SemVer;

// The debug function is excluded entirely from the minified version.
/* nomin */ var debug;
/* nomin */ if (typeof process === 'object' &&
    /* nomin */ process.env &&
    /* nomin */ process.env.NODE_DEBUG &&
    /* nomin */ /\bsemver\b/i.test(process.env.NODE_DEBUG))
  /* nomin */ debug = function() {
    /* nomin */ var args = Array.prototype.slice.call(arguments, 0);
    /* nomin */ args.unshift('SEMVER');
    /* nomin */ console.log.apply(console, args);
    /* nomin */ };
/* nomin */ else
  /* nomin */ debug = function() {};

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
exports.SEMVER_SPEC_VERSION = '2.0.0';

var MAX_LENGTH = 256;
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;

// Max safe segment length for coercion.
var MAX_SAFE_COMPONENT_LENGTH = 16;

// The actual regexps go on exports.re
var re = exports.re = [];
var src = exports.src = [];
var R = 0;

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

var NUMERICIDENTIFIER = R++;
src[NUMERICIDENTIFIER] = '0|[1-9]\\d*';
var NUMERICIDENTIFIERLOOSE = R++;
src[NUMERICIDENTIFIERLOOSE] = '[0-9]+';


// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

var NONNUMERICIDENTIFIER = R++;
src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';


// ## Main Version
// Three dot-separated numeric identifiers.

var MAINVERSION = R++;
src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')';

var MAINVERSIONLOOSE = R++;
src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')';

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

var PRERELEASEIDENTIFIER = R++;
src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +
                            '|' + src[NONNUMERICIDENTIFIER] + ')';

var PRERELEASEIDENTIFIERLOOSE = R++;
src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +
                                 '|' + src[NONNUMERICIDENTIFIER] + ')';


// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

var PRERELEASE = R++;
src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +
                  '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))';

var PRERELEASELOOSE = R++;
src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +
                       '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

var BUILDIDENTIFIER = R++;
src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

var BUILD = R++;
src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] +
             '(?:\\.' + src[BUILDIDENTIFIER] + ')*))';


// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

var FULL = R++;
var FULLPLAIN = 'v?' + src[MAINVERSION] +
                src[PRERELEASE] + '?' +
                src[BUILD] + '?';

src[FULL] = '^' + FULLPLAIN + '$';

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] +
                 src[PRERELEASELOOSE] + '?' +
                 src[BUILD] + '?';

var LOOSE = R++;
src[LOOSE] = '^' + LOOSEPLAIN + '$';

var GTLT = R++;
src[GTLT] = '((?:<|>)?=?)';

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
var XRANGEIDENTIFIERLOOSE = R++;
src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
var XRANGEIDENTIFIER = R++;
src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*';

var XRANGEPLAIN = R++;
src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:' + src[PRERELEASE] + ')?' +
                   src[BUILD] + '?' +
                   ')?)?';

var XRANGEPLAINLOOSE = R++;
src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:' + src[PRERELEASELOOSE] + ')?' +
                        src[BUILD] + '?' +
                        ')?)?';

var XRANGE = R++;
src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$';
var XRANGELOOSE = R++;
src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$';

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
var COERCE = R++;
src[COERCE] = '(?:^|[^\\d])' +
              '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:$|[^\\d])';

// Tilde ranges.
// Meaning is "reasonably at or greater than"
var LONETILDE = R++;
src[LONETILDE] = '(?:~>?)';

var TILDETRIM = R++;
src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+';
re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');
var tildeTrimReplace = '$1~';

var TILDE = R++;
src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';
var TILDELOOSE = R++;
src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';

// Caret ranges.
// Meaning is "at least and backwards compatible with"
var LONECARET = R++;
src[LONECARET] = '(?:\\^)';

var CARETTRIM = R++;
src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+';
re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');
var caretTrimReplace = '$1^';

var CARET = R++;
src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';
var CARETLOOSE = R++;
src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';

// A simple gt/lt/eq thing, or just "" to indicate "any version"
var COMPARATORLOOSE = R++;
src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$';
var COMPARATOR = R++;
src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$';


// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
var COMPARATORTRIM = R++;
src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] +
                      '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';

// this one has to use the /g flag
re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');
var comparatorTrimReplace = '$1$2$3';


// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
var HYPHENRANGE = R++;
src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' +
                   '\\s+-\\s+' +
                   '(' + src[XRANGEPLAIN] + ')' +
                   '\\s*$';

var HYPHENRANGELOOSE = R++;
src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s+-\\s+' +
                        '(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s*$';

// Star ranges basically just allow anything at all.
var STAR = R++;
src[STAR] = '(<|>)?=?\\s*\\*';

// Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.
for (var i = 0; i < R; i++) {
  debug(i, src[i]);
  if (!re[i])
    re[i] = new RegExp(src[i]);
}

exports.parse = parse;
function parse(version, options) {
  if (!options || typeof options !== 'object')
    options = { loose: !!options, includePrerelease: false }

  if (version instanceof SemVer)
    return version;

  if (typeof version !== 'string')
    return null;

  if (version.length > MAX_LENGTH)
    return null;

  var r = options.loose ? re[LOOSE] : re[FULL];
  if (!r.test(version))
    return null;

  try {
    return new SemVer(version, options);
  } catch (er) {
    return null;
  }
}

exports.valid = valid;
function valid(version, options) {
  var v = parse(version, options);
  return v ? v.version : null;
}


exports.clean = clean;
function clean(version, options) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), options);
  return s ? s.version : null;
}

exports.SemVer = SemVer;

function SemVer(version, options) {
  if (!options || typeof options !== 'object')
    options = { loose: !!options, includePrerelease: false }
  if (version instanceof SemVer) {
    if (version.loose === options.loose)
      return version;
    else
      version = version.version;
  } else if (typeof version !== 'string') {
    throw new TypeError('Invalid Version: ' + version);
  }

  if (version.length > MAX_LENGTH)
    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')

  if (!(this instanceof SemVer))
    return new SemVer(version, options);

  debug('SemVer', version, options);
  this.options = options;
  this.loose = !!options.loose;

  var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL]);

  if (!m)
    throw new TypeError('Invalid Version: ' + version);

  this.raw = version;

  // these are actually numbers
  this.major = +m[1];
  this.minor = +m[2];
  this.patch = +m[3];

  if (this.major > MAX_SAFE_INTEGER || this.major < 0)
    throw new TypeError('Invalid major version')

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)
    throw new TypeError('Invalid minor version')

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)
    throw new TypeError('Invalid patch version')

  // numberify any prerelease numeric ids
  if (!m[4])
    this.prerelease = [];
  else
    this.prerelease = m[4].split('.').map(function(id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id;
        if (num >= 0 && num < MAX_SAFE_INTEGER)
          return num;
      }
      return id;
    });

  this.build = m[5] ? m[5].split('.') : [];
  this.format();
}

SemVer.prototype.format = function() {
  this.version = this.major + '.' + this.minor + '.' + this.patch;
  if (this.prerelease.length)
    this.version += '-' + this.prerelease.join('.');
  return this.version;
};

SemVer.prototype.toString = function() {
  return this.version;
};

SemVer.prototype.compare = function(other) {
  debug('SemVer.compare', this.version, this.options, other);
  if (!(other instanceof SemVer))
    other = new SemVer(other, this.options);

  return this.compareMain(other) || this.comparePre(other);
};

SemVer.prototype.compareMain = function(other) {
  if (!(other instanceof SemVer))
    other = new SemVer(other, this.options);

  return compareIdentifiers(this.major, other.major) ||
         compareIdentifiers(this.minor, other.minor) ||
         compareIdentifiers(this.patch, other.patch);
};

SemVer.prototype.comparePre = function(other) {
  if (!(other instanceof SemVer))
    other = new SemVer(other, this.options);

  // NOT having a prerelease is > having one
  if (this.prerelease.length && !other.prerelease.length)
    return -1;
  else if (!this.prerelease.length && other.prerelease.length)
    return 1;
  else if (!this.prerelease.length && !other.prerelease.length)
    return 0;

  var i = 0;
  do {
    var a = this.prerelease[i];
    var b = other.prerelease[i];
    debug('prerelease compare', i, a, b);
    if (a === undefined && b === undefined)
      return 0;
    else if (b === undefined)
      return 1;
    else if (a === undefined)
      return -1;
    else if (a === b)
      continue;
    else
      return compareIdentifiers(a, b);
  } while (++i);
};

// preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.
SemVer.prototype.inc = function(release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0;
      this.patch = 0;
      this.minor = 0;
      this.major++;
      this.inc('pre', identifier);
      break;
    case 'preminor':
      this.prerelease.length = 0;
      this.patch = 0;
      this.minor++;
      this.inc('pre', identifier);
      break;
    case 'prepatch':
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0;
      this.inc('patch', identifier);
      this.inc('pre', identifier);
      break;
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.
    case 'prerelease':
      if (this.prerelease.length === 0)
        this.inc('patch', identifier);
      this.inc('pre', identifier);
      break;

    case 'major':
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0)
        this.major++;
      this.minor = 0;
      this.patch = 0;
      this.prerelease = [];
      break;
    case 'minor':
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0)
        this.minor++;
      this.patch = 0;
      this.prerelease = [];
      break;
    case 'patch':
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0)
        this.patch++;
      this.prerelease = [];
      break;
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
    case 'pre':
      if (this.prerelease.length === 0)
        this.prerelease = [0];
      else {
        var i = this.prerelease.length;
        while (--i >= 0) {
          if (typeof this.prerelease[i] === 'number') {
            this.prerelease[i]++;
            i = -2;
          }
        }
        if (i === -1) // didn't increment anything
          this.prerelease.push(0);
      }
      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1]))
            this.prerelease = [identifier, 0];
        } else
          this.prerelease = [identifier, 0];
      }
      break;

    default:
      throw new Error('invalid increment argument: ' + release);
  }
  this.format();
  this.raw = this.version;
  return this;
};

exports.inc = inc;
function inc(version, release, loose, identifier) {
  if (typeof(loose) === 'string') {
    identifier = loose;
    loose = undefined;
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version;
  } catch (er) {
    return null;
  }
}

exports.diff = diff;
function diff(version1, version2) {
  if (eq(version1, version2)) {
    return null;
  } else {
    var v1 = parse(version1);
    var v2 = parse(version2);
    if (v1.prerelease.length || v2.prerelease.length) {
      for (var key in v1) {
        if (key === 'major' || key === 'minor' || key === 'patch') {
          if (v1[key] !== v2[key]) {
            return 'pre'+key;
          }
        }
      }
      return 'prerelease';
    }
    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return key;
        }
      }
    }
  }
}

exports.compareIdentifiers = compareIdentifiers;

var numeric = /^[0-9]+$/;
function compareIdentifiers(a, b) {
  var anum = numeric.test(a);
  var bnum = numeric.test(b);

  if (anum && bnum) {
    a = +a;
    b = +b;
  }

  return (anum && !bnum) ? -1 :
         (bnum && !anum) ? 1 :
         a < b ? -1 :
         a > b ? 1 :
         0;
}

exports.rcompareIdentifiers = rcompareIdentifiers;
function rcompareIdentifiers(a, b) {
  return compareIdentifiers(b, a);
}

exports.major = major;
function major(a, loose) {
  return new SemVer(a, loose).major;
}

exports.minor = minor;
function minor(a, loose) {
  return new SemVer(a, loose).minor;
}

exports.patch = patch;
function patch(a, loose) {
  return new SemVer(a, loose).patch;
}

exports.compare = compare;
function compare(a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose));
}

exports.compareLoose = compareLoose;
function compareLoose(a, b) {
  return compare(a, b, true);
}

exports.rcompare = rcompare;
function rcompare(a, b, loose) {
  return compare(b, a, loose);
}

exports.sort = sort;
function sort(list, loose) {
  return list.sort(function(a, b) {
    return exports.compare(a, b, loose);
  });
}

exports.rsort = rsort;
function rsort(list, loose) {
  return list.sort(function(a, b) {
    return exports.rcompare(a, b, loose);
  });
}

exports.gt = gt;
function gt(a, b, loose) {
  return compare(a, b, loose) > 0;
}

exports.lt = lt;
function lt(a, b, loose) {
  return compare(a, b, loose) < 0;
}

exports.eq = eq;
function eq(a, b, loose) {
  return compare(a, b, loose) === 0;
}

exports.neq = neq;
function neq(a, b, loose) {
  return compare(a, b, loose) !== 0;
}

exports.gte = gte;
function gte(a, b, loose) {
  return compare(a, b, loose) >= 0;
}

exports.lte = lte;
function lte(a, b, loose) {
  return compare(a, b, loose) <= 0;
}

exports.cmp = cmp;
function cmp(a, op, b, loose) {
  var ret;
  switch (op) {
    case '===':
      if (typeof a === 'object') a = a.version;
      if (typeof b === 'object') b = b.version;
      ret = a === b;
      break;
    case '!==':
      if (typeof a === 'object') a = a.version;
      if (typeof b === 'object') b = b.version;
      ret = a !== b;
      break;
    case '': case '=': case '==': ret = eq(a, b, loose); break;
    case '!=': ret = neq(a, b, loose); break;
    case '>': ret = gt(a, b, loose); break;
    case '>=': ret = gte(a, b, loose); break;
    case '<': ret = lt(a, b, loose); break;
    case '<=': ret = lte(a, b, loose); break;
    default: throw new TypeError('Invalid operator: ' + op);
  }
  return ret;
}

exports.Comparator = Comparator;
function Comparator(comp, options) {
  if (!options || typeof options !== 'object')
    options = { loose: !!options, includePrerelease: false }

  if (comp instanceof Comparator) {
    if (comp.loose === !!options.loose)
      return comp;
    else
      comp = comp.value;
  }

  if (!(this instanceof Comparator))
    return new Comparator(comp, options);

  debug('comparator', comp, options);
  this.options = options;
  this.loose = !!options.loose;
  this.parse(comp);

  if (this.semver === ANY)
    this.value = '';
  else
    this.value = this.operator + this.semver.version;

  debug('comp', this);
}

var ANY = {};
Comparator.prototype.parse = function(comp) {
  var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
  var m = comp.match(r);

  if (!m)
    throw new TypeError('Invalid comparator: ' + comp);

  this.operator = m[1];
  if (this.operator === '=')
    this.operator = '';

  // if it literally is just '>' or '' then allow anything.
  if (!m[2])
    this.semver = ANY;
  else
    this.semver = new SemVer(m[2], this.options.loose);
};

Comparator.prototype.toString = function() {
  return this.value;
};

Comparator.prototype.test = function(version) {
  debug('Comparator.test', version, this.options.loose);

  if (this.semver === ANY)
    return true;

  if (typeof version === 'string')
    version = new SemVer(version, this.options);

  return cmp(version, this.operator, this.semver, this.options);
};

Comparator.prototype.intersects = function(comp, options) {
  if (!(comp instanceof Comparator)) {
    throw new TypeError('a Comparator is required');
  }

  if (!options || typeof options !== 'object')
    options = { loose: !!options, includePrerelease: false }

  var rangeTmp;

  if (this.operator === '') {
    rangeTmp = new Range(comp.value, options);
    return satisfies(this.value, rangeTmp, options);
  } else if (comp.operator === '') {
    rangeTmp = new Range(this.value, options);
    return satisfies(comp.semver, rangeTmp, options);
  }

  var sameDirectionIncreasing =
    (this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '>=' || comp.operator === '>');
  var sameDirectionDecreasing =
    (this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '<=' || comp.operator === '<');
  var sameSemVer = this.semver.version === comp.semver.version;
  var differentDirectionsInclusive =
    (this.operator === '>=' || this.operator === '<=') &&
    (comp.operator === '>=' || comp.operator === '<=');
  var oppositeDirectionsLessThan =
    cmp(this.semver, '<', comp.semver, options) &&
    ((this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '<=' || comp.operator === '<'));
  var oppositeDirectionsGreaterThan =
    cmp(this.semver, '>', comp.semver, options) &&
    ((this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '>=' || comp.operator === '>'));

  return sameDirectionIncreasing || sameDirectionDecreasing ||
    (sameSemVer && differentDirectionsInclusive) ||
    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
};


exports.Range = Range;
function Range(range, options) {
  if (!options || typeof options !== 'object')
    options = { loose: !!options, includePrerelease: false }

  if (range instanceof Range) {
    if (range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease) {
      return range;
    } else {
      return new Range(range.raw, options);
    }
  }

  if (range instanceof Comparator) {
    return new Range(range.value, options);
  }

  if (!(this instanceof Range))
    return new Range(range, options);

  this.options = options;
  this.loose = !!options.loose;
  this.includePrerelease = !!options.includePrerelease

  // First, split based on boolean or ||
  this.raw = range;
  this.set = range.split(/\s*\|\|\s*/).map(function(range) {
    return this.parseRange(range.trim());
  }, this).filter(function(c) {
    // throw out any that are not relevant for whatever reason
    return c.length;
  });

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + range);
  }

  this.format();
}

Range.prototype.format = function() {
  this.range = this.set.map(function(comps) {
    return comps.join(' ').trim();
  }).join('||').trim();
  return this.range;
};

Range.prototype.toString = function() {
  return this.range;
};

Range.prototype.parseRange = function(range) {
  var loose = this.options.loose;
  range = range.trim();
  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
  range = range.replace(hr, hyphenReplace);
  debug('hyphen replace', range);
  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
  debug('comparator trim', range, re[COMPARATORTRIM]);

  // `~ 1.2.3` => `~1.2.3`
  range = range.replace(re[TILDETRIM], tildeTrimReplace);

  // `^ 1.2.3` => `^1.2.3`
  range = range.replace(re[CARETTRIM], caretTrimReplace);

  // normalize spaces
  range = range.split(/\s+/).join(' ');

  // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
  var set = range.split(' ').map(function(comp) {
    return parseComparator(comp, this.options);
  }, this).join(' ').split(/\s+/);
  if (this.options.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function(comp) {
      return !!comp.match(compRe);
    });
  }
  set = set.map(function(comp) {
    return new Comparator(comp, this.options);
  }, this);

  return set;
};

Range.prototype.intersects = function(range, options) {
  if (!(range instanceof Range)) {
    throw new TypeError('a Range is required');
  }

  return this.set.some(function(thisComparators) {
    return thisComparators.every(function(thisComparator) {
      return range.set.some(function(rangeComparators) {
        return rangeComparators.every(function(rangeComparator) {
          return thisComparator.intersects(rangeComparator, options);
        });
      });
    });
  });
};

// Mostly just for testing and legacy API reasons
exports.toComparators = toComparators;
function toComparators(range, options) {
  return new Range(range, options).set.map(function(comp) {
    return comp.map(function(c) {
      return c.value;
    }).join(' ').trim().split(' ');
  });
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
function parseComparator(comp, options) {
  debug('comp', comp, options);
  comp = replaceCarets(comp, options);
  debug('caret', comp);
  comp = replaceTildes(comp, options);
  debug('tildes', comp);
  comp = replaceXRanges(comp, options);
  debug('xrange', comp);
  comp = replaceStars(comp, options);
  debug('stars', comp);
  return comp;
}

function isX(id) {
  return !id || id.toLowerCase() === 'x' || id === '*';
}

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
function replaceTildes(comp, options) {
  return comp.trim().split(/\s+/).map(function(comp) {
    return replaceTilde(comp, options);
  }).join(' ');
}

function replaceTilde(comp, options) {
  if (!options || typeof options !== 'object')
    options = { loose: !!options, includePrerelease: false }
  var r = options.loose ? re[TILDELOOSE] : re[TILDE];
  return comp.replace(r, function(_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr);
    var ret;

    if (isX(M))
      ret = '';
    else if (isX(m))
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    else if (isX(p))
      // ~1.2 == >=1.2.0 <1.3.0
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
    else if (pr) {
      debug('replaceTilde pr', pr);
      if (pr.charAt(0) !== '-')
        pr = '-' + pr;
      ret = '>=' + M + '.' + m + '.' + p + pr +
            ' <' + M + '.' + (+m + 1) + '.0';
    } else
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p +
            ' <' + M + '.' + (+m + 1) + '.0';

    debug('tilde return', ret);
    return ret;
  });
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0
function replaceCarets(comp, options) {
  return comp.trim().split(/\s+/).map(function(comp) {
    return replaceCaret(comp, options);
  }).join(' ');
}

function replaceCaret(comp, options) {
  debug('caret', comp, options);
  if (!options || typeof options !== 'object')
    options = { loose: !!options, includePrerelease: false }
  var r = options.loose ? re[CARETLOOSE] : re[CARET];
  return comp.replace(r, function(_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr);
    var ret;

    if (isX(M))
      ret = '';
    else if (isX(m))
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    else if (isX(p)) {
      if (M === '0')
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
      else
        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
    } else if (pr) {
      debug('replaceCaret pr', pr);
      if (pr.charAt(0) !== '-')
        pr = '-' + pr;
      if (M === '0') {
        if (m === '0')
          ret = '>=' + M + '.' + m + '.' + p + pr +
                ' <' + M + '.' + m + '.' + (+p + 1);
        else
          ret = '>=' + M + '.' + m + '.' + p + pr +
                ' <' + M + '.' + (+m + 1) + '.0';
      } else
        ret = '>=' + M + '.' + m + '.' + p + pr +
              ' <' + (+M + 1) + '.0.0';
    } else {
      debug('no pr');
      if (M === '0') {
        if (m === '0')
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + m + '.' + (+p + 1);
        else
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + (+m + 1) + '.0';
      } else
        ret = '>=' + M + '.' + m + '.' + p +
              ' <' + (+M + 1) + '.0.0';
    }

    debug('caret return', ret);
    return ret;
  });
}

function replaceXRanges(comp, options) {
  debug('replaceXRanges', comp, options);
  return comp.split(/\s+/).map(function(comp) {
    return replaceXRange(comp, options);
  }).join(' ');
}

function replaceXRange(comp, options) {
  comp = comp.trim();
  if (!options || typeof options !== 'object')
    options = { loose: !!options, includePrerelease: false }
  var r = options.loose ? re[XRANGELOOSE] : re[XRANGE];
  return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr);
    var xM = isX(M);
    var xm = xM || isX(m);
    var xp = xm || isX(p);
    var anyX = xp;

    if (gtlt === '=' && anyX)
      gtlt = '';

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0';
      } else {
        // nothing is forbidden
        ret = '*';
      }
    } else if (gtlt && anyX) {
      // replace X with 0
      if (xm)
        m = 0;
      if (xp)
        p = 0;

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>=';
        if (xm) {
          M = +M + 1;
          m = 0;
          p = 0;
        } else if (xp) {
          m = +m + 1;
          p = 0;
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<';
        if (xm)
          M = +M + 1;
        else
          m = +m + 1;
      }

      ret = gtlt + M + '.' + m + '.' + p;
    } else if (xm) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
    }

    debug('xRange return', ret);

    return ret;
  });
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
function replaceStars(comp, options) {
  debug('replaceStars', comp, options);
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[STAR], '');
}

// This function is passed to string.replace(re[HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0
function hyphenReplace($0,
                       from, fM, fm, fp, fpr, fb,
                       to, tM, tm, tp, tpr, tb) {

  if (isX(fM))
    from = '';
  else if (isX(fm))
    from = '>=' + fM + '.0.0';
  else if (isX(fp))
    from = '>=' + fM + '.' + fm + '.0';
  else
    from = '>=' + from;

  if (isX(tM))
    to = '';
  else if (isX(tm))
    to = '<' + (+tM + 1) + '.0.0';
  else if (isX(tp))
    to = '<' + tM + '.' + (+tm + 1) + '.0';
  else if (tpr)
    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;
  else
    to = '<=' + to;

  return (from + ' ' + to).trim();
}


// if ANY of the sets match ALL of its comparators, then pass
Range.prototype.test = function(version) {
  if (!version)
    return false;

  if (typeof version === 'string')
    version = new SemVer(version, this.options);

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version, this.options))
      return true;
  }
  return false;
};

function testSet(set, version, options) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version))
      return false;
  }

  if (!options)
    options = {}

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (var i = 0; i < set.length; i++) {
      debug(set[i].semver);
      if (set[i].semver === ANY)
        continue;

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver;
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch)
          return true;
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false;
  }

  return true;
}

exports.satisfies = satisfies;
function satisfies(version, range, options) {
  try {
    range = new Range(range, options);
  } catch (er) {
    return false;
  }
  return range.test(version);
}

exports.maxSatisfying = maxSatisfying;
function maxSatisfying(versions, range, options) {
  var max = null;
  var maxSV = null;
  try {
    var rangeObj = new Range(range, options);
  } catch (er) {
    return null;
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) { // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) { // compare(max, v, true)
        max = v;
        maxSV = new SemVer(max, options);
      }
    }
  })
  return max;
}

exports.minSatisfying = minSatisfying;
function minSatisfying(versions, range, options) {
  var min = null;
  var minSV = null;
  try {
    var rangeObj = new Range(range, options);
  } catch (er) {
    return null;
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) { // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) { // compare(min, v, true)
        min = v;
        minSV = new SemVer(min, options);
      }
    }
  })
  return min;
}

exports.validRange = validRange;
function validRange(range, options) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*';
  } catch (er) {
    return null;
  }
}

// Determine if version is less than all the versions possible in the range
exports.ltr = ltr;
function ltr(version, range, options) {
  return outside(version, range, '<', options);
}

// Determine if version is greater than all the versions possible in the range.
exports.gtr = gtr;
function gtr(version, range, options) {
  return outside(version, range, '>', options);
}

exports.outside = outside;
function outside(version, range, hilo, options) {
  version = new SemVer(version, options);
  range = new Range(range, options);

  var gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case '>':
      gtfn = gt;
      ltefn = lte;
      ltfn = lt;
      comp = '>';
      ecomp = '>=';
      break;
    case '<':
      gtfn = lt;
      ltefn = gte;
      ltfn = gt;
      comp = '<';
      ecomp = '<=';
      break;
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  }

  // If it satisifes the range it is not outside
  if (satisfies(version, range, options)) {
    return false;
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i];

    var high = null;
    var low = null;

    comparators.forEach(function(comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator;
      low = low || comparator;
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator;
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator;
      }
    });

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false;
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false;
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false;
    }
  }
  return true;
}

exports.prerelease = prerelease;
function prerelease(version, options) {
  var parsed = parse(version, options);
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null;
}

exports.intersects = intersects;
function intersects(r1, r2, options) {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2)
}

exports.coerce = coerce;
function coerce(version) {
  if (version instanceof SemVer)
    return version;

  if (typeof version !== 'string')
    return null;

  var match = version.match(re[COERCE]);

  if (match == null)
    return null;

  return parse((match[1] || '0') + '.' + (match[2] || '0') + '.' + (match[3] || '0')); 
}


/***/ }),
/* 51 */
/***/ (function(module, exports) {

module.exports = require("truffle-decoder");

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(3);

var _helpers = __webpack_require__(1);

var _sagas = __webpack_require__(53);

var ast = _interopRequireWildcard(_sagas);

var _sagas2 = __webpack_require__(55);

var controller = _interopRequireWildcard(_sagas2);

var _sagas3 = __webpack_require__(29);

var solidity = _interopRequireWildcard(_sagas3);

var _sagas4 = __webpack_require__(27);

var evm = _interopRequireWildcard(_sagas4);

var _sagas5 = __webpack_require__(26);

var trace = _interopRequireWildcard(_sagas5);

var _sagas6 = __webpack_require__(17);

var data = _interopRequireWildcard(_sagas6);

var _sagas7 = __webpack_require__(56);

var web3 = _interopRequireWildcard(_sagas7);

var _actions = __webpack_require__(13);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:session:sagas");

function* saga() {
  debug("starting listeners");
  yield* forkListeners();

  // receiving & saving contracts into state
  debug("waiting for contract information");
  let { contexts, sources } = yield (0, _effects.take)(actions.RECORD_CONTRACTS);

  debug("recording contract binaries");
  yield* recordContexts(...contexts);

  debug("recording contract sources");
  yield* recordSources(...sources);

  debug("waiting for start");
  // wait for start signal
  let { txHash, provider } = yield (0, _effects.take)(actions.START);
  debug("starting");

  // process transaction
  debug("fetching transaction info");
  let err = yield* fetchTx(txHash, provider);
  if (err) {
    debug("error %o", err);
    yield* error(err);
  } else {
    debug("visiting ASTs");
    // visit asts
    yield* ast.visitAll();

    debug("readying");
    // signal that stepping can begin
    yield* ready();
  }
}

exports.default = (0, _helpers.prefixName)("session", saga);


function* forkListeners() {
  return yield (0, _effects.all)([ast, controller, data, evm, solidity, trace, web3].map(app => (0, _effects.fork)(app.saga)));
}

function* fetchTx(txHash, provider) {
  let result = yield* web3.inspectTransaction(txHash, provider);

  if (result.error) {
    return result.error;
  }

  yield* evm.begin(result);

  let addresses = yield* trace.processTrace(result.trace);
  if (result.address && addresses.indexOf(result.address) == -1) {
    addresses.push(result.address);
  }

  let binaries = yield* web3.obtainBinaries(addresses);

  yield (0, _effects.all)(addresses.map((address, i) => (0, _effects.call)(recordInstance, address, binaries[i])));
}

function* recordContexts(...contexts) {
  for (let _ref of contexts) {
    let { contractName, binary, sourceMap, compiler } = _ref;

    yield* evm.addContext(contractName, { binary }, compiler);

    if (sourceMap) {
      yield* solidity.addSourceMap(binary, sourceMap);
    }
  }
}

function* recordSources(...sources) {
  for (let i = 0; i < sources.length; i++) {
    const sourceData = sources[i];
    if (sourceData !== undefined && sourceData !== null) {
      yield* solidity.addSource(sourceData.source, sourceData.sourcePath, sourceData.ast);
    }
  }
}

function* recordInstance(address, binary) {
  yield* evm.addInstance(address, binary);
}

function* ready() {
  yield (0, _effects.put)(actions.ready());
}

function* error(err) {
  yield (0, _effects.put)(actions.error(err));
}

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = __webpack_require__(4);

var _entries2 = _interopRequireDefault(_entries);

exports.visitAll = visitAll;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(3);

var _helpers = __webpack_require__(1);

var _sagas = __webpack_require__(17);

var data = _interopRequireWildcard(_sagas);

var _actions = __webpack_require__(54);

var actions = _interopRequireWildcard(_actions);

var _selectors = __webpack_require__(15);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:ast:sagas");

function* walk(sourceId, node, pointer = "", parentId = null) {
  debug("walking %o %o", pointer, node);

  yield* handleEnter(sourceId, node, pointer, parentId);

  if (node instanceof Array) {
    for (let [i, child] of node.entries()) {
      yield (0, _effects.call)(walk, sourceId, child, `${pointer}/${i}`, parentId);
    }
  } else if (node instanceof Object) {
    for (let [key, child] of (0, _entries2.default)(node)) {
      yield (0, _effects.call)(walk, sourceId, child, `${pointer}/${key}`, node.id);
    }
  }

  yield* handleExit(sourceId, node, pointer);
}

function* handleEnter(sourceId, node, pointer, parentId) {
  if (!(node instanceof Object)) {
    return;
  }

  debug("entering %s", pointer);

  if (node.id !== undefined) {
    debug("%s recording scope %s", pointer, node.id);
    yield* data.scope(node.id, pointer, parentId, sourceId);
  }

  switch (node.nodeType) {
    case "VariableDeclaration":
      debug("%s recording variable %o", pointer, node);
      yield* data.declare(node);
      break;
  }
}

function* handleExit(sourceId, node, pointer) {
  debug("exiting %s", pointer);

  // no-op right now
}

function* walkSaga({ sourceId, ast }) {
  yield walk(sourceId, ast);
}

function* visitAll(idx) {
  let sources = yield (0, _effects.select)(_selectors2.default.views.sources);

  let tasks = yield (0, _effects.all)((0, _entries2.default)(sources).filter(([id, { ast }]) => !!ast).map(([id, { ast }]) => (0, _effects.fork)(() => (0, _effects.put)(actions.visit(id, ast)))));

  if (tasks.length > 0) {
    yield (0, _effects.join)(...tasks);
  }

  yield (0, _effects.put)(actions.doneVisiting());
}

function* saga() {
  yield (0, _effects.race)({
    visitor: (0, _effects.takeEvery)(actions.VISIT, walkSaga),
    done: (0, _effects.take)(actions.DONE_VISITING)
  });
}

exports.default = (0, _helpers.prefixName)("ast", saga);

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.visit = visit;
exports.doneVisiting = doneVisiting;
const VISIT = exports.VISIT = "VISIT";
function visit(sourceId, ast) {
  return {
    type: VISIT,
    sourceId,
    ast
  };
}

const DONE_VISITING = exports.DONE_VISITING = "DONE_VISITING";
function doneVisiting() {
  return {
    type: DONE_VISITING
  };
}

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = __webpack_require__(22);

var _keys2 = _interopRequireDefault(_keys);

var _set = __webpack_require__(18);

var _set2 = _interopRequireDefault(_set);

exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(3);

var _helpers = __webpack_require__(1);

var _sagas = __webpack_require__(26);

var trace = _interopRequireWildcard(_sagas);

var _sagas2 = __webpack_require__(17);

var data = _interopRequireWildcard(_sagas2);

var _sagas3 = __webpack_require__(27);

var evm = _interopRequireWildcard(_sagas3);

var _sagas4 = __webpack_require__(29);

var solidity = _interopRequireWildcard(_sagas4);

var _actions = __webpack_require__(20);

var actions = _interopRequireWildcard(_actions);

var _selectors = __webpack_require__(31);

var _selectors2 = _interopRequireDefault(_selectors);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:controller:sagas");

const CONTROL_SAGAS = {
  [actions.ADVANCE]: advance,
  [actions.STEP_NEXT]: stepNext,
  [actions.STEP_OVER]: stepOver,
  [actions.STEP_INTO]: stepInto,
  [actions.STEP_OUT]: stepOut,
  [actions.CONTINUE]: continueUntilBreakpoint,
  [actions.RESET]: reset
};

/** AST node types that are skipped to filter out some noise */
const SKIPPED_TYPES = new _set2.default(["ContractDefinition", "VariableDeclaration"]);

function* saga() {
  while (true) {
    debug("waiting for control action");
    let action = yield (0, _effects.take)((0, _keys2.default)(CONTROL_SAGAS));
    debug("got control action");
    let saga = CONTROL_SAGAS[action.type];

    yield (0, _effects.put)(actions.beginStep(action.type));

    yield (0, _effects.race)({
      exec: (0, _effects.call)(saga, action),
      interrupt: (0, _effects.take)(actions.INTERRUPT)
    });
  }
}

exports.default = (0, _helpers.prefixName)("controller", saga);

/**
 * Advance the state by one instruction
 */

function* advance() {
  // send action to advance trace
  yield* trace.advance();
}

/**
 * stepNext - step to the next logical code segment
 *
 * Note: It might take multiple instructions to express the same section of code.
 * "Stepping", then, is stepping to the next logical item, not stepping to the next
 * instruction. See advance() if you'd like to advance by one instruction.
 */
function* stepNext() {
  const startingRange = yield (0, _effects.select)(_selectors2.default.current.location.sourceRange);

  var upcoming, finished;

  do {
    // advance at least once step
    yield* advance();

    // and check the next source range
    try {
      upcoming = yield (0, _effects.select)(_selectors2.default.current.location);
    } catch (e) {
      upcoming = null;
    }

    finished = yield (0, _effects.select)(_selectors2.default.finished);

    // if the next step's source range is still the same, keep going
  } while (!finished && (!upcoming || !upcoming.node || SKIPPED_TYPES.has(upcoming.node.nodeType) || upcoming.sourceRange.start == startingRange.start && upcoming.sourceRange.length == startingRange.length));
}

/**
 * stepInto - step into the current function
 *
 * Conceptually this is easy, but from a programming standpoint it's hard.
 * Code like `getBalance(msg.sender)` might be highlighted, but there could
 * be a number of different intermediate steps (like evaluating `msg.sender`)
 * before `getBalance` is stepped into. This function will step into the first
 * function available (where instruction.jump == "i"), ignoring any intermediate
 * steps that fall within the same code range. If there's a step encountered
 * that exists outside of the range, then stepInto will only execute until that
 * step.
 */
function* stepInto() {
  if (yield (0, _effects.select)(_selectors2.default.current.willJump)) {
    yield* stepNext();

    return;
  }

  if (yield (0, _effects.select)(_selectors2.default.current.location.isMultiline)) {
    yield* stepOver();

    return;
  }

  const startingDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
  const startingRange = yield (0, _effects.select)(_selectors2.default.current.location.sourceRange);
  var currentDepth;
  var currentRange;

  do {
    yield* stepNext();

    currentDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
    currentRange = yield (0, _effects.select)(_selectors2.default.current.location.sourceRange);
  } while (
  // the function stack has not increased,
  currentDepth <= startingDepth &&
  // the current source range begins on or after the starting range
  currentRange.start >= startingRange.start &&
  // and the current range ends on or before the starting range ends
  currentRange.start + currentRange.length <= startingRange.start + startingRange.length);
}

/**
 * Step out of the current function
 *
 * This will run until the debugger encounters a decrease in function depth.
 */
function* stepOut() {
  if (yield (0, _effects.select)(_selectors2.default.current.location.isMultiline)) {
    yield* stepOver();

    return;
  }

  const startingDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
  var currentDepth;

  do {
    yield* stepNext();

    currentDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
  } while (currentDepth >= startingDepth);
}

/**
 * stepOver - step over the current line
 *
 * Step over the current line. This will step to the next instruction that
 * exists on a different line of code within the same function depth.
 */
function* stepOver() {
  const startingDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
  const startingRange = yield (0, _effects.select)(_selectors2.default.current.location.sourceRange);
  var currentDepth;
  var currentRange;

  do {
    yield* stepNext();

    currentDepth = yield (0, _effects.select)(_selectors2.default.current.functionDepth);
    currentRange = yield (0, _effects.select)(_selectors2.default.current.location.sourceRange);
  } while (
  // keep stepping provided:
  //
  // we haven't jumped out
  !(currentDepth < startingDepth) && (
  // either: function depth is greater than starting (ignore function calls)
  // or, if we're at the same depth, keep stepping until we're on a new
  // line.
  currentDepth > startingDepth || currentRange.lines.start.line == startingRange.lines.start.line));
}

/**
 * continueUntilBreakpoint - step through execution until a breakpoint
 */
function* continueUntilBreakpoint() {
  var currentLocation, currentNode, currentLine, currentSourceId;
  var finished;
  var previousLine, previousSourceId;

  let breakpoints = yield (0, _effects.select)(_selectors2.default.breakpoints);

  let breakpointHit = false;

  currentLocation = yield (0, _effects.select)(_selectors2.default.current.location);
  currentNode = currentLocation.node.id;
  currentLine = currentLocation.sourceRange.lines.start.line;
  currentSourceId = currentLocation.source.id;

  do {
    yield* stepNext();

    previousLine = currentLine;
    previousSourceId = currentSourceId;

    currentLocation = yield (0, _effects.select)(_selectors2.default.current.location);
    finished = yield (0, _effects.select)(_selectors2.default.finished);
    debug("finished %o", finished);

    currentNode = currentLocation.node.id;
    currentLine = currentLocation.sourceRange.lines.start.line;
    currentSourceId = currentLocation.source.id;

    breakpointHit = breakpoints.filter(({ sourceId, line, node }) => {
      if (node !== undefined) {
        debug("node %d currentNode %d", node, currentNode);
        return sourceId === currentSourceId && node === currentNode;
      }
      //otherwise, we have a line-style breakpoint; we want to stop at the
      //*first* point on the line
      return sourceId === currentSourceId && line === currentLine && (currentSourceId !== previousSourceId || currentLine !== previousLine);
    }).length > 0;
  } while (!breakpointHit && !finished);
}

/**
 * reset -- reset the state of the debugger
 */
function* reset() {
  yield* data.reset();
  yield* evm.reset();
  yield* solidity.reset();
  yield* trace.reset();
}

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.inspectTransaction = inspectTransaction;
exports.obtainBinaries = obtainBinaries;
exports.saga = saga;

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _effects = __webpack_require__(3);

var _helpers = __webpack_require__(1);

var _actions = __webpack_require__(57);

var actions = _interopRequireWildcard(_actions);

var _actions2 = __webpack_require__(13);

var session = _interopRequireWildcard(_actions2);

var _adapter = __webpack_require__(58);

var _adapter2 = _interopRequireDefault(_adapter);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:web3:sagas");

function* fetchTransactionInfo(adapter, { txHash }) {
  debug("inspecting transaction");
  var trace;
  try {
    trace = yield (0, _effects.apply)(adapter, adapter.getTrace, [txHash]);
  } catch (e) {
    debug("putting error");
    yield (0, _effects.put)(actions.error(e));
    return;
  }

  debug("got trace");
  yield (0, _effects.put)(actions.receiveTrace(trace));

  let tx = yield (0, _effects.apply)(adapter, adapter.getTransaction, [txHash]);
  let receipt = yield (0, _effects.apply)(adapter, adapter.getReceipt, [txHash]);

  yield (0, _effects.put)(session.saveTransaction(tx));
  yield (0, _effects.put)(session.saveReceipt(receipt));

  if (tx.to && tx.to != "0x0") {
    yield (0, _effects.put)(actions.receiveCall({ address: tx.to }));
    return;
  }

  if (receipt.contractAddress) {
    yield (0, _effects.put)(actions.receiveCall({ binary: tx.input }));
    return;
  }

  throw new Error("Could not find contract associated with transaction. " + "Please make sure you're debugging a transaction that executes a " + "contract function or creates a new contract.");
}

function* fetchBinary(adapter, { address }) {
  debug("fetching binary for %s", address);
  let binary = yield (0, _effects.apply)(adapter, adapter.getDeployedCode, [address]);

  debug("received binary for %s", address);
  yield (0, _effects.put)(actions.receiveBinary(address, binary));
}

function* inspectTransaction(txHash, provider) {
  yield (0, _effects.put)(actions.init(provider));
  yield (0, _effects.put)(actions.inspect(txHash));

  let action = yield (0, _effects.take)(({ type }) => type == actions.RECEIVE_TRACE || type == actions.ERROR_WEB3);
  debug("action %o", action);

  var trace;
  if (action.type == actions.RECEIVE_TRACE) {
    trace = action.trace;
    debug("received trace");
  } else {
    return { error: action.error };
  }

  let { address, binary } = yield (0, _effects.take)(actions.RECEIVE_CALL);
  debug("received call");

  return { trace, address, binary };
}

function* obtainBinaries(addresses) {
  let tasks = yield (0, _effects.all)(addresses.map(address => (0, _effects.fork)(receiveBinary, address)));

  debug("requesting binaries");
  yield (0, _effects.all)(addresses.map(address => (0, _effects.put)(actions.fetchBinary(address))));

  let binaries = [];
  binaries = yield (0, _effects.all)(tasks.map(task => (0, _effects.join)(task)));

  debug("binaries %o", binaries);

  return binaries;
}

function* receiveBinary(address) {
  let { binary } = yield (0, _effects.take)(action => action.type == actions.RECEIVE_BINARY && action.address == address);
  debug("got binary for %s", address);

  return binary;
}

function* saga() {
  // wait for web3 init signal
  let { provider } = yield (0, _effects.take)(actions.INIT_WEB3);
  let adapter = new _adapter2.default(provider);

  yield (0, _effects.takeEvery)(actions.INSPECT, fetchTransactionInfo, adapter);
  yield (0, _effects.takeEvery)(actions.FETCH_BINARY, fetchBinary, adapter);
}

exports.default = (0, _helpers.prefixName)("web3", saga);

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.init = init;
exports.inspect = inspect;
exports.fetchBinary = fetchBinary;
exports.receiveBinary = receiveBinary;
exports.receiveTrace = receiveTrace;
exports.receiveCall = receiveCall;
exports.error = error;
const INIT_WEB3 = exports.INIT_WEB3 = "INIT_WEB3";
function init(provider) {
  return {
    type: INIT_WEB3,
    provider
  };
}

const INSPECT = exports.INSPECT = "INSPECT_TRANSACTION";
function inspect(txHash) {
  return {
    type: INSPECT,
    txHash
  };
}

const FETCH_BINARY = exports.FETCH_BINARY = "FETCH_BINARY";
function fetchBinary(address) {
  return {
    type: FETCH_BINARY,
    address
  };
}

const RECEIVE_BINARY = exports.RECEIVE_BINARY = "RECEIVE_BINARY";
function receiveBinary(address, binary) {
  return {
    type: RECEIVE_BINARY,
    address,
    binary
  };
}

const RECEIVE_TRACE = exports.RECEIVE_TRACE = "RECEIVE_TRACE";
function receiveTrace(trace) {
  return {
    type: RECEIVE_TRACE,
    trace
  };
}

const RECEIVE_CALL = exports.RECEIVE_CALL = "RECEIVE_CALL";
function receiveCall({ address, binary }) {
  return {
    type: RECEIVE_CALL,
    address,
    binary
  };
}

const ERROR_WEB3 = exports.ERROR_WEB3 = "ERROR_WEB3";
function error(error) {
  return {
    type: ERROR_WEB3,
    error
  };
}

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _promise = __webpack_require__(19);

var _promise2 = _interopRequireDefault(_promise);

var _asyncToGenerator2 = __webpack_require__(12);

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _web = __webpack_require__(59);

var _web2 = _interopRequireDefault(_web);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:web3:adapter");

class Web3Adapter {
  constructor(provider) {
    this.web3 = new _web2.default(provider);
  }

  getTrace(txHash) {
    var _this = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return new _promise2.default(function (accept, reject) {
        _this.web3.currentProvider.send({
          jsonrpc: "2.0",
          method: "debug_traceTransaction",
          params: [txHash, {}],
          id: new Date().getTime()
        }, function (err, result) {
          if (err) return reject(err);
          if (result.error) return reject(new Error(result.error.message));
          debug("result: %o", result);
          accept(result.result.structLogs);
        });
      });
    })();
  }

  getTransaction(txHash) {
    var _this2 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return new _promise2.default(function (accept, reject) {
        _this2.web3.eth.getTransaction(txHash, function (err, tx) {
          if (err) return reject(err);

          return accept(tx);
        });
      });
    })();
  }

  getReceipt(txHash) {
    var _this3 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      return new _promise2.default(function (accept, reject) {
        _this3.web3.eth.getTransactionReceipt(txHash, function (err, receipt) {
          if (err) return reject(err);

          return accept(receipt);
        });
      });
    })();
  }

  /**
   * getDeployedCode - get the deployed code for an address from the client
   * @param  {String} address
   * @return {String}         deployedBinary
   */
  getDeployedCode(address) {
    var _this4 = this;

    return (0, _asyncToGenerator3.default)(function* () {
      debug("getting deployed code for %s", address);
      return new _promise2.default(function (accept, reject) {
        _this4.web3.eth.getCode(address, function (err, deployedBinary) {
          if (err) debug("error: %o", err);
          if (err) return reject(err);
          debug("got deployed code for %s", address);
          accept(deployedBinary);
        });
      });
    })();
  }
}
exports.default = Web3Adapter;

/***/ }),
/* 59 */
/***/ (function(module, exports) {

module.exports = require("web3");

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ERROR = exports.ACTIVE = exports.WAITING = undefined;
exports.status = status;
exports.transaction = transaction;
exports.receipt = receipt;

var _redux = __webpack_require__(6);

var _reducers = __webpack_require__(61);

var _reducers2 = _interopRequireDefault(_reducers);

var _reducers3 = __webpack_require__(62);

var _reducers4 = _interopRequireDefault(_reducers3);

var _reducers5 = __webpack_require__(64);

var _reducers6 = _interopRequireDefault(_reducers5);

var _reducers7 = __webpack_require__(65);

var _reducers8 = _interopRequireDefault(_reducers7);

var _reducers9 = __webpack_require__(66);

var _reducers10 = _interopRequireDefault(_reducers9);

var _actions = __webpack_require__(13);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const WAITING = exports.WAITING = "WAITING";
const ACTIVE = exports.ACTIVE = "ACTIVE";
const ERROR = exports.ERROR = "ERROR";

function status(state = WAITING, action) {
  switch (action.type) {
    case actions.READY:
      return ACTIVE;

    case actions.ERROR:
      return { error: action.error };

    default:
      return state;
  }
}

function transaction(state = {}, action) {
  switch (action.type) {
    case actions.SAVE_TRANSACTION:
      return action.transaction;
    default:
      return state;
  }
}

function receipt(state = {}, action) {
  switch (action.type) {
    case actions.SAVE_RECEIPT:
      return action.receipt;
    default:
      return state;
  }
}

const session = (0, _redux.combineReducers)({
  status,
  transaction,
  receipt
});

const reduceState = (0, _redux.combineReducers)({
  session,
  data: _reducers2.default,
  evm: _reducers4.default,
  solidity: _reducers6.default,
  trace: _reducers8.default,
  controller: _reducers10.default
});

exports.default = reduceState;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = __webpack_require__(4);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(5);

var _assign2 = _interopRequireDefault(_assign);

var _set = __webpack_require__(18);

var _set2 = _interopRequireDefault(_set);

var _values = __webpack_require__(23);

var _values2 = _interopRequireDefault(_values);

var _extends2 = __webpack_require__(7);

var _extends3 = _interopRequireDefault(_extends2);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _redux = __webpack_require__(6);

var _helpers = __webpack_require__(1);

var _actions = __webpack_require__(25);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:data:reducers");

const DEFAULT_SCOPES = {
  byId: {}
};

function scopes(state = DEFAULT_SCOPES, action) {
  var scope;
  var variables;

  switch (action.type) {
    case actions.SCOPE:
      scope = state.byId[action.id] || {};

      return {
        byId: (0, _extends3.default)({}, state.byId, {

          [action.id]: (0, _extends3.default)({}, scope, {

            id: action.id,
            sourceId: action.sourceId,
            parentId: action.parentId,
            pointer: action.pointer
          })
        })
      };

    case actions.DECLARE:
      scope = state.byId[action.node.scope] || {};
      variables = scope.variables || [];

      return {
        byId: (0, _extends3.default)({}, state.byId, {

          [action.node.scope]: (0, _extends3.default)({}, scope, {

            variables: [...variables, { name: action.node.name, id: action.node.id }]
          })
        })
      };

    default:
      return state;
  }
}

const info = (0, _redux.combineReducers)({
  scopes
});

const DEFAULT_ASSIGNMENTS = {
  byId: {},
  byAstId: {}
};

function assignments(state = DEFAULT_ASSIGNMENTS, action) {
  switch (action.type) {
    case actions.ASSIGN:
      debug("action.assignments %O", action.assignments);
      return (0, _values2.default)(action.assignments.byId).reduce((acc, assignment) => {
        let { id, astId } = assignment; //we don't need the rest
        return {
          byId: (0, _extends3.default)({}, acc.byId, {
            [id]: assignment
          }),
          byAstId: (0, _extends3.default)({}, acc.byAstId, {
            [astId]: [...new _set2.default([...(acc.byAstId[astId] || []), id])]
            //we use a set for uniqueness
          })
        };
      }, state);

    case actions.LEARN_ADDRESS:
      let { dummyAddress, address } = action;
      return {
        byId: (0, _assign2.default)({}, ...(0, _entries2.default)(state.byId).map(([, assignment]) => {
          let newAssignment = learnAddress(assignment, dummyAddress, address);
          return {
            [newAssignment.id]: newAssignment
          };
        })),
        byAstId: (0, _assign2.default)({}, ...(0, _entries2.default)(state.byAstId).map(([astId]) => {
          return {
            [astId]: state.byAstId[astId].map(id => learnAddress(state.byId[id], dummyAddress, address).id
            //this above involves some recomputation but oh well
            )
          };
        }))
      };

    case actions.RESET:
      return DEFAULT_ASSIGNMENTS;

    default:
      return state;
  }
}

function learnAddress(assignment, dummyAddress, address) {
  if (assignment.dummyAddress === dummyAddress) {
    //we can assume here that the object being
    //transformed has a very particular form
    let newIdObj = {
      astId: assignment.astId,
      address
    };
    let newId = (0, _helpers.stableKeccak256)(newIdObj);
    return {
      id: newId,
      ref: assignment.ref,
      astId: assignment.astId,
      address
    };
  } else {
    return assignment;
  }
}

const DEFAULT_MAPPING_KEYS = {
  decodingStarted: 0,
  byId: {}
};

function mappingKeys(state = DEFAULT_MAPPING_KEYS, action) {
  switch (action.type) {
    case actions.MAP_KEY_DECODING:
      debug("decoding started: %d", state.decodingStarted + (action.started ? 1 : -1));
      return {
        decodingStarted: state.decodingStarted + (action.started ? 1 : -1),
        byId: (0, _extends3.default)({}, state.byId)
      };
    case actions.MAP_KEY:
      let { id, key } = action;
      debug("mapping id and key: %s, %o", id, key);

      return {
        decodingStarted: state.decodingStarted,
        byId: (0, _extends3.default)({}, state.byId, {

          // add new key to set of keys already defined
          [id]: [...new _set2.default([
          //set for uniqueness
          ...(state.byId[id] || []), key])]
        })
      };

    case actions.RESET:
      return DEFAULT_MAPPING_KEYS;

    default:
      return state;
  }
}

const proc = (0, _redux.combineReducers)({
  assignments,
  mappingKeys
});

const reducer = (0, _redux.combineReducers)({
  info,
  proc
});

exports.default = reducer;

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = __webpack_require__(18);

var _set2 = _interopRequireDefault(_set);

var _from = __webpack_require__(63);

var _from2 = _interopRequireDefault(_from);

var _extends2 = __webpack_require__(7);

var _extends3 = _interopRequireDefault(_extends2);

exports.callstack = callstack;

var _redux = __webpack_require__(6);

var _actions = __webpack_require__(28);

var actions = _interopRequireWildcard(_actions);

var _helpers = __webpack_require__(1);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DEFAULT_CONTEXTS = {
  byContext: {},
  byBinary: {}
};

function contexts(state = DEFAULT_CONTEXTS, action) {
  switch (action.type) {
    /*
     * Adding a new context
     */
    case actions.ADD_CONTEXT:
      {
        const { contractName, raw, compiler } = action;
        const context = (0, _helpers.keccak256)(raw);

        return (0, _extends3.default)({}, state, {

          byContext: (0, _extends3.default)({}, state.byContext, {

            [context]: (0, _extends3.default)({}, state.byContext[context] || {}, {

              contractName,
              context,
              compiler
            })
          })
        });
      }

    /*
     * Adding binary for a context
     */
    case actions.ADD_BINARY:
      {
        const { context, binary } = action;

        if (state.byBinary[binary]) {
          return state;
        }

        return {
          byContext: (0, _extends3.default)({}, state.byContext, {

            [context]: (0, _extends3.default)({}, state.byContext[context], {

              binary
            })
          }),

          byBinary: (0, _extends3.default)({}, state.byBinary, {

            [binary]: { context: context }
          })
        };
      }

    /*
     * Default case
     */
    default:
      return state;
  }
}

const DEFAULT_INSTANCES = {
  byAddress: {},
  byContext: {}
};

function instances(state = DEFAULT_INSTANCES, action) {
  switch (action.type) {
    /*
     * Adding a new address for context
     */
    case actions.ADD_INSTANCE:
      let { address, context, binary } = action;

      address = address.toLowerCase();

      // get known addresses for this context
      let otherInstances = state.byContext[context] || [];
      let otherAddresses = otherInstances.map(({ address }) => address);

      return {
        byAddress: (0, _extends3.default)({}, state.byAddress, {

          [address]: { address, context, binary }
        }),

        byContext: (0, _extends3.default)({}, state.byContext, {

          // reconstruct context instances to include new address
          [context]: (0, _from2.default)(new _set2.default(otherAddresses).add(address)).map(address => ({ address }))
        })
      };

    /*
     * Default case
     */
    default:
      return state;
  }
}

const info = (0, _redux.combineReducers)({
  contexts,
  instances
});

function callstack(state = [], action) {
  switch (action.type) {
    case actions.CALL:
      let address = action.address.toLowerCase();
      //we get some addresses in lowercase, some in checksum case,
      //so I'm lowercasing them all for consistency
      return state.concat([{ address }]);

    case actions.CREATE:
      const binary = action.binary;
      return state.concat([{ binary }]);

    case actions.RETURN:
      //HACK: pop the stack, UNLESS that would leave it empty (this will only
      //happen at the end when we want to keep the last one around)
      return state.length > 1 ? state.slice(0, -1) : state;

    case action.RESET:
      return [state[0]]; //leave the initial call still on the stack

    default:
      return state;
  }
}

const proc = (0, _redux.combineReducers)({
  callstack
});

const reducer = (0, _redux.combineReducers)({
  info,
  proc
});

exports.default = reducer;

/***/ }),
/* 63 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/core-js/array/from");

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = __webpack_require__(7);

var _extends3 = _interopRequireDefault(_extends2);

var _keys = __webpack_require__(22);

var _keys2 = _interopRequireDefault(_keys);

exports.functionDepth = functionDepth;

var _redux = __webpack_require__(6);

var _helpers = __webpack_require__(1);

var _actions = __webpack_require__(30);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DEFAULT_SOURCES = {
  byId: {}
};

function sources(state = DEFAULT_SOURCES, action) {
  switch (action.type) {
    /*
     * Adding a new source
     */
    case actions.ADD_SOURCE:
      let { ast, source, sourcePath, compiler } = action;

      let id = (0, _keys2.default)(state.byId).length;

      return {
        byId: (0, _extends3.default)({}, state.byId, {

          [id]: {
            id,
            ast,
            source,
            sourcePath,
            compiler
          }
        })
      };

    /*
     * Default case
     */
    default:
      return state;
  }
}

const DEFAULT_SOURCEMAPS = {
  byContext: {}
};

function sourceMaps(state = DEFAULT_SOURCEMAPS, action) {
  switch (action.type) {
    /*
     * Adding a new sourceMap
     */
    case actions.ADD_SOURCEMAP:
      let { binary, sourceMap } = action;
      let context = (0, _helpers.keccak256)(binary);

      return {
        byContext: (0, _extends3.default)({}, state.byContext, {

          [context]: {
            context,
            sourceMap
          }
        })
      };

    /*
     * Default Case
     */
    default:
      return state;
  }
}

const info = (0, _redux.combineReducers)({
  sources,
  sourceMaps
});

function functionDepth(state = 0, action) {
  switch (action.type) {
    case actions.JUMP:
      const delta = spelunk(action.jumpDirection);
      return state + delta;

    case actions.RESET:
      return 0;

    default:
      return state;
  }
}

function spelunk(jump) {
  if (jump == "i") {
    return 1;
  } else if (jump == "o") {
    return -1;
  } else if (jump == "2") {
    return 2; //HACK WORKAROUND
  } else {
    return 0;
  }
}

const proc = (0, _redux.combineReducers)({
  functionDepth
});

const reducer = (0, _redux.combineReducers)({
  info,
  proc
});

exports.default = reducer;

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.index = index;
exports.finished = finished;
exports.steps = steps;

var _redux = __webpack_require__(6);

var _actions = __webpack_require__(11);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function index(state = 0, action) {
  switch (action.type) {
    case actions.TOCK:
      return state + 1;

    case actions.RESET:
      return 0;

    default:
      return state;
  }
}

function finished(state = false, action) {
  switch (action.type) {
    case actions.END_OF_TRACE:
      return true;

    case actions.RESET:
      return false;

    default:
      return state;
  }
}

function steps(state = null, action) {
  if (action.type === actions.SAVE_STEPS) {
    return action.steps;
  } else {
    return state;
  }
}

const info = (0, _redux.combineReducers)({
  steps
});

const proc = (0, _redux.combineReducers)({
  index,
  finished
});

const reducer = (0, _redux.combineReducers)({
  info,
  proc
});

exports.default = reducer;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _redux = __webpack_require__(6);

var _actions = __webpack_require__(20);

var actions = _interopRequireWildcard(_actions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:controller:reducers"); //eslint-disable-line no-unused-vars

function breakpoints(state = [], action) {
  switch (action.type) {
    case actions.ADD_BREAKPOINT:
      //check for any existing identical breakpoints to avoid redundancy
      if (state.filter(breakpoint => breakpoint.sourceId === action.breakpoint.sourceId && breakpoint.line === action.breakpoint.line && breakpoint.node === action.breakpoint.node //may be undefined
      ).length > 0) {
        //if it's already there, do nothing
        return state;
      } else {
        //otherwise add it
        return state.concat([action.breakpoint]);
      }
      break;

    case actions.REMOVE_BREAKPOINT:
      return state.filter(breakpoint => breakpoint.sourceId !== action.breakpoint.sourceId || breakpoint.line !== action.breakpoint.line || breakpoint.node !== action.breakpoint.node //may be undefined
      );
      break;

    case actions.REMOVE_ALL_BREAKPOINTS:
      return [];

    default:
      return state;
  }
}

const reducer = (0, _redux.combineReducers)({
  breakpoints
});

exports.default = reducer;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _entries = __webpack_require__(4);

var _entries2 = _interopRequireDefault(_entries);

var _assign = __webpack_require__(5);

var _assign2 = _interopRequireDefault(_assign);

var _debug = __webpack_require__(0);

var _debug2 = _interopRequireDefault(_debug);

var _reselectTree = __webpack_require__(2);

var _selectors = __webpack_require__(9);

var _selectors2 = _interopRequireDefault(_selectors);

var _selectors3 = __webpack_require__(8);

var _selectors4 = _interopRequireDefault(_selectors3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const debug = (0, _debug2.default)("debugger:session:selectors");

const session = (0, _reselectTree.createSelectorTree)({
  /**
   * session.info
   */
  info: {

    /**
     * session.info.affectedInstances
     */
    affectedInstances: (0, _reselectTree.createLeaf)([_selectors2.default.info.instances, _selectors2.default.info.contexts, _selectors4.default.info.sources, _selectors4.default.info.sourceMaps], (instances, contexts, sources, sourceMaps) => (0, _assign2.default)({}, ...(0, _entries2.default)(instances).map(([address, { context }]) => {
      debug("instances %O", instances);
      debug("contexts %O", contexts);
      let { contractName, binary } = contexts[context];
      let { sourceMap } = sourceMaps[context] || {};

      let { source } = sourceMap ?
      // look for source ID between second and third colons (HACK)
      sources[sourceMap.match(/^[^:]+:[^:]+:([^:]+):/)[1]] : {};

      return {
        [address]: {
          contractName, source, binary
        }
      };
    })))

  },

  /**
   * session.transaction (namespace)
   */
  transaction: {

    /**
     * session.transaction (selector)
     * contains the web3 transaction object
     */
    _: state => state.session.transaction,

    /**
     * session.transaction.receipt
     * contains the web3 receipt object
     */
    receipt: state => state.session.receipt

  }

});

exports.default = session;

/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVidWdnZXIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsIndlYnBhY2svYm9vdHN0cmFwIGYzMzVlMGJiZWFiYWE4ZTJhNDMwIiwiZXh0ZXJuYWwgXCJkZWJ1Z1wiIiwibGliL2hlbHBlcnMvaW5kZXguanMiLCJleHRlcm5hbCBcInJlc2VsZWN0LXRyZWVcIiIsImV4dGVybmFsIFwicmVkdXgtc2FnYS9lZmZlY3RzXCIiLCJleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZW50cmllc1wiIiwiZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2Fzc2lnblwiIiwiZXh0ZXJuYWwgXCJyZWR1eFwiIiwiZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvZXh0ZW5kc1wiIiwibGliL3NvbGlkaXR5L3NlbGVjdG9ycy9pbmRleC5qcyIsImxpYi9ldm0vc2VsZWN0b3JzL2luZGV4LmpzIiwiZXh0ZXJuYWwgXCJ0cnVmZmxlLWRlY29kZS11dGlsc1wiIiwibGliL3RyYWNlL2FjdGlvbnMvaW5kZXguanMiLCJleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIiLCJsaWIvc2Vzc2lvbi9hY3Rpb25zL2luZGV4LmpzIiwiZXh0ZXJuYWwgXCJqc29uLXBvaW50ZXJcIiIsImxpYi9hc3Qvc2VsZWN0b3JzL2luZGV4LmpzIiwibGliL3RyYWNlL3NlbGVjdG9ycy9pbmRleC5qcyIsImxpYi9kYXRhL3NhZ2FzL2luZGV4LmpzIiwiZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvc2V0XCIiLCJleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9wcm9taXNlXCIiLCJsaWIvY29udHJvbGxlci9hY3Rpb25zL2luZGV4LmpzIiwibGliL2RhdGEvc2VsZWN0b3JzL2luZGV4LmpzIiwiZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2tleXNcIiIsImV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC92YWx1ZXNcIiIsImxpYi9hc3QvbWFwLmpzIiwibGliL2RhdGEvYWN0aW9ucy9pbmRleC5qcyIsImxpYi90cmFjZS9zYWdhcy9pbmRleC5qcyIsImxpYi9ldm0vc2FnYXMvaW5kZXguanMiLCJsaWIvZXZtL2FjdGlvbnMvaW5kZXguanMiLCJsaWIvc29saWRpdHkvc2FnYXMvaW5kZXguanMiLCJsaWIvc29saWRpdHkvYWN0aW9ucy9pbmRleC5qcyIsImxpYi9jb250cm9sbGVyL3NlbGVjdG9ycy9pbmRleC5qcyIsIi9Vc2Vycy9nbmlkYW4vc3JjL3dvcmsvdHJ1ZmZsZS9wYWNrYWdlcy90cnVmZmxlLWRlYnVnZ2VyL2RlYnVnZ2VyLmpzIiwibGliL2RlYnVnZ2VyLmpzIiwiZXh0ZXJuYWwgXCJ0cnVmZmxlLWV4cGVjdFwiIiwibGliL3Nlc3Npb24vaW5kZXguanMiLCJsaWIvc3RvcmUvaW5kZXguanMiLCJsaWIvc3RvcmUvcHJvZHVjdGlvbi5qcyIsImxpYi9zdG9yZS9jb21tb24uanMiLCJleHRlcm5hbCBcInJlZHV4LXNhZ2FcIiIsImV4dGVybmFsIFwicmVkdXgtY2xpLWxvZ2dlclwiIiwiL1VzZXJzL2duaWRhbi9zcmMvd29yay90cnVmZmxlL25vZGVfbW9kdWxlcy9qc29uLXN0YWJsZS1zdHJpbmdpZnkvaW5kZXguanMiLCIvVXNlcnMvZ25pZGFuL3NyYy93b3JrL3RydWZmbGUvbm9kZV9tb2R1bGVzL2pzb25pZnkvaW5kZXguanMiLCIvVXNlcnMvZ25pZGFuL3NyYy93b3JrL3RydWZmbGUvbm9kZV9tb2R1bGVzL2pzb25pZnkvbGliL3BhcnNlLmpzIiwiL1VzZXJzL2duaWRhbi9zcmMvd29yay90cnVmZmxlL25vZGVfbW9kdWxlcy9qc29uaWZ5L2xpYi9zdHJpbmdpZnkuanMiLCJleHRlcm5hbCBcInRydWZmbGUtc29saWRpdHktdXRpbHNcIiIsImV4dGVybmFsIFwidHJ1ZmZsZS1jb2RlLXV0aWxzXCIiLCIvVXNlcnMvZ25pZGFuL3NyYy93b3JrL3RydWZmbGUvbm9kZV9tb2R1bGVzL25vZGUtaW50ZXJ2YWwtdHJlZS9saWIvaW5kZXguanMiLCIvVXNlcnMvZ25pZGFuL3NyYy93b3JrL3RydWZmbGUvbm9kZV9tb2R1bGVzL3NoYWxsb3dlcXVhbC9pbmRleC5qcyIsImV4dGVybmFsIFwiZmFzdC1sZXZlbnNodGVpblwiIiwiL1VzZXJzL2duaWRhbi9zcmMvd29yay90cnVmZmxlL25vZGVfbW9kdWxlcy9zZW12ZXIvc2VtdmVyLmpzIiwiZXh0ZXJuYWwgXCJ0cnVmZmxlLWRlY29kZXJcIiIsImxpYi9zZXNzaW9uL3NhZ2FzL2luZGV4LmpzIiwibGliL2FzdC9zYWdhcy9pbmRleC5qcyIsImxpYi9hc3QvYWN0aW9ucy9pbmRleC5qcyIsImxpYi9jb250cm9sbGVyL3NhZ2FzL2luZGV4LmpzIiwibGliL3dlYjMvc2FnYXMvaW5kZXguanMiLCJsaWIvd2ViMy9hY3Rpb25zL2luZGV4LmpzIiwibGliL3dlYjMvYWRhcHRlci5qcyIsImV4dGVybmFsIFwid2ViM1wiIiwibGliL3Nlc3Npb24vcmVkdWNlcnMuanMiLCJsaWIvZGF0YS9yZWR1Y2Vycy5qcyIsImxpYi9ldm0vcmVkdWNlcnMuanMiLCJleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9hcnJheS9mcm9tXCIiLCJsaWIvc29saWRpdHkvcmVkdWNlcnMuanMiLCJsaWIvdHJhY2UvcmVkdWNlcnMuanMiLCJsaWIvY29udHJvbGxlci9yZWR1Y2Vycy5qcyIsImxpYi9zZXNzaW9uL3NlbGVjdG9ycy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShcIkRlYnVnZ2VyXCIsIFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIkRlYnVnZ2VyXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIkRlYnVnZ2VyXCJdID0gZmFjdG9yeSgpO1xufSkodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAzMik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgZjMzNWUwYmJlYWJhYThlMmE0MzAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImRlYnVnXCJcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICogYXMgdXRpbHMgZnJvbSBcInRydWZmbGUtZGVjb2RlLXV0aWxzXCI7XG5cbmNvbnN0IHN0cmluZ2lmeSA9IHJlcXVpcmUoXCJqc29uLXN0YWJsZS1zdHJpbmdpZnlcIik7XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmVmaXhOYW1lKHByZWZpeCwgZm4pIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBcIm5hbWVcIiwge1xuICAgIHZhbHVlOiBgJHtwcmVmaXh9LiR7Zm4ubmFtZX1gLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcblxuICByZXR1cm4gZm47XG59XG5cbi8qKlxuICogQHJldHVybiAweC1wcmVmaXggc3RyaW5nIG9mIGtlY2NhazI1NiBoYXNoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBrZWNjYWsyNTYoLi4uYXJncykge1xuICByZXR1cm4gdXRpbHMuQ29udmVyc2lvbi50b0hleFN0cmluZyh1dGlscy5FVk0ua2VjY2FrMjU2KC4uLmFyZ3MpKTtcbn1cblxuLyoqXG4gKiBHaXZlbiBhbiBvYmplY3QsIHJldHVybiBhIHN0YWJsZSBoYXNoIGJ5IGZpcnN0IHJ1bm5pbmcgaXQgdGhyb3VnaCBhIHN0YWJsZVxuICogc3RyaW5naWZ5IG9wZXJhdGlvbiBiZWZvcmUgaGFzaGluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhYmxlS2VjY2FrMjU2KG9iaikge1xuICByZXR1cm4ga2VjY2FrMjU2KHN0cmluZ2lmeShvYmopKTtcbn1cblxuLypcbiAqIEdpdmVuIGEgbW1lbW9uaWMsIGRldGVybWluZSB3aGV0aGVyIGl0J3MgdGhlIG1uZW1vbmljIG9mIGEgY2FsbGluZ1xuICogaW5zdHJ1Y3Rpb24gKGRvZXMgTk9UIGluY2x1ZGUgY3JlYXRpb24gaW5zdHJ1Y3Rpb25zKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNDYWxsTW5lbW9uaWMob3ApIHtcbiAgY29uc3QgY2FsbHMgPSBbXCJDQUxMXCIsIFwiREVMRUdBVEVDQUxMXCIsIFwiU1RBVElDQ0FMTFwiLCBcIkNBTExDT0RFXCJdO1xuICByZXR1cm4gY2FsbHMuaW5jbHVkZXMob3ApO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9oZWxwZXJzL2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVzZWxlY3QtdHJlZVwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInJlc2VsZWN0LXRyZWVcIlxuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWR1eC1zYWdhL2VmZmVjdHNcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJyZWR1eC1zYWdhL2VmZmVjdHNcIlxuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2VudHJpZXNcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2VudHJpZXNcIlxuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2Fzc2lnblwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduXCJcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVkdXhcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJyZWR1eFwiXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvaGVscGVycy9leHRlbmRzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2V4dGVuZHNcIlxuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6c29saWRpdHk6c2VsZWN0b3JzXCIpO1xuXG5pbXBvcnQgeyBjcmVhdGVTZWxlY3RvclRyZWUsIGNyZWF0ZUxlYWYgfSBmcm9tIFwicmVzZWxlY3QtdHJlZVwiO1xuaW1wb3J0IFNvbGlkaXR5VXRpbHMgZnJvbSBcInRydWZmbGUtc29saWRpdHktdXRpbHNcIjtcbmltcG9ydCBDb2RlVXRpbHMgZnJvbSBcInRydWZmbGUtY29kZS11dGlsc1wiO1xuXG5pbXBvcnQgKiBhcyBUcnVmZmxlRGVjb2RlVXRpbHMgZnJvbSBcInRydWZmbGUtZGVjb2RlLXV0aWxzXCI7XG5pbXBvcnQgeyBmaW5kUmFuZ2UgfSBmcm9tIFwibGliL2FzdC9tYXBcIjtcbmltcG9ydCBqc29ucG9pbnRlciBmcm9tIFwianNvbi1wb2ludGVyXCI7XG5cbmltcG9ydCBldm0gZnJvbSBcImxpYi9ldm0vc2VsZWN0b3JzXCI7XG5cbmNvbnN0IHNlbXZlciA9IHJlcXVpcmUoXCJzZW12ZXJcIik7XG5cbmZ1bmN0aW9uIGdldFNvdXJjZVJhbmdlKGluc3RydWN0aW9uID0ge30pIHtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogaW5zdHJ1Y3Rpb24uc3RhcnQgfHwgMCxcbiAgICBsZW5ndGg6IGluc3RydWN0aW9uLmxlbmd0aCB8fCAwLFxuICAgIGxpbmVzOiBpbnN0cnVjdGlvbi5yYW5nZSB8fCB7XG4gICAgICBzdGFydDoge1xuICAgICAgICBsaW5lOiAwLFxuICAgICAgICBjb2x1bW46IDBcbiAgICAgIH0sXG4gICAgICBlbmQ6IHtcbiAgICAgICAgbGluZTogMCxcbiAgICAgICAgY29sdW1uOiAwXG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5sZXQgc29saWRpdHkgPSBjcmVhdGVTZWxlY3RvclRyZWUoe1xuICAvKipcbiAgICogc29saWRpdHkuc3RhdGVcbiAgICovXG4gIHN0YXRlOiBzdGF0ZSA9PiBzdGF0ZS5zb2xpZGl0eSxcblxuICAvKipcbiAgICogc29saWRpdHkuaW5mb1xuICAgKi9cbiAgaW5mbzoge1xuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmluZm8uc291cmNlc1xuICAgICAqL1xuICAgIHNvdXJjZXM6IGNyZWF0ZUxlYWYoW1wiL3N0YXRlXCJdLCBzdGF0ZSA9PiBzdGF0ZS5pbmZvLnNvdXJjZXMuYnlJZCksXG5cbiAgICAvKipcbiAgICAgKiBzb2xpZGl0eS5pbmZvLnNvdXJjZU1hcHNcbiAgICAgKi9cbiAgICBzb3VyY2VNYXBzOiBjcmVhdGVMZWFmKFtcIi9zdGF0ZVwiXSwgc3RhdGUgPT4gc3RhdGUuaW5mby5zb3VyY2VNYXBzLmJ5Q29udGV4dClcbiAgfSxcblxuICAvKipcbiAgICogc29saWRpdHkuY3VycmVudFxuICAgKi9cbiAgY3VycmVudDoge1xuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQuc291cmNlTWFwXG4gICAgICovXG4gICAgc291cmNlTWFwOiBjcmVhdGVMZWFmKFxuICAgICAgW2V2bS5jdXJyZW50LmNvbnRleHQsIFwiL2luZm8vc291cmNlTWFwc1wiXSxcblxuICAgICAgKHsgY29udGV4dCB9LCBzb3VyY2VNYXBzKSA9PiBzb3VyY2VNYXBzW2NvbnRleHRdIHx8IHt9XG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQuZnVuY3Rpb25EZXB0aFxuICAgICAqL1xuICAgIGZ1bmN0aW9uRGVwdGg6IHN0YXRlID0+IHN0YXRlLnNvbGlkaXR5LnByb2MuZnVuY3Rpb25EZXB0aCxcblxuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQuaW5zdHJ1Y3Rpb25zXG4gICAgICovXG4gICAgaW5zdHJ1Y3Rpb25zOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiL2luZm8vc291cmNlc1wiLCBldm0uY3VycmVudC5jb250ZXh0LCBcIi4vc291cmNlTWFwXCJdLFxuXG4gICAgICAoc291cmNlcywgeyBiaW5hcnkgfSwgeyBzb3VyY2VNYXAgfSkgPT4ge1xuICAgICAgICBpZiAoIWJpbmFyeSkge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpbnN0cnVjdGlvbnMgPSBDb2RlVXRpbHMucGFyc2VDb2RlKGJpbmFyeSk7XG5cbiAgICAgICAgaWYgKCFzb3VyY2VNYXApIHtcbiAgICAgICAgICAvLyBMZXQncyBjcmVhdGUgYSBzb3VyY2UgbWFwIHRvIHVzZSBzaW5jZSBub25lIGV4aXN0cy4gVGhpcyBzb3VyY2UgbWFwXG4gICAgICAgICAgLy8gbWFwcyBqdXN0IGFzIG1hbnkgcmFuZ2VzIGFzIHRoZXJlIGFyZSBpbnN0cnVjdGlvbnMsIGFuZCBlbnN1cmVzIGV2ZXJ5XG4gICAgICAgICAgLy8gaW5zdHJ1Y3Rpb24gaXMgbWFya2VkIGFzIFwianVtcGluZyBvdXRcIi4gVGhpcyB3aWxsIGVuc3VyZSBhbGxcbiAgICAgICAgICAvLyBhdmFpbGFibGUgZGVidWdnZXIgY29tbWFuZHMgc3RlcCBvbmUgaW5zdHJ1Y3Rpb24gYXQgYSB0aW1lLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gVGhpcyBpcyBraW5kb2YgYSBoYWNrOyBwZXJoYXBzIHRoaXMgc2hvdWxkIGJlIGJyb2tlbiBvdXQgaW50byBzZXBhcmF0ZVxuICAgICAgICAgIC8vIGNvbnRleHQgdHlwZXMuIFRPRE9cbiAgICAgICAgICBzb3VyY2VNYXAgPSBcIlwiO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzb3VyY2VNYXAgKz0gaSArIFwiOlwiICsgaSArIFwiOjE6LTE7XCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxpbmVBbmRDb2x1bW5NYXBwaW5ncyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge30sXG4gICAgICAgICAgLi4uT2JqZWN0LmVudHJpZXMoc291cmNlcykubWFwKChbaWQsIHsgc291cmNlIH1dKSA9PiAoe1xuICAgICAgICAgICAgW2lkXTogU29saWRpdHlVdGlscy5nZXRDaGFyYWN0ZXJPZmZzZXRUb0xpbmVBbmRDb2x1bW5NYXBwaW5nKFxuICAgICAgICAgICAgICBzb3VyY2UgfHwgXCJcIlxuICAgICAgICAgICAgKVxuICAgICAgICAgIH0pKVxuICAgICAgICApO1xuICAgICAgICB2YXIgaHVtYW5SZWFkYWJsZVNvdXJjZU1hcCA9IFNvbGlkaXR5VXRpbHMuZ2V0SHVtYW5SZWFkYWJsZVNvdXJjZU1hcChcbiAgICAgICAgICBzb3VyY2VNYXBcbiAgICAgICAgKTtcblxuICAgICAgICBsZXQgcHJpbWFyeUZpbGUgPSBodW1hblJlYWRhYmxlU291cmNlTWFwWzBdLmZpbGU7XG4gICAgICAgIGRlYnVnKFwicHJpbWFyeUZpbGUgJW9cIiwgcHJpbWFyeUZpbGUpO1xuXG4gICAgICAgIHJldHVybiBpbnN0cnVjdGlvbnNcbiAgICAgICAgICAubWFwKChpbnN0cnVjdGlvbiwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIC8vIGxvb2t1cCBzb3VyY2UgbWFwIGJ5IGluZGV4IGFuZCBhZGQgYGluZGV4YCBwcm9wZXJ0eSB0b1xuICAgICAgICAgICAgLy8gaW5zdHJ1Y3Rpb25cbiAgICAgICAgICAgIC8vXG5cbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZU1hcCA9IGh1bWFuUmVhZGFibGVTb3VyY2VNYXBbaW5kZXhdIHx8IHt9O1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBpbnN0cnVjdGlvbjogeyAuLi5pbnN0cnVjdGlvbiwgaW5kZXggfSxcbiAgICAgICAgICAgICAgc291cmNlTWFwXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLm1hcCgoeyBpbnN0cnVjdGlvbiwgc291cmNlTWFwIH0pID0+IHtcbiAgICAgICAgICAgIC8vIGFkZCBzb3VyY2UgbWFwIGluZm9ybWF0aW9uIHRvIGluc3RydWN0aW9uLCBvciBkZWZhdWx0c1xuICAgICAgICAgICAgLy9cblxuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBqdW1wLFxuICAgICAgICAgICAgICBzdGFydCA9IDAsXG4gICAgICAgICAgICAgIGxlbmd0aCA9IDAsXG4gICAgICAgICAgICAgIGZpbGUgPSBwcmltYXJ5RmlsZVxuICAgICAgICAgICAgfSA9IHNvdXJjZU1hcDtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVBbmRDb2x1bW5NYXBwaW5nID0gbGluZUFuZENvbHVtbk1hcHBpbmdzW2ZpbGVdIHx8IHt9O1xuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSB7XG4gICAgICAgICAgICAgIHN0YXJ0OiBsaW5lQW5kQ29sdW1uTWFwcGluZ1tzdGFydF0gfHwge1xuICAgICAgICAgICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgICAgICAgICAgY29sdW1uOiBudWxsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGVuZDogbGluZUFuZENvbHVtbk1hcHBpbmdbc3RhcnQgKyBsZW5ndGhdIHx8IHtcbiAgICAgICAgICAgICAgICBsaW5lOiBudWxsLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogbnVsbFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAocmFuZ2Uuc3RhcnQubGluZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBkZWJ1ZyhcInNvdXJjZU1hcCAlb1wiLCBzb3VyY2VNYXApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAuLi5pbnN0cnVjdGlvbixcblxuICAgICAgICAgICAgICBqdW1wLFxuICAgICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgICAgbGVuZ3RoLFxuICAgICAgICAgICAgICBmaWxlLFxuICAgICAgICAgICAgICByYW5nZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogc29saWRpdHkuY3VycmVudC5pbnN0cnVjdGlvbkF0UHJvZ3JhbUNvdW50ZXJcbiAgICAgKi9cbiAgICBpbnN0cnVjdGlvbkF0UHJvZ3JhbUNvdW50ZXI6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIuL2luc3RydWN0aW9uc1wiXSxcblxuICAgICAgaW5zdHJ1Y3Rpb25zID0+IHtcbiAgICAgICAgbGV0IG1hcCA9IFtdO1xuICAgICAgICBpbnN0cnVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihpbnN0cnVjdGlvbikge1xuICAgICAgICAgIG1hcFtpbnN0cnVjdGlvbi5wY10gPSBpbnN0cnVjdGlvbjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZmlsbCBpbiBnYXBzIGluIG1hcCBieSBkZWZhdWx0aW5nIHRvIHRoZSBsYXN0IGtub3duIGluc3RydWN0aW9uXG4gICAgICAgIGxldCBsYXN0U2VlbiA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IFtwYywgaW5zdHJ1Y3Rpb25dIG9mIG1hcC5lbnRyaWVzKCkpIHtcbiAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgICAgIGxhc3RTZWVuID0gaW5zdHJ1Y3Rpb247XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hcFtwY10gPSBsYXN0U2VlbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgIH1cbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogc29saWRpdHkuY3VycmVudC5pbnN0cnVjdGlvblxuICAgICAqL1xuICAgIGluc3RydWN0aW9uOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiLi9pbnN0cnVjdGlvbkF0UHJvZ3JhbUNvdW50ZXJcIiwgZXZtLmN1cnJlbnQuc3RlcC5wcm9ncmFtQ291bnRlcl0sXG5cbiAgICAgIChtYXAsIHBjKSA9PiBtYXBbcGNdIHx8IHt9XG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQuc291cmNlXG4gICAgICovXG4gICAgc291cmNlOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiL2luZm8vc291cmNlc1wiLCBcIi4vaW5zdHJ1Y3Rpb25cIl0sXG5cbiAgICAgIChzb3VyY2VzLCB7IGZpbGU6IGlkIH0pID0+IHNvdXJjZXNbaWRdIHx8IHt9XG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQuc291cmNlUmFuZ2VcbiAgICAgKi9cbiAgICBzb3VyY2VSYW5nZTogY3JlYXRlTGVhZihbXCIuL2luc3RydWN0aW9uXCJdLCBnZXRTb3VyY2VSYW5nZSksXG5cbiAgICAvKipcbiAgICAgKiBzb2xpZGl0eS5jdXJyZW50LmlzU291cmNlUmFuZ2VGaW5hbFxuICAgICAqL1xuICAgIGlzU291cmNlUmFuZ2VGaW5hbDogY3JlYXRlTGVhZihcbiAgICAgIFtcbiAgICAgICAgXCIuL2luc3RydWN0aW9uQXRQcm9ncmFtQ291bnRlclwiLFxuICAgICAgICBldm0uY3VycmVudC5zdGVwLnByb2dyYW1Db3VudGVyLFxuICAgICAgICBldm0ubmV4dC5zdGVwLnByb2dyYW1Db3VudGVyXG4gICAgICBdLFxuXG4gICAgICAobWFwLCBjdXJyZW50LCBuZXh0KSA9PiB7XG4gICAgICAgIGlmICghbWFwW25leHRdKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50ID0gbWFwW2N1cnJlbnRdO1xuICAgICAgICBuZXh0ID0gbWFwW25leHRdO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgY3VycmVudC5zdGFydCAhPSBuZXh0LnN0YXJ0IHx8XG4gICAgICAgICAgY3VycmVudC5sZW5ndGggIT0gbmV4dC5sZW5ndGggfHxcbiAgICAgICAgICBjdXJyZW50LmZpbGUgIT0gbmV4dC5maWxlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQuaXNNdWx0aWxpbmVcbiAgICAgKi9cbiAgICBpc011bHRpbGluZTogY3JlYXRlTGVhZihcbiAgICAgIFtcIi4vc291cmNlUmFuZ2VcIl0sXG5cbiAgICAgICh7IGxpbmVzIH0pID0+IGxpbmVzLnN0YXJ0LmxpbmUgIT0gbGluZXMuZW5kLmxpbmVcbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogc29saWRpdHkuY3VycmVudC53aWxsSnVtcFxuICAgICAqL1xuICAgIHdpbGxKdW1wOiBjcmVhdGVMZWFmKFtldm0uY3VycmVudC5zdGVwLmlzSnVtcF0sIGlzSnVtcCA9PiBpc0p1bXApLFxuXG4gICAgLyoqXG4gICAgICogc29saWRpdHkuY3VycmVudC5qdW1wRGlyZWN0aW9uXG4gICAgICovXG4gICAganVtcERpcmVjdGlvbjogY3JlYXRlTGVhZihbXCIuL2luc3RydWN0aW9uXCJdLCAoaSA9IHt9KSA9PiBpLmp1bXAgfHwgXCItXCIpLFxuXG4gICAgLyoqXG4gICAgICogc29saWRpdHkuY3VycmVudC53aWxsQ2FsbFxuICAgICAqL1xuICAgIHdpbGxDYWxsOiBjcmVhdGVMZWFmKFtldm0uY3VycmVudC5zdGVwLmlzQ2FsbF0sIHggPT4geCksXG5cbiAgICAvKipcbiAgICAgKiBzb2xpZGl0eS5jdXJyZW50LndpbGxDcmVhdGVcbiAgICAgKi9cbiAgICB3aWxsQ3JlYXRlOiBjcmVhdGVMZWFmKFtldm0uY3VycmVudC5zdGVwLmlzQ3JlYXRlXSwgeCA9PiB4KSxcblxuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQuY2FsbHNQcmVjb21waWxlXG4gICAgICovXG4gICAgY2FsbHNQcmVjb21waWxlOiBjcmVhdGVMZWFmKFtldm0uY3VycmVudC5zdGVwLmNhbGxzUHJlY29tcGlsZV0sIHggPT4geCksXG5cbiAgICAvKipcbiAgICAgKiBzb2xpZGl0eS5jdXJyZW50LndpbGxSZXR1cm5cbiAgICAgKi9cbiAgICB3aWxsUmV0dXJuOiBjcmVhdGVMZWFmKFxuICAgICAgW2V2bS5jdXJyZW50LnN0ZXAuaXNIYWx0aW5nXSxcbiAgICAgIGlzSGFsdGluZyA9PiBpc0hhbHRpbmdcbiAgICApLFxuXG4gICAgLy9IQUNLOiBEVVBMSUNBVEUgQ09ERSBGT0xMT1dTXG4gICAgLy9UaGUgZm9sbG93aW5nIGNvZGUgZHVwbGljYXRlcyBzb21lIHNlbGVjdG9ycyBpbiBhc3QuXG4gICAgLy9UaGlzIGV4aXN0cyB0byBzdXBwb3IgdGhlIHNvbGlkaXR5LmN1cnJlbnQuY29udHJhY3RDYWxsIHdvcmthcm91bmQgYmVsb3cuXG4gICAgLy9UaGlzIHNob3VsZCBiZSBjbGVhbmVkIHVwIGxhdGVyLlxuXG4gICAgLyoqXG4gICAgICogc29saWRpdHkuY3VycmVudC5wb2ludGVyXG4gICAgICogSEFDSyBkdXBsaWNhdGVzIGFzdC5jdXJyZW50LnBvaW50ZXJcbiAgICAgKi9cbiAgICBwb2ludGVyOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiLi9zb3VyY2VcIiwgXCIuL3NvdXJjZVJhbmdlXCJdLFxuXG4gICAgICAoeyBhc3QgfSwgcmFuZ2UpID0+IGZpbmRSYW5nZShhc3QsIHJhbmdlLnN0YXJ0LCByYW5nZS5sZW5ndGgpXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQubm9kZVxuICAgICAqIEhBQ0sgZHVwbGljYXRlcyBhc3QuY3VycmVudC5ub2RlXG4gICAgICovXG4gICAgbm9kZTogY3JlYXRlTGVhZihcbiAgICAgIFtcIi4vc291cmNlXCIsIFwiLi9wb2ludGVyXCJdLFxuICAgICAgKHsgYXN0IH0sIHBvaW50ZXIpID0+XG4gICAgICAgIHBvaW50ZXIgPyBqc29ucG9pbnRlci5nZXQoYXN0LCBwb2ludGVyKSA6IGpzb25wb2ludGVyLmdldChhc3QsIFwiXCIpXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIHNvbGlkaXR5LmN1cnJlbnQuaXNDb250cmFjdENhbGxcbiAgICAgKiBIQUNLIFdPUktBUk9VTkQgKG9ubHkgYXBwbGllcyB0byBzb2xjIHZlcnNpb24gPDAuNS4xKVxuICAgICAqIHRoaXMgc2VsZWN0b3IgZXhpc3RzIHRvIHdvcmsgYXJvdW5kIGEgcHJvYmxlbSBpbiBzb2xjXG4gICAgICogaXQgYXR0ZW1wdHMgdG8gZGV0ZWN0IHdoZXRoZXIgdGhlIGN1cnJlbnQgbm9kZSBpcyBhIGNvbnRyYWN0IG1ldGhvZCBjYWxsXG4gICAgICogKG9yIGxpYnJhcnkgbWV0aG9kIGNhbGwpXG4gICAgICogaXQgd2lsbCBub3Qgc3VjY2Vzc2Z1bGx5IGRldGVjdCB0aGlzIGlmIHRoZSBtZXRob2Qgd2FzIGZpcnN0IHBsYWNlZCBpbiBhXG4gICAgICogZnVuY3Rpb24gdmFyaWFibGUsIG9ubHkgaWYgaXQgaXMgYmVpbmcgY2FsbGVkIGRpcmVjdGx5XG4gICAgICovXG4gICAgaXNDb250cmFjdENhbGw6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIuL25vZGVcIl0sXG4gICAgICBub2RlID0+XG4gICAgICAgIG5vZGUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBub2RlLm5vZGVUeXBlID09PSBcIkZ1bmN0aW9uQ2FsbFwiICYmXG4gICAgICAgIG5vZGUuZXhwcmVzc2lvbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIG5vZGUuZXhwcmVzc2lvbi5ub2RlVHlwZSA9PT0gXCJNZW1iZXJBY2Nlc3NcIiAmJlxuICAgICAgICBub2RlLmV4cHJlc3Npb24uZXhwcmVzc2lvbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIChUcnVmZmxlRGVjb2RlVXRpbHMuRGVmaW5pdGlvbi5pc0NvbnRyYWN0KG5vZGUuZXhwcmVzc2lvbi5leHByZXNzaW9uKSB8fFxuICAgICAgICAgIFRydWZmbGVEZWNvZGVVdGlscy5EZWZpbml0aW9uLmlzQ29udHJhY3RUeXBlKFxuICAgICAgICAgICAgbm9kZS5leHByZXNzaW9uLmV4cHJlc3Npb25cbiAgICAgICAgICApKVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBzb2xpZGl0eS5jdXJyZW50Lm5lZWRzRnVuY3Rpb25EZXB0aFdvcmthcm91bmRcbiAgICAgKiBIQUNLXG4gICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgc29saWRpdHkgdmVyc2lvbiB1c2VkIGZvciB0aGUgY29udHJhY3QgYWJvdXQgdG8gYmVcbiAgICAgKiBjYWxsZWQgd2FzIDwwLjUuMSwgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gdXNlIHRoZSBhYm92ZSB3b3JrYXJvdW5kXG4gICAgICogT25seSBjYWxsIHRoaXMgaWYgdGhlIGN1cnJlbnQgc3RlcCBpcyBhIGNhbGwgb3IgY3JlYXRlIVxuICAgICAqL1xuICAgIG5lZWRzRnVuY3Rpb25EZXB0aFdvcmthcm91bmQ6IGNyZWF0ZUxlYWYoXG4gICAgICBbZXZtLmN1cnJlbnQuc3RlcC5jYWxsQ29udGV4dF0sXG4gICAgICBjb250ZXh0ID0+XG4gICAgICAgIGNvbnRleHQuY29tcGlsZXIgIT09IHVuZGVmaW5lZCAmJiAvL3dvdWxkIGJlIHVuZGVmaW5lZCBmb3IgZS5nLiBhIHByZWNvbXBpbGVcbiAgICAgICAgY29udGV4dC5jb21waWxlci5uYW1lID09PSBcInNvbGNcIiAmJlxuICAgICAgICBzZW12ZXIuc2F0aXNmaWVzKGNvbnRleHQuY29tcGlsZXIudmVyc2lvbiwgXCI8MC41LjFcIilcbiAgICApXG4gIH1cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBzb2xpZGl0eTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvc29saWRpdHkvc2VsZWN0b3JzL2luZGV4LmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOmV2bTpzZWxlY3RvcnNcIik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3JUcmVlLCBjcmVhdGVMZWFmIH0gZnJvbSBcInJlc2VsZWN0LXRyZWVcIjtcbmltcG9ydCBsZXZlbnNodGVpbiBmcm9tIFwiZmFzdC1sZXZlbnNodGVpblwiO1xuXG5pbXBvcnQgdHJhY2UgZnJvbSBcImxpYi90cmFjZS9zZWxlY3RvcnNcIjtcblxuaW1wb3J0IHsgaXNDYWxsTW5lbW9uaWMgfSBmcm9tIFwibGliL2hlbHBlcnNcIjtcblxuZnVuY3Rpb24gZmluZENvbnRleHQoeyBhZGRyZXNzLCBiaW5hcnkgfSwgaW5zdGFuY2VzLCBzZWFyY2gsIGNvbnRleHRzKSB7XG4gIGxldCByZWNvcmQ7XG4gIGlmIChhZGRyZXNzKSB7XG4gICAgcmVjb3JkID0gaW5zdGFuY2VzW2FkZHJlc3NdO1xuICAgIGlmICghcmVjb3JkKSB7XG4gICAgICByZXR1cm4geyBhZGRyZXNzIH07XG4gICAgfVxuICAgIGJpbmFyeSA9IHJlY29yZC5iaW5hcnk7XG4gIH0gZWxzZSB7XG4gICAgcmVjb3JkID0gc2VhcmNoKGJpbmFyeSk7XG4gIH1cblxuICBsZXQgY29udGV4dCA9IGNvbnRleHRzWyhyZWNvcmQgfHwge30pLmNvbnRleHRdO1xuXG4gIHJldHVybiB7XG4gICAgLi4uY29udGV4dCxcbiAgICBiaW5hcnlcbiAgfTtcbn1cblxuLyoqXG4gKiBjcmVhdGUgRVZNLWxldmVsIHNlbGVjdG9ycyBmb3IgYSBnaXZlbiB0cmFjZSBzdGVwIHNlbGVjdG9yXG4gKiBtYXkgc3BlY2lmeSBhZGRpdGlvbmFsIHNlbGVjdG9ycyB0byBpbmNsdWRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVN0ZXBTZWxlY3RvcnMoc3RlcCwgc3RhdGUgPSBudWxsKSB7XG4gIGxldCBiYXNlID0ge1xuICAgIC8qKlxuICAgICAqIC50cmFjZVxuICAgICAqXG4gICAgICogdHJhY2Ugc3RlcCBpbmZvIHJlbGF0ZWQgdG8gb3BlcmF0aW9uXG4gICAgICovXG4gICAgdHJhY2U6IGNyZWF0ZUxlYWYoW3N0ZXBdLCAoeyBnYXNDb3N0LCBvcCwgcGMgfSkgPT4gKHsgZ2FzQ29zdCwgb3AsIHBjIH0pKSxcblxuICAgIC8qKlxuICAgICAqIC5wcm9ncmFtQ291bnRlclxuICAgICAqL1xuICAgIHByb2dyYW1Db3VudGVyOiBjcmVhdGVMZWFmKFtcIi4vdHJhY2VcIl0sIHN0ZXAgPT4gc3RlcC5wYyksXG5cbiAgICAvKipcbiAgICAgKiAuaXNKdW1wXG4gICAgICovXG4gICAgaXNKdW1wOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiLi90cmFjZVwiXSxcbiAgICAgIHN0ZXAgPT4gc3RlcC5vcCAhPSBcIkpVTVBERVNUXCIgJiYgc3RlcC5vcC5pbmRleE9mKFwiSlVNUFwiKSA9PSAwXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIC5pc0NhbGxcbiAgICAgKlxuICAgICAqIHdoZXRoZXIgdGhlIG9wY29kZSB3aWxsIHN3aXRjaCB0byBhbm90aGVyIGNhbGxpbmcgY29udGV4dFxuICAgICAqL1xuICAgIGlzQ2FsbDogY3JlYXRlTGVhZihbXCIuL3RyYWNlXCJdLCBzdGVwID0+IGlzQ2FsbE1uZW1vbmljKHN0ZXAub3ApKSxcblxuICAgIC8qKlxuICAgICAqIC5pc0NyZWF0ZVxuICAgICAqL1xuICAgIGlzQ3JlYXRlOiBjcmVhdGVMZWFmKFtcIi4vdHJhY2VcIl0sIHN0ZXAgPT4gc3RlcC5vcCA9PSBcIkNSRUFURVwiKSxcblxuICAgIC8qKlxuICAgICAqIC5pc0hhbHRpbmdcbiAgICAgKlxuICAgICAqIHdoZXRoZXIgdGhlIGluc3RydWN0aW9uIGhhbHRzIG9yIHJldHVybnMgZnJvbSBhIGNhbGxpbmcgY29udGV4dFxuICAgICAqL1xuICAgIGlzSGFsdGluZzogY3JlYXRlTGVhZihcbiAgICAgIFtcIi4vdHJhY2VcIl0sXG4gICAgICBzdGVwID0+IHN0ZXAub3AgPT0gXCJTVE9QXCIgfHwgc3RlcC5vcCA9PSBcIlJFVFVSTlwiXG4gICAgKVxuICB9O1xuXG4gIGlmIChzdGF0ZSkge1xuICAgIGNvbnN0IGlzUmVsYXRpdmUgPSBwYXRoID0+XG4gICAgICB0eXBlb2YgcGF0aCA9PSBcInN0cmluZ1wiICYmXG4gICAgICAocGF0aC5zdGFydHNXaXRoKFwiLi9cIikgfHwgcGF0aC5zdGFydHNXaXRoKFwiLi4vXCIpKTtcblxuICAgIGlmIChpc1JlbGF0aXZlKHN0YXRlKSkge1xuICAgICAgc3RhdGUgPSBgLi4vJHtzdGF0ZX1gO1xuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24oYmFzZSwge1xuICAgICAgLyoqXG4gICAgICAgKiAuY2FsbEFkZHJlc3NcbiAgICAgICAqXG4gICAgICAgKiBhZGRyZXNzIHRyYW5zZmVycmVkIHRvIGJ5IGNhbGwgb3BlcmF0aW9uXG4gICAgICAgKi9cbiAgICAgIGNhbGxBZGRyZXNzOiBjcmVhdGVMZWFmKFxuICAgICAgICBbXCIuL2lzQ2FsbFwiLCBcIi4vdHJhY2VcIiwgc3RhdGVdLFxuXG4gICAgICAgIChtYXRjaGVzLCBzdGVwLCB7IHN0YWNrIH0pID0+IHtcbiAgICAgICAgICBpZiAoIW1hdGNoZXMpIHJldHVybiBudWxsO1xuXG4gICAgICAgICAgbGV0IGFkZHJlc3MgPSBzdGFja1tzdGFjay5sZW5ndGggLSAyXTtcbiAgICAgICAgICBhZGRyZXNzID0gXCIweFwiICsgYWRkcmVzcy5zdWJzdHJpbmcoMjQpO1xuICAgICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgICAgICB9XG4gICAgICApLFxuXG4gICAgICAvKipcbiAgICAgICAqIC5jcmVhdGVCaW5hcnlcbiAgICAgICAqXG4gICAgICAgKiBiaW5hcnkgY29kZSB0byBleGVjdXRlIHZpYSBjcmVhdGUgb3BlcmF0aW9uXG4gICAgICAgKi9cbiAgICAgIGNyZWF0ZUJpbmFyeTogY3JlYXRlTGVhZihcbiAgICAgICAgW1wiLi9pc0NyZWF0ZVwiLCBcIi4vdHJhY2VcIiwgc3RhdGVdLFxuXG4gICAgICAgIChtYXRjaGVzLCBzdGVwLCB7IHN0YWNrLCBtZW1vcnkgfSkgPT4ge1xuICAgICAgICAgIGlmICghbWF0Y2hlcykgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICAvLyBHZXQgdGhlIGNvZGUgdGhhdCdzIGdvaW5nIHRvIGJlIGNyZWF0ZWQgZnJvbSBtZW1vcnkuXG4gICAgICAgICAgLy8gTm90ZSB3ZSBtdWx0aXBseSBieSAyIGJlY2F1c2UgdGhlc2Ugb2Zmc2V0cyBhcmUgaW4gYnl0ZXMuXG4gICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gcGFyc2VJbnQoc3RhY2tbc3RhY2subGVuZ3RoIC0gMl0sIDE2KSAqIDI7XG4gICAgICAgICAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQoc3RhY2tbc3RhY2subGVuZ3RoIC0gM10sIDE2KSAqIDI7XG5cbiAgICAgICAgICByZXR1cm4gXCIweFwiICsgbWVtb3J5LmpvaW4oXCJcIikuc3Vic3RyaW5nKG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgKSxcblxuICAgICAgLyoqXG4gICAgICAgKiAuY2FsbENvbnRleHRcbiAgICAgICAqXG4gICAgICAgKiBjb250ZXh0IGZvciB3aGF0IHdlJ3JlIGFib3V0IHRvIGNhbGwgaW50byAob3IgY3JlYXRlKVxuICAgICAgICovXG4gICAgICBjYWxsQ29udGV4dDogY3JlYXRlTGVhZihcbiAgICAgICAgW1xuICAgICAgICAgIFwiLi9jYWxsQWRkcmVzc1wiLFxuICAgICAgICAgIFwiLi9jcmVhdGVCaW5hcnlcIixcbiAgICAgICAgICBcIi9pbmZvL2luc3RhbmNlc1wiLFxuICAgICAgICAgIFwiL2luZm8vYmluYXJpZXMvc2VhcmNoXCIsXG4gICAgICAgICAgXCIvaW5mby9jb250ZXh0c1wiXG4gICAgICAgIF0sXG4gICAgICAgIChhZGRyZXNzLCBiaW5hcnksIGluc3RhbmNlcywgc2VhcmNoLCBjb250ZXh0cykgPT5cbiAgICAgICAgICBmaW5kQ29udGV4dCh7IGFkZHJlc3MsIGJpbmFyeSB9LCBpbnN0YW5jZXMsIHNlYXJjaCwgY29udGV4dHMpXG4gICAgICApLFxuXG4gICAgICAvKipcbiAgICAgICAqIC5jYWxsc1ByZWNvbXBpbGVcbiAgICAgICAqXG4gICAgICAgKiBpcyB0aGUgY2FsbCBhZGRyZXNzIHRvIGEgcHJlY29tcGlsZWQgY29udHJhY3Q/XG4gICAgICAgKiBIQUNLXG4gICAgICAgKi9cbiAgICAgIGNhbGxzUHJlY29tcGlsZTogY3JlYXRlTGVhZihcbiAgICAgICAgW1wiLi9jYWxsQWRkcmVzc1wiLCBcIi9pbmZvL2NvbnRleHRzXCIsIFwiL2luZm8vaW5zdGFuY2VzXCJdLFxuXG4gICAgICAgIChhZGRyZXNzLCBjb250ZXh0cywgaW5zdGFuY2VzKSA9PiB7XG4gICAgICAgICAgaWYgKCFhZGRyZXNzKSByZXR1cm4gbnVsbDtcblxuICAgICAgICAgIGxldCB7IGNvbnRleHQgfSA9IGluc3RhbmNlc1thZGRyZXNzXSB8fCB7fTtcbiAgICAgICAgICBsZXQgeyBiaW5hcnkgfSA9IGNvbnRleHRzW2NvbnRleHRdIHx8IHt9O1xuICAgICAgICAgIHJldHVybiAhYmluYXJ5O1xuICAgICAgICB9XG4gICAgICApXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gYmFzZTtcbn1cblxuY29uc3QgZXZtID0gY3JlYXRlU2VsZWN0b3JUcmVlKHtcbiAgLyoqXG4gICAqIGV2bS5zdGF0ZVxuICAgKi9cbiAgc3RhdGU6IHN0YXRlID0+IHN0YXRlLmV2bSxcblxuICAvKipcbiAgICogZXZtLmluZm9cbiAgICovXG4gIGluZm86IHtcbiAgICAvKipcbiAgICAgKiBldm0uaW5mby5jb250ZXh0c1xuICAgICAqL1xuICAgIGNvbnRleHRzOiBjcmVhdGVMZWFmKFtcIi9zdGF0ZVwiXSwgc3RhdGUgPT4gc3RhdGUuaW5mby5jb250ZXh0cy5ieUNvbnRleHQpLFxuXG4gICAgLyoqXG4gICAgICogZXZtLmluZm8uaW5zdGFuY2VzXG4gICAgICovXG4gICAgaW5zdGFuY2VzOiBjcmVhdGVMZWFmKFtcIi9zdGF0ZVwiXSwgc3RhdGUgPT4gc3RhdGUuaW5mby5pbnN0YW5jZXMuYnlBZGRyZXNzKSxcblxuICAgIC8qKlxuICAgICAqIGV2bS5pbmZvLmJpbmFyaWVzXG4gICAgICovXG4gICAgYmluYXJpZXM6IHtcbiAgICAgIF86IGNyZWF0ZUxlYWYoW1wiL3N0YXRlXCJdLCBzdGF0ZSA9PiBzdGF0ZS5pbmZvLmNvbnRleHRzLmJ5QmluYXJ5KSxcblxuICAgICAgLyoqXG4gICAgICAgKiBldm0uaW5mby5iaW5hcmllcy5zZWFyY2hcbiAgICAgICAqXG4gICAgICAgKiByZXR1cm5zIGZ1bmN0aW9uIChiaW5hcnkpID0+IGNvbnRleHRcbiAgICAgICAqL1xuICAgICAgc2VhcmNoOiBjcmVhdGVMZWFmKFtcIi4vX1wiXSwgYmluYXJpZXMgPT4gYmluYXJ5ID0+IHtcbiAgICAgICAgLy8gc2VhcmNoIGZvciBhIGdpdmVuIGJpbmFyeSBiYXNlZCBvbiBsZXZlbnNodGVpbiBkaXN0YW5jZXMgdG9cbiAgICAgICAgLy8gZXhpc3RpbmcgKGtub3duKSBjb250ZXh0IGJpbmFyaWVzLlxuICAgICAgICAvL1xuICAgICAgICAvLyBsZXZlbnNodGVpbiBkaXN0YW5jZSBpcyB0aGUgbnVtYmVyIG9mIHRleHR1YWwgbW9kaWZpY2F0aW9uc1xuICAgICAgICAvLyAoaW5zZXJ0LCBjaGFuZ2UsIGRlbGV0ZSkgcmVxdWlyZWQgdG8gY29udmVydCBzdHJpbmcgYSB0byBiXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGZpbHRlciBieSBhIHBlcmNlbnRhZ2UgdGhyZXNob2xkXG4gICAgICAgIGNvbnN0IHRocmVzaG9sZCA9IDAuMjU7XG5cbiAgICAgICAgLy8gc2tpcCBsZXZlbnNodGVpbiBjaGVjayBmb3IgdW5kZWZpbmVkIGJpbmFyaWVzXG4gICAgICAgIGlmICghYmluYXJ5IHx8IGJpbmFyeSA9PSBcIjB4MFwiKSB7XG4gICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IE9iamVjdC5lbnRyaWVzKGJpbmFyaWVzKVxuICAgICAgICAgIC5tYXAoKFtrbm93bkJpbmFyeSwgeyBjb250ZXh0IH1dKSA9PiAoe1xuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIGRpc3RhbmNlOiBsZXZlbnNodGVpbi5nZXQoa25vd25CaW5hcnksIGJpbmFyeSlcbiAgICAgICAgICB9KSlcbiAgICAgICAgICAuZmlsdGVyKCh7IGRpc3RhbmNlIH0pID0+IGRpc3RhbmNlIDw9IGJpbmFyeS5sZW5ndGggKiB0aHJlc2hvbGQpXG4gICAgICAgICAgLnNvcnQoKHsgZGlzdGFuY2U6IGEgfSwgeyBkaXN0YW5jZTogYiB9KSA9PiBhIC0gYik7XG5cbiAgICAgICAgaWYgKHJlc3VsdHNbMF0pIHtcbiAgICAgICAgICBjb25zdCB7IGNvbnRleHQgfSA9IHJlc3VsdHNbMF07XG4gICAgICAgICAgcmV0dXJuIHsgY29udGV4dCB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfSlcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIGV2bS5jdXJyZW50XG4gICAqL1xuICBjdXJyZW50OiB7XG4gICAgLyoqXG4gICAgICogZXZtLmN1cnJlbnQuY2FsbHN0YWNrXG4gICAgICovXG4gICAgY2FsbHN0YWNrOiBzdGF0ZSA9PiBzdGF0ZS5ldm0ucHJvYy5jYWxsc3RhY2ssXG5cbiAgICAvKipcbiAgICAgKiBldm0uY3VycmVudC5jYWxsXG4gICAgICovXG4gICAgY2FsbDogY3JlYXRlTGVhZihcbiAgICAgIFtcIi4vY2FsbHN0YWNrXCJdLFxuXG4gICAgICBzdGFjayA9PiAoc3RhY2subGVuZ3RoID8gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gOiB7fSlcbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogZXZtLmN1cnJlbnQuY3JlYXRpb25EZXB0aFxuICAgICAqIGhvdyBtYW55IGNyZWF0aW9uIGNhbGxzIGFyZSBjdXJyZW50bHkgb24gdGhlIGNhbGwgc3RhY2s/XG4gICAgICovXG4gICAgY3JlYXRpb25EZXB0aDogY3JlYXRlTGVhZihcbiAgICAgIFtcIi4vY2FsbHN0YWNrXCJdLFxuXG4gICAgICBzdGFjayA9PiBzdGFjay5maWx0ZXIoY2FsbCA9PiBjYWxsLmFkZHJlc3MgPT09IHVuZGVmaW5lZCkubGVuZ3RoXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIGV2bS5jdXJyZW50LmNvbnRleHRcbiAgICAgKi9cbiAgICBjb250ZXh0OiBjcmVhdGVMZWFmKFxuICAgICAgW1wiLi9jYWxsXCIsIFwiL2luZm8vaW5zdGFuY2VzXCIsIFwiL2luZm8vYmluYXJpZXMvc2VhcmNoXCIsIFwiL2luZm8vY29udGV4dHNcIl0sXG4gICAgICBmaW5kQ29udGV4dFxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBldm0uY3VycmVudC5zdGF0ZVxuICAgICAqXG4gICAgICogZXZtIHN0YXRlIGluZm86IGFzIG9mIGxhc3Qgb3BlcmF0aW9uLCBiZWZvcmUgb3AgZGVmaW5lZCBpbiBzdGVwXG4gICAgICovXG4gICAgc3RhdGU6IE9iamVjdC5hc3NpZ24oXG4gICAgICB7fSxcbiAgICAgIC4uLltcImRlcHRoXCIsIFwiZXJyb3JcIiwgXCJnYXNcIiwgXCJtZW1vcnlcIiwgXCJzdGFja1wiLCBcInN0b3JhZ2VcIl0ubWFwKHBhcmFtID0+ICh7XG4gICAgICAgIFtwYXJhbV06IGNyZWF0ZUxlYWYoW3RyYWNlLnN0ZXBdLCBzdGVwID0+IHN0ZXBbcGFyYW1dKVxuICAgICAgfSkpXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIGV2bS5jdXJyZW50LnN0ZXBcbiAgICAgKi9cbiAgICBzdGVwOiBjcmVhdGVTdGVwU2VsZWN0b3JzKHRyYWNlLnN0ZXAsIFwiLi9zdGF0ZVwiKVxuICB9LFxuXG4gIC8qKlxuICAgKiBldm0ubmV4dFxuICAgKi9cbiAgbmV4dDoge1xuICAgIC8qKlxuICAgICAqIGV2bS5uZXh0LnN0YXRlXG4gICAgICpcbiAgICAgKiBldm0gc3RhdGUgYXMgYSByZXN1bHQgb2YgbmV4dCBzdGVwIG9wZXJhdGlvblxuICAgICAqL1xuICAgIHN0YXRlOiBPYmplY3QuYXNzaWduKFxuICAgICAge30sXG4gICAgICAuLi5bXCJkZXB0aFwiLCBcImVycm9yXCIsIFwiZ2FzXCIsIFwibWVtb3J5XCIsIFwic3RhY2tcIiwgXCJzdG9yYWdlXCJdLm1hcChwYXJhbSA9PiAoe1xuICAgICAgICBbcGFyYW1dOiBjcmVhdGVMZWFmKFt0cmFjZS5uZXh0XSwgc3RlcCA9PiBzdGVwW3BhcmFtXSlcbiAgICAgIH0pKVxuICAgICksXG5cbiAgICBzdGVwOiBjcmVhdGVTdGVwU2VsZWN0b3JzKHRyYWNlLm5leHQsIFwiLi9zdGF0ZVwiKVxuICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgZXZtO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9ldm0vc2VsZWN0b3JzL2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidHJ1ZmZsZS1kZWNvZGUtdXRpbHNcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJ0cnVmZmxlLWRlY29kZS11dGlsc1wiXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnQgY29uc3QgU0FWRV9TVEVQUyA9IFwiU0FWRV9TVEVQU1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHNhdmVTdGVwcyhzdGVwcykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFNBVkVfU1RFUFMsXG4gICAgc3RlcHNcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFJFQ0VJVkVfQUREUkVTU0VTID0gXCJSRUNFSVZFX0FERFJFU1NFU1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHJlY2VpdmVBZGRyZXNzZXMoYWRkcmVzc2VzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogUkVDRUlWRV9BRERSRVNTRVMsXG4gICAgYWRkcmVzc2VzXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBORVhUID0gXCJORVhUXCI7XG5leHBvcnQgZnVuY3Rpb24gbmV4dCgpIHtcbiAgcmV0dXJuIHsgdHlwZTogTkVYVCB9O1xufVxuXG5leHBvcnQgY29uc3QgVElDSyA9IFwiVElDS1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHRpY2soKSB7XG4gIHJldHVybiB7IHR5cGU6IFRJQ0sgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFRPQ0sgPSBcIlRPQ0tcIjtcbmV4cG9ydCBmdW5jdGlvbiB0b2NrKCkge1xuICByZXR1cm4geyB0eXBlOiBUT0NLIH07XG59XG5cbmV4cG9ydCBjb25zdCBFTkRfT0ZfVFJBQ0UgPSBcIkVPVFwiO1xuZXhwb3J0IGZ1bmN0aW9uIGVuZFRyYWNlKCkge1xuICByZXR1cm4geyB0eXBlOiBFTkRfT0ZfVFJBQ0UgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFJFU0VUID0gXCJUUkFDRV9SRVNFVFwiO1xuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0KCkge1xuICByZXR1cm4geyB0eXBlOiBSRVNFVCB9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi90cmFjZS9hY3Rpb25zL2luZGV4LmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnQgY29uc3QgU1RBUlQgPSBcIlNFU1NJT05fU1RBUlRcIjtcbmV4cG9ydCBmdW5jdGlvbiBzdGFydCh0eEhhc2gsIHByb3ZpZGVyKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogU1RBUlQsXG4gICAgdHhIYXNoLFxucHJvdmlkZXJcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFJFQURZID0gXCJTRVNTSU9OX1JFQURZXCI7XG5leHBvcnQgZnVuY3Rpb24gcmVhZHkoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogUkVBRFksXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBFUlJPUiA9IFwiU0VTU0lPTl9FUlJPUlwiO1xuZXhwb3J0IGZ1bmN0aW9uIGVycm9yKGVycm9yKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogRVJST1IsXG4gICAgZXJyb3JcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFJFQ09SRF9DT05UUkFDVFMgPSBcIlJFQ09SRF9DT05UUkFDVFNcIjtcbmV4cG9ydCBmdW5jdGlvbiByZWNvcmRDb250cmFjdHMoY29udGV4dHMsIHNvdXJjZXMpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBSRUNPUkRfQ09OVFJBQ1RTLFxuICAgIGNvbnRleHRzLFxuc291cmNlc1xuICB9O1xufVxuXG5leHBvcnQgY29uc3QgU0FWRV9UUkFOU0FDVElPTiA9IFwiU0FWRV9UUkFOU0FDVElPTlwiO1xuZXhwb3J0IGZ1bmN0aW9uIHNhdmVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFNBVkVfVFJBTlNBQ1RJT04sXG4gICAgdHJhbnNhY3Rpb25cbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFNBVkVfUkVDRUlQVCA9IFwiU0FWRV9SRUNFSVBUXCI7XG5leHBvcnQgZnVuY3Rpb24gc2F2ZVJlY2VpcHQocmVjZWlwdCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFNBVkVfUkVDRUlQVCxcbiAgICByZWNlaXB0XG4gIH07XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3Nlc3Npb24vYWN0aW9ucy9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImpzb24tcG9pbnRlclwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImpzb24tcG9pbnRlclwiXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6YXN0OnNlbGVjdG9yc1wiKTtcblxuaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3JUcmVlLCBjcmVhdGVMZWFmIH0gZnJvbSBcInJlc2VsZWN0LXRyZWVcIjtcbmltcG9ydCBqc29ucG9pbnRlciBmcm9tIFwianNvbi1wb2ludGVyXCI7XG5cbmltcG9ydCBzb2xpZGl0eSBmcm9tIFwibGliL3NvbGlkaXR5L3NlbGVjdG9yc1wiO1xuXG5pbXBvcnQgeyBmaW5kUmFuZ2UgfSBmcm9tIFwiLi4vbWFwXCI7XG5cblxuLyoqXG4gKiBhc3RcbiAqL1xuY29uc3QgYXN0ID0gY3JlYXRlU2VsZWN0b3JUcmVlKHtcbiAgLyoqXG4gICAqIGFzdC52aWV3c1xuICAgKi9cbiAgdmlld3M6IHtcbiAgICAvKipcbiAgICAgKiBhc3Qudmlld3Muc291cmNlc1xuICAgICAqL1xuICAgIHNvdXJjZXM6IGNyZWF0ZUxlYWYoW3NvbGlkaXR5LmluZm8uc291cmNlc10sIHNvdXJjZXMgPT4gc291cmNlcylcbiAgfSxcblxuICAvKipcbiAgICogYXN0LmN1cnJlbnRcbiAgICovXG4gIGN1cnJlbnQ6IHtcblxuICAgIC8qKlxuICAgICAqIGFzdC5jdXJyZW50LnRyZWVcbiAgICAgKlxuICAgICAqIGFzdCBmb3IgY3VycmVudCBzb3VyY2VcbiAgICAgKi9cbiAgICB0cmVlOiBjcmVhdGVMZWFmKFxuICAgICAgW3NvbGlkaXR5LmN1cnJlbnQuc291cmNlXSwgKHthc3R9KSA9PiBhc3RcbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogYXN0LmN1cnJlbnQuaW5kZXhcbiAgICAgKlxuICAgICAqIHNvdXJjZSBJRFxuICAgICAqL1xuICAgIGluZGV4OiBjcmVhdGVMZWFmKFxuICAgICAgW3NvbGlkaXR5LmN1cnJlbnQuc291cmNlXSwgKHtpZH0pID0+IGlkXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIGFzdC5jdXJyZW50LnBvaW50ZXJcbiAgICAgKlxuICAgICAqIGpzb25wb2ludGVyIGZvciBjdXJyZW50IGFzdCBub2RlXG4gICAgICovXG4gICAgcG9pbnRlcjogY3JlYXRlTGVhZihcbiAgICAgIFtcIi4vdHJlZVwiLCBzb2xpZGl0eS5jdXJyZW50LnNvdXJjZVJhbmdlXSxcblxuICAgICAgKGFzdCwgcmFuZ2UpID0+IGZpbmRSYW5nZShhc3QsIHJhbmdlLnN0YXJ0LCByYW5nZS5sZW5ndGgpXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIGFzdC5jdXJyZW50Lm5vZGVcbiAgICAgKlxuICAgICAqIGN1cnJlbnQgYXN0IG5vZGUgdG8gZXhlY3V0ZVxuICAgICAqL1xuICAgIG5vZGU6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIuL3RyZWVcIiwgXCIuL3BvaW50ZXJcIl0sIChhc3QsIHBvaW50ZXIpID0+XG4gICAgICAgIChwb2ludGVyKVxuICAgICAgICAgID8ganNvbnBvaW50ZXIuZ2V0KGFzdCwgcG9pbnRlcilcbiAgICAgICAgICA6IGpzb25wb2ludGVyLmdldChhc3QsIFwiXCIpXG4gICAgKSxcblxuICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgYXN0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9hc3Qvc2VsZWN0b3JzL2luZGV4LmpzIiwiaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3JUcmVlLCBjcmVhdGVMZWFmIH0gZnJvbSBcInJlc2VsZWN0LXRyZWVcIjtcblxubGV0IHRyYWNlID0gY3JlYXRlU2VsZWN0b3JUcmVlKHtcbiAgLyoqXG4gICAqIHRyYWNlLmluZGV4XG4gICAqXG4gICAqIGN1cnJlbnQgc3RlcCBpbmRleFxuICAgKi9cbiAgaW5kZXg6IChzdGF0ZSkgPT4gc3RhdGUudHJhY2UucHJvYy5pbmRleCxcblxuICAvKipcbiAgICogdHJhY2UuZmluaXNoZWRcbiAgICpcbiAgICogaXMgdGhlIHRyYWNlIGZpbmlzaGVkP1xuICAgKi9cbiAgZmluaXNoZWQ6IChzdGF0ZSkgPT4gc3RhdGUudHJhY2UucHJvYy5maW5pc2hlZCxcblxuICAvKipcbiAgICogdHJhY2Uuc3RlcHNcbiAgICpcbiAgICogYWxsIHRyYWNlIHN0ZXBzXG4gICAqL1xuICBzdGVwczogKHN0YXRlKSA9PiBzdGF0ZS50cmFjZS5pbmZvLnN0ZXBzLFxuXG4gIC8qKlxuICAgKiB0cmFjZS5zdGVwc1JlbWFpbmluZ1xuICAgKlxuICAgKiBudW1iZXIgb2Ygc3RlcHMgcmVtYWluaW5nIGluIHRyYWNlXG4gICAqL1xuICBzdGVwc1JlbWFpbmluZzogY3JlYXRlTGVhZihcbiAgICBbXCIuL3N0ZXBzXCIsIFwiLi9pbmRleFwiXSwgKHN0ZXBzLCBpbmRleCkgPT4gc3RlcHMubGVuZ3RoIC0gaW5kZXhcbiAgKSxcblxuICAvKipcbiAgICogdHJhY2Uuc3RlcFxuICAgKlxuICAgKiBjdXJyZW50IHRyYWNlIHN0ZXBcbiAgICovXG4gIHN0ZXA6IGNyZWF0ZUxlYWYoXG4gICAgW1wiLi9zdGVwc1wiLCBcIi4vaW5kZXhcIl0sIChzdGVwcywgaW5kZXgpID0+IHN0ZXBzW2luZGV4XVxuICApLFxuXG4gIC8qKlxuICAgKiB0cmFjZS5uZXh0XG4gICAqXG4gICAqIG5leHQgdHJhY2Ugc3RlcFxuICAgKiBIQUNLOiBpZiBhdCB0aGUgZW5kLFxuICAgKiB3ZSB3aWxsIHJldHVybiB0aGUgKnNhbWUqIHRyYWNlIHN0ZXBcbiAgICovXG4gIG5leHQ6IGNyZWF0ZUxlYWYoXG4gICAgW1wiLi9zdGVwc1wiLCBcIi4vaW5kZXhcIl0sIChzdGVwcywgaW5kZXgpID0+XG4gICAgICBpbmRleCA8IHN0ZXBzLmxlbmd0aCAtIDEgPyBzdGVwc1tpbmRleCArIDFdIDogc3RlcHNbaW5kZXhdXG4gIClcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCB0cmFjZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvdHJhY2Uvc2VsZWN0b3JzL2luZGV4LmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOmRhdGE6c2FnYXNcIik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuaW1wb3J0IHsgcHV0LCB0YWtlRXZlcnksIHNlbGVjdCwgY2FsbCB9IGZyb20gXCJyZWR1eC1zYWdhL2VmZmVjdHNcIjtcbmltcG9ydCBqc29ucG9pbnRlciBmcm9tIFwianNvbi1wb2ludGVyXCI7XG5cbmltcG9ydCB7IHByZWZpeE5hbWUsIHN0YWJsZUtlY2NhazI1NiB9IGZyb20gXCJsaWIvaGVscGVyc1wiO1xuXG5pbXBvcnQgeyBUSUNLIH0gZnJvbSBcImxpYi90cmFjZS9hY3Rpb25zXCI7XG5pbXBvcnQgKiBhcyBhY3Rpb25zIGZyb20gXCIuLi9hY3Rpb25zXCI7XG5cbmltcG9ydCBkYXRhIGZyb20gXCIuLi9zZWxlY3RvcnNcIjtcblxuaW1wb3J0ICogYXMgVHJ1ZmZsZURlY29kZVV0aWxzIGZyb20gXCJ0cnVmZmxlLWRlY29kZS11dGlsc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24qIHNjb3BlKG5vZGVJZCwgcG9pbnRlciwgcGFyZW50SWQsIHNvdXJjZUlkKSB7XG4gIHlpZWxkIHB1dChhY3Rpb25zLnNjb3BlKG5vZGVJZCwgcG9pbnRlciwgcGFyZW50SWQsIHNvdXJjZUlkKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogZGVjbGFyZShub2RlKSB7XG4gIHlpZWxkIHB1dChhY3Rpb25zLmRlY2xhcmUobm9kZSkpO1xufVxuXG5mdW5jdGlvbiogdGlja1NhZ2EoKSB7XG4gIGxldCB7IHRyZWUsIGlkOiB0cmVlSWQsIG5vZGUsIHBvaW50ZXIgfSA9IHlpZWxkIHNlbGVjdChkYXRhLnZpZXdzLmFzdCk7XG5cbiAgbGV0IGRlY29kZSA9IHlpZWxkIHNlbGVjdChkYXRhLnZpZXdzLmRlY29kZXIpO1xuICBsZXQgc2NvcGVzID0geWllbGQgc2VsZWN0KGRhdGEuaW5mby5zY29wZXMpO1xuICBsZXQgZGVmaW5pdGlvbnMgPSB5aWVsZCBzZWxlY3QoZGF0YS52aWV3cy5zY29wZXMuaW5saW5lZCk7XG4gIGxldCBjdXJyZW50QXNzaWdubWVudHMgPSB5aWVsZCBzZWxlY3QoZGF0YS5wcm9jLmFzc2lnbm1lbnRzKTtcbiAgbGV0IGN1cnJlbnREZXB0aCA9IHlpZWxkIHNlbGVjdChkYXRhLmN1cnJlbnQuZnVuY3Rpb25EZXB0aCk7XG4gIGxldCBhZGRyZXNzID0geWllbGQgc2VsZWN0KGRhdGEuY3VycmVudC5hZGRyZXNzKTsgLy9tYXkgYmUgdW5kZWZpbmVkXG4gIGxldCBkdW1teUFkZHJlc3MgPSB5aWVsZCBzZWxlY3QoZGF0YS5jdXJyZW50LmR1bW15QWRkcmVzcyk7XG5cbiAgbGV0IHN0YWNrID0geWllbGQgc2VsZWN0KGRhdGEubmV4dC5zdGF0ZS5zdGFjayk7XG4gIGlmICghc3RhY2spIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBsZXQgdG9wID0gc3RhY2subGVuZ3RoIC0gMTtcbiAgdmFyIHBhcmFtZXRlcnMsIHJldHVyblBhcmFtZXRlcnMsIGFzc2lnbm1lbnQsIGFzc2lnbm1lbnRzO1xuXG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHN0YWNrIGlzIG9ubHkgcmVhZHkgZm9yIGludGVycHJldGF0aW9uIGFmdGVyIHRoZSBsYXN0IHN0ZXAgb2YgZWFjaFxuICAvLyBzb3VyY2UgcmFuZ2VcbiAgLy9cbiAgLy8gdGhlIGRhdGEgbW9kdWxlIGFsd2F5cyBsb29rcyBhdCB0aGUgcmVzdWx0IG9mIGEgcGFydGljdWxhciBvcGNvZGVcbiAgLy8gKGkuZS4sIHRoZSBmb2xsb3dpbmcgdHJhY2Ugc3RlcCdzIHN0YWNrL21lbW9yeS9zdG9yYWdlKSwgc28gdGhpc1xuICAvLyBhc3NlcnRzIHRoYXQgdGhlIF9jdXJyZW50XyBvcGVyYXRpb24gaXMgdGhlIGZpbmFsIG9uZSBiZWZvcmVcbiAgLy8gcHJvY2VlZGluZ1xuICBpZiAoISh5aWVsZCBzZWxlY3QoZGF0YS52aWV3cy5hdExhc3RJbnN0cnVjdGlvbkZvclNvdXJjZVJhbmdlKSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2ggKG5vZGUubm9kZVR5cGUpIHtcbiAgICBjYXNlIFwiRnVuY3Rpb25EZWZpbml0aW9uXCI6XG4gICAgICBwYXJhbWV0ZXJzID0gbm9kZS5wYXJhbWV0ZXJzLnBhcmFtZXRlcnMubWFwKFxuICAgICAgICAocCwgaSkgPT4gYCR7cG9pbnRlcn0vcGFyYW1ldGVycy9wYXJhbWV0ZXJzLyR7aX1gXG4gICAgICApO1xuXG4gICAgICByZXR1cm5QYXJhbWV0ZXJzID0gbm9kZS5yZXR1cm5QYXJhbWV0ZXJzLnBhcmFtZXRlcnMubWFwKFxuICAgICAgICAocCwgaSkgPT4gYCR7cG9pbnRlcn0vcmV0dXJuUGFyYW1ldGVycy9wYXJhbWV0ZXJzLyR7aX1gXG4gICAgICApO1xuXG4gICAgICBhc3NpZ25tZW50cyA9IHtcbiAgICAgICAgYnlJZDogT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICAuLi5yZXR1cm5QYXJhbWV0ZXJzXG4gICAgICAgICAgICAuY29uY2F0KHBhcmFtZXRlcnMpXG4gICAgICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgICAgICAubWFwKHBvaW50ZXIgPT4ganNvbnBvaW50ZXIuZ2V0KHRyZWUsIHBvaW50ZXIpLmlkKVxuICAgICAgICAgICAgLy9ub3RlOiBkZXB0aCBtYXkgYmUgb2ZmIGJ5IDEgYnV0IGl0IGRvZXNuJ3QgbWF0dGVyXG4gICAgICAgICAgICAubWFwKChpZCwgaSkgPT5cbiAgICAgICAgICAgICAgbWFrZUFzc2lnbm1lbnQoXG4gICAgICAgICAgICAgICAgeyBhc3RJZDogaWQsIHN0YWNrZnJhbWU6IGN1cnJlbnREZXB0aCB9LFxuICAgICAgICAgICAgICAgIHsgc3RhY2s6IHRvcCAtIGkgfVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAubWFwKGFzc2lnbm1lbnQgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4geyBbYXNzaWdubWVudC5pZF06IGFzc2lnbm1lbnQgfTtcbiAgICAgICAgICAgICAgLy9hd2t3YXJkLCBidXQgc2VlbXMgdG8gYmUgb25seSB3YXkgdG8gcmV0dXJuIGFuIG9iamVjdCBsaXRlcmFsXG4gICAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICB9O1xuICAgICAgZGVidWcoXCJGdW5jdGlvbiBkZWZpbml0aW9uIGNhc2VcIik7XG4gICAgICBkZWJ1ZyhcImFzc2lnbm1lbnRzICVPXCIsIGFzc2lnbm1lbnRzKTtcblxuICAgICAgeWllbGQgcHV0KGFjdGlvbnMuYXNzaWduKHRyZWVJZCwgYXNzaWdubWVudHMpKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcIkNvbnRyYWN0RGVmaW5pdGlvblwiOlxuICAgICAgbGV0IHN0b3JhZ2VWYXJzID0gc2NvcGVzW25vZGUuaWRdLnZhcmlhYmxlcyB8fCBbXTtcbiAgICAgIGRlYnVnKFwic3RvcmFnZSB2YXJzICVvXCIsIHN0b3JhZ2VWYXJzKTtcblxuICAgICAgbGV0IGFsbG9jYXRpb24gPSBUcnVmZmxlRGVjb2RlVXRpbHMuQWxsb2NhdGlvbi5hbGxvY2F0ZURlY2xhcmF0aW9ucyhcbiAgICAgICAgc3RvcmFnZVZhcnMsXG4gICAgICAgIGRlZmluaXRpb25zXG4gICAgICApO1xuICAgICAgZGVidWcoXCJDb250cmFjdCBkZWZpbml0aW9uIGNhc2VcIik7XG4gICAgICBkZWJ1ZyhcImFsbG9jYXRpb24gJU9cIiwgYWxsb2NhdGlvbik7XG4gICAgICBhc3NpZ25tZW50cyA9IHsgYnlJZDoge30gfTtcbiAgICAgIGZvciAobGV0IGlkIGluIGFsbG9jYXRpb24uY2hpbGRyZW4pIHtcbiAgICAgICAgaWQgPSBOdW1iZXIoaWQpOyAvL25vdCBzdXJlIHdoeSB3ZSdyZSBnZXR0aW5nIHRoZW0gYXMgc3RyaW5ncywgYnV0Li4uXG4gICAgICAgIGxldCBpZE9iajtcbiAgICAgICAgaWYgKGFkZHJlc3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlkT2JqID0geyBhc3RJZDogaWQsIGFkZHJlc3MgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZE9iaiA9IHsgYXN0SWQ6IGlkLCBkdW1teUFkZHJlc3MgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZnVsbElkID0gc3RhYmxlS2VjY2FrMjU2KGlkT2JqKTtcbiAgICAgICAgLy93ZSBkb24ndCB1c2UgbWFrZUFzc2lnbm1lbnQgaGVyZSBhcyB3ZSBoYWQgdG8gY29tcHV0ZSB0aGUgSUQgYW55d2F5XG4gICAgICAgIGFzc2lnbm1lbnQgPSB7XG4gICAgICAgICAgLi4uaWRPYmosXG4gICAgICAgICAgaWQ6IGZ1bGxJZCxcbiAgICAgICAgICByZWY6IHtcbiAgICAgICAgICAgIC4uLigoY3VycmVudEFzc2lnbm1lbnRzLmJ5SWRbZnVsbElkXSB8fCB7fSkucmVmIHx8IHt9KSxcbiAgICAgICAgICAgIHN0b3JhZ2U6IGFsbG9jYXRpb24uY2hpbGRyZW5baWRdXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBhc3NpZ25tZW50cy5ieUlkW2Z1bGxJZF0gPSBhc3NpZ25tZW50O1xuICAgICAgfVxuICAgICAgZGVidWcoXCJhc3NpZ25tZW50cyAlT1wiLCBhc3NpZ25tZW50cyk7XG5cbiAgICAgIHlpZWxkIHB1dChhY3Rpb25zLmFzc2lnbih0cmVlSWQsIGFzc2lnbm1lbnRzKSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCI6XG4gICAgICBsZXQgdmFySWQgPSBqc29ucG9pbnRlci5nZXQodHJlZSwgcG9pbnRlcikuaWQ7XG4gICAgICBkZWJ1ZyhcIlZhcmlhYmxlIGRlY2xhcmF0aW9uIGNhc2VcIik7XG4gICAgICBkZWJ1ZyhcImN1cnJlbnREZXB0aCAlZCB2YXJJZCAlZFwiLCBjdXJyZW50RGVwdGgsIHZhcklkKTtcblxuICAgICAgLy9OT1RFOiBXZSdyZSBnb2luZyB0byBtYWtlIHRoZSBhc3NpZ25tZW50IGNvbmRpdGlvbmFsIGhlcmU7IGhlcmUncyB3aHkuXG4gICAgICAvL1RoZXJlJ3MgYSBidWcgd2hlcmUgY2FsbGluZyB0aGUgYXV0b2dlbmVyYXRlZCBhY2Nlc3NvciBmb3IgYSBwdWJsaWNcbiAgICAgIC8vY29udHJhY3QgdmFyaWFibGUgY2F1c2VzIHRoZSBkZWJ1Z2dlciB0byBzZWUgdHdvIGFkZGl0aW9uYWxcbiAgICAgIC8vZGVjbGFyYXRpb25zIGZvciB0aGF0IHZhcmlhYmxlLi4uIHdoaWNoIHRoaXMgY29kZSByZWFkcyBhcyBsb2NhbFxuICAgICAgLy92YXJpYWJsZSBkZWNsYXJhdGlvbnMuICBSYXRoZXIgdGhhbiBwcmV2ZW50IHRoaXMgYXQgdGhlIHNvdXJjZSwgd2UncmVcbiAgICAgIC8vanVzdCBnb2luZyB0byBjaGVjayBmb3IgaXQgaGVyZSwgYnkgbm90IGFkZGluZyBhIGxvY2FsIHZhcmlhYmxlIGlmIHNhaWRcbiAgICAgIC8vdmFyaWFibGUgaXMgYWxyZWFkeSBhIGNvbnRyYWN0IHZhcmlhYmxlLlxuXG4gICAgICBpZiAoXG4gICAgICAgIGN1cnJlbnRBc3NpZ25tZW50cy5ieUFzdElkW3ZhcklkXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIGN1cnJlbnRBc3NpZ25tZW50cy5ieUFzdElkW3ZhcklkXS5zb21lKFxuICAgICAgICAgIGlkID0+XG4gICAgICAgICAgICBjdXJyZW50QXNzaWdubWVudHMuYnlJZFtpZF0uYWRkcmVzcyAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBjdXJyZW50QXNzaWdubWVudHMuYnlJZFtpZF0uZHVtbXlBZGRyZXNzICE9PSB1bmRlZmluZWRcbiAgICAgICAgKVxuICAgICAgKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvL290aGVyd2lzZSwgZ28gYWhlYWQgYW5kIG1ha2UgdGhlIGFzc2lnbm1lbnRcbiAgICAgIGFzc2lnbm1lbnQgPSBtYWtlQXNzaWdubWVudChcbiAgICAgICAgeyBhc3RJZDogdmFySWQsIHN0YWNrZnJhbWU6IGN1cnJlbnREZXB0aCB9LFxuICAgICAgICB7IHN0YWNrOiB0b3AgfVxuICAgICAgKTtcbiAgICAgIGFzc2lnbm1lbnRzID0geyBieUlkOiB7IFthc3NpZ25tZW50LmlkXTogYXNzaWdubWVudCB9IH07XG4gICAgICB5aWVsZCBwdXQoYWN0aW9ucy5hc3NpZ24odHJlZUlkLCBhc3NpZ25tZW50cykpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwiSW5kZXhBY2Nlc3NcIjpcbiAgICAgIC8vIHRvIHRyYWNrIGBtYXBwaW5nYCB0eXBlcyBrbm93biBpbmRleGVzXG4gICAgICB5aWVsZCBwdXQoYWN0aW9ucy5tYXBLZXlEZWNvZGluZyh0cnVlKSk7XG5cbiAgICAgIGxldCB7XG4gICAgICAgIGJhc2VFeHByZXNzaW9uOiB7IHJlZmVyZW5jZWREZWNsYXJhdGlvbjogYmFzZURlY2xhcmF0aW9uSWQgfSxcbiAgICAgICAgaW5kZXhFeHByZXNzaW9uOiB7IGlkOiBpbmRleElkIH1cbiAgICAgIH0gPSBub2RlO1xuXG4gICAgICAvL2luZGljZXMgbmVlZCB0byBiZSBpZGVudGlmaWVkIGJ5IHN0YWNrZnJhbWVcbiAgICAgIGxldCBpbmRleElkT2JqID0geyBhc3RJZDogaW5kZXhJZCwgc3RhY2tmcmFtZTogY3VycmVudERlcHRoIH07XG4gICAgICBsZXQgZnVsbEluZGV4SWQgPSBzdGFibGVLZWNjYWsyNTYoaW5kZXhJZE9iaik7XG5cbiAgICAgIGRlYnVnKFwiSW5kZXggYWNjZXNzIGNhc2VcIik7XG5cbiAgICAgIGNvbnN0IGluZGV4QXNzaWdubWVudCA9IChjdXJyZW50QXNzaWdubWVudHMuYnlJZFtmdWxsSW5kZXhJZF0gfHwge30pLnJlZjtcbiAgICAgIGRlYnVnKFwiaW5kZXhBc3NpZ25tZW50ICVPXCIsIGluZGV4QXNzaWdubWVudCk7XG4gICAgICAvLyBIQUNLIGJlY2F1c2Ugc3RyaW5nIGxpdGVyYWwgQVNUIG5vZGVzIGFyZSBub3Qgc291cmNlbWFwcGVkIHRvIGRpcmVjdGx5XG4gICAgICAvLyB2YWx1ZSBhcHBlYXJzIHRvIGJlIGF2YWlsYWJsZSBpbiBgbm9kZS5pbmRleEV4cHJlc3Npb24uaGV4VmFsdWVgXG4gICAgICAvLyBbb2JzZXJ2ZWQgd2l0aCBzb2xjIHYwLjQuMjRdXG4gICAgICBsZXQgaW5kZXhWYWx1ZTtcbiAgICAgIGlmIChpbmRleEFzc2lnbm1lbnQpIHtcbiAgICAgICAgaW5kZXhWYWx1ZSA9IHlpZWxkIGNhbGwoZGVjb2RlLCBub2RlLmluZGV4RXhwcmVzc2lvbiwgaW5kZXhBc3NpZ25tZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIFRydWZmbGVEZWNvZGVVdGlscy5EZWZpbml0aW9uLnR5cGVDbGFzcyhub2RlLmluZGV4RXhwcmVzc2lvbikgPT1cbiAgICAgICAgXCJzdHJpbmdsaXRlcmFsXCJcbiAgICAgICkge1xuICAgICAgICBpbmRleFZhbHVlID0geWllbGQgY2FsbChkZWNvZGUsIG5vZGUuaW5kZXhFeHByZXNzaW9uLCB7XG4gICAgICAgICAgbGl0ZXJhbDogVHJ1ZmZsZURlY29kZVV0aWxzLkNvbnZlcnNpb24udG9CeXRlcyhcbiAgICAgICAgICAgIG5vZGUuaW5kZXhFeHByZXNzaW9uLmhleFZhbHVlXG4gICAgICAgICAgKVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZGVidWcoXCJpbmRleCB2YWx1ZSAlT1wiLCBpbmRleFZhbHVlKTtcbiAgICAgIGlmIChpbmRleFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgeWllbGQgcHV0KGFjdGlvbnMubWFwS2V5KGJhc2VEZWNsYXJhdGlvbklkLCBpbmRleFZhbHVlKSk7XG4gICAgICB9XG5cbiAgICAgIHlpZWxkIHB1dChhY3Rpb25zLm1hcEtleURlY29kaW5nKGZhbHNlKSk7XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcIkFzc2lnbm1lbnRcIjpcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChub2RlLnR5cGVEZXNjcmlwdGlvbnMgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBkZWJ1ZyhcImRlY29kaW5nIGV4cHJlc3Npb24gdmFsdWUgJU9cIiwgbm9kZS50eXBlRGVzY3JpcHRpb25zKTtcbiAgICAgIGxldCBsaXRlcmFsID0gc3RhY2tbdG9wXTtcblxuICAgICAgZGVidWcoXCJkZWZhdWx0IGNhc2VcIik7XG4gICAgICBkZWJ1ZyhcImN1cnJlbnREZXB0aCAlZCBub2RlLmlkICVkXCIsIGN1cnJlbnREZXB0aCwgbm9kZS5pZCk7XG4gICAgICBhc3NpZ25tZW50ID0gbWFrZUFzc2lnbm1lbnQoXG4gICAgICAgIHsgYXN0SWQ6IG5vZGUuaWQsIHN0YWNrZnJhbWU6IGN1cnJlbnREZXB0aCB9LFxuICAgICAgICB7IGxpdGVyYWwgfVxuICAgICAgKTtcbiAgICAgIGFzc2lnbm1lbnRzID0geyBieUlkOiB7IFthc3NpZ25tZW50LmlkXTogYXNzaWdubWVudCB9IH07XG4gICAgICB5aWVsZCBwdXQoYWN0aW9ucy5hc3NpZ24odHJlZUlkLCBhc3NpZ25tZW50cykpO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiByZXNldCgpIHtcbiAgeWllbGQgcHV0KGFjdGlvbnMucmVzZXQoKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogbGVhcm5BZGRyZXNzU2FnYShkdW1teUFkZHJlc3MsIGFkZHJlc3MpIHtcbiAgZGVidWcoXCJhYm91dCB0byBsZWFybiBhbiBhZGRyZXNzXCIpO1xuICB5aWVsZCBwdXQoYWN0aW9ucy5sZWFybkFkZHJlc3MoZHVtbXlBZGRyZXNzLCBhZGRyZXNzKSk7XG4gIGRlYnVnKFwiYWRkcmVzcyBsZWFybnRcIik7XG59XG5cbmZ1bmN0aW9uIG1ha2VBc3NpZ25tZW50KGlkT2JqLCByZWYpIHtcbiAgbGV0IGlkID0gc3RhYmxlS2VjY2FrMjU2KGlkT2JqKTtcbiAgcmV0dXJuIHsgLi4uaWRPYmosIGlkLCByZWYgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiBzYWdhKCkge1xuICB5aWVsZCB0YWtlRXZlcnkoVElDSywgZnVuY3Rpb24qKCkge1xuICAgIHRyeSB7XG4gICAgICB5aWVsZCogdGlja1NhZ2EoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkZWJ1ZyhcIkVSUk9SOiAlT1wiLCBlKTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBwcmVmaXhOYW1lKFwiZGF0YVwiLCBzYWdhKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvZGF0YS9zYWdhcy9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9zZXRcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvc2V0XCJcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9wcm9taXNlXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL3Byb21pc2VcIlxuLy8gbW9kdWxlIGlkID0gMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0IGNvbnN0IEJFR0lOX1NURVAgPSBcIkJFR0lOX1NURVBcIjtcbmV4cG9ydCBmdW5jdGlvbiBiZWdpblN0ZXAodHlwZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEJFR0lOX1NURVAsXG4gICAgc3RlcFR5cGU6IHR5cGVcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IEFEVkFOQ0UgPSBcIkFEVkFOQ0VcIjtcbmV4cG9ydCBmdW5jdGlvbiBhZHZhbmNlKCkge1xuICByZXR1cm4geyB0eXBlOiBBRFZBTkNFIH07XG59XG5cbmV4cG9ydCBjb25zdCBTVEVQX05FWFQgPSBcIlNURVBfTkVYVFwiO1xuZXhwb3J0IGZ1bmN0aW9uIHN0ZXBOZXh0KCkge1xuICByZXR1cm4geyB0eXBlOiBTVEVQX05FWFQgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFNURVBfT1ZFUiA9IFwiU1RFUF9PVkVSXCI7XG5leHBvcnQgZnVuY3Rpb24gc3RlcE92ZXIoKSB7XG4gIHJldHVybiB7IHR5cGU6IFNURVBfT1ZFUiB9O1xufVxuXG5leHBvcnQgY29uc3QgU1RFUF9JTlRPID0gXCJTVEVQX0lOVE9cIjtcbmV4cG9ydCBmdW5jdGlvbiBzdGVwSW50bygpIHtcbiAgcmV0dXJuIHsgdHlwZTogU1RFUF9JTlRPIH07XG59XG5cbmV4cG9ydCBjb25zdCBTVEVQX09VVCA9IFwiU1RFUF9PVVRcIjtcbmV4cG9ydCBmdW5jdGlvbiBzdGVwT3V0KCkge1xuICByZXR1cm4geyB0eXBlOiBTVEVQX09VVCB9O1xufVxuXG5leHBvcnQgY29uc3QgUkVTRVQgPSBcIlJFU0VUXCI7XG5leHBvcnQgZnVuY3Rpb24gcmVzZXQoKSB7XG4gIHJldHVybiB7IHR5cGU6IFJFU0VUIH07XG59XG5cbmV4cG9ydCBjb25zdCBJTlRFUlJVUFQgPSBcIklOVEVSUlVQVFwiO1xuZXhwb3J0IGZ1bmN0aW9uIGludGVycnVwdCgpIHtcbiAgcmV0dXJuIHsgdHlwZTogSU5URVJSVVBUIH07XG59XG5cbmV4cG9ydCBjb25zdCBDT05USU5VRSA9IFwiQ09OVElOVUVcIjtcbmV4cG9ydCBmdW5jdGlvbiBjb250aW51ZVVudGlsQnJlYWtwb2ludCgpIHtcbiAgLy9cImNvbnRpbnVlXCIgaXMgbm90IGEgbGVnYWwgbmFtZVxuICByZXR1cm4geyB0eXBlOiBDT05USU5VRSB9O1xufVxuXG5leHBvcnQgY29uc3QgQUREX0JSRUFLUE9JTlQgPSBcIkFERF9CUkVBS1BPSU5UXCI7XG5leHBvcnQgZnVuY3Rpb24gYWRkQnJlYWtwb2ludChicmVha3BvaW50KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQUREX0JSRUFLUE9JTlQsXG4gICAgYnJlYWtwb2ludFxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgUkVNT1ZFX0JSRUFLUE9JTlQgPSBcIlJFTU9WRV9CUkVBS1BPSU5UXCI7XG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQnJlYWtwb2ludChicmVha3BvaW50KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogUkVNT1ZFX0JSRUFLUE9JTlQsXG4gICAgYnJlYWtwb2ludFxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgUkVNT1ZFX0FMTF9CUkVBS1BPSU5UUyA9IFwiUkVNT1ZFX0FMTF9CUkVBS1BPSU5UU1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUFsbEJyZWFrcG9pbnRzKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFJFTU9WRV9BTExfQlJFQUtQT0lOVFNcbiAgfTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvY29udHJvbGxlci9hY3Rpb25zL2luZGV4LmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOmRhdGE6c2VsZWN0b3JzXCIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbmltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yVHJlZSwgY3JlYXRlTGVhZiB9IGZyb20gXCJyZXNlbGVjdC10cmVlXCI7XG5pbXBvcnQganNvbnBvaW50ZXIgZnJvbSBcImpzb24tcG9pbnRlclwiO1xuXG5pbXBvcnQgeyBzdGFibGVLZWNjYWsyNTYgfSBmcm9tIFwibGliL2hlbHBlcnNcIjtcblxuaW1wb3J0IGFzdCBmcm9tIFwibGliL2FzdC9zZWxlY3RvcnNcIjtcbmltcG9ydCBldm0gZnJvbSBcImxpYi9ldm0vc2VsZWN0b3JzXCI7XG5pbXBvcnQgc29saWRpdHkgZnJvbSBcImxpYi9zb2xpZGl0eS9zZWxlY3RvcnNcIjtcblxuaW1wb3J0ICogYXMgVHJ1ZmZsZURlY29kZVV0aWxzIGZyb20gXCJ0cnVmZmxlLWRlY29kZS11dGlsc1wiO1xuaW1wb3J0IHsgZm9yRXZtU3RhdGUgfSBmcm9tIFwidHJ1ZmZsZS1kZWNvZGVyXCI7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgaWRlbnRpdHkgPSB4ID0+IHg7XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRlU2VsZWN0b3JzKHsgc3RhY2ssIG1lbW9yeSwgc3RvcmFnZSB9KSB7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogLnN0YWNrXG4gICAgICovXG4gICAgc3RhY2s6IGNyZWF0ZUxlYWYoXG4gICAgICBbc3RhY2tdLFxuXG4gICAgICB3b3JkcyA9PlxuICAgICAgICAod29yZHMgfHwgW10pLm1hcCh3b3JkID0+XG4gICAgICAgICAgVHJ1ZmZsZURlY29kZVV0aWxzLkNvbnZlcnNpb24udG9CeXRlcyhcbiAgICAgICAgICAgIFRydWZmbGVEZWNvZGVVdGlscy5Db252ZXJzaW9uLnRvQk4oXG4gICAgICAgICAgICAgIHdvcmQsXG4gICAgICAgICAgICAgIFRydWZmbGVEZWNvZGVVdGlscy5FVk0uV09SRF9TSVpFXG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIC5tZW1vcnlcbiAgICAgKi9cbiAgICBtZW1vcnk6IGNyZWF0ZUxlYWYoXG4gICAgICBbbWVtb3J5XSxcblxuICAgICAgd29yZHMgPT5cbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgICAgKHdvcmRzLmpvaW4oXCJcIikubWF0Y2goLy57MSwyfS9nKSB8fCBbXSkubWFwKGJ5dGUgPT5cbiAgICAgICAgICAgIHBhcnNlSW50KGJ5dGUsIDE2KVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiAuc3RvcmFnZVxuICAgICAqL1xuICAgIHN0b3JhZ2U6IGNyZWF0ZUxlYWYoXG4gICAgICBbc3RvcmFnZV0sXG5cbiAgICAgIG1hcHBpbmcgPT5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICAuLi5PYmplY3QuZW50cmllcyhtYXBwaW5nKS5tYXAoKFthZGRyZXNzLCB3b3JkXSkgPT4gKHtcbiAgICAgICAgICAgIFtgMHgke2FkZHJlc3N9YF06IG5ldyBVaW50OEFycmF5KFxuICAgICAgICAgICAgICAod29yZC5tYXRjaCgvLnsxLDJ9L2cpIHx8IFtdKS5tYXAoYnl0ZSA9PiBwYXJzZUludChieXRlLCAxNikpXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSkpXG4gICAgICAgIClcbiAgICApXG4gIH07XG59XG5cbmNvbnN0IGRhdGEgPSBjcmVhdGVTZWxlY3RvclRyZWUoe1xuICBzdGF0ZTogc3RhdGUgPT4gc3RhdGUuZGF0YSxcblxuICAvKipcbiAgICogZGF0YS52aWV3c1xuICAgKi9cbiAgdmlld3M6IHtcbiAgICBhc3Q6IGNyZWF0ZUxlYWYoW2FzdC5jdXJyZW50XSwgdHJlZSA9PiB0cmVlKSxcblxuICAgIGF0TGFzdEluc3RydWN0aW9uRm9yU291cmNlUmFuZ2U6IGNyZWF0ZUxlYWYoXG4gICAgICBbc29saWRpdHkuY3VycmVudC5pc1NvdXJjZVJhbmdlRmluYWxdLFxuICAgICAgZmluYWwgPT4gZmluYWxcbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogZGF0YS52aWV3cy5zY29wZXNcbiAgICAgKi9cbiAgICBzY29wZXM6IHtcbiAgICAgIC8qKlxuICAgICAgICogZGF0YS52aWV3cy5zY29wZXMuaW5saW5lZFxuICAgICAgICovXG4gICAgICBpbmxpbmVkOiBjcmVhdGVMZWFmKFxuICAgICAgICBbXCIvaW5mby9zY29wZXNcIiwgc29saWRpdHkuaW5mby5zb3VyY2VzXSxcblxuICAgICAgICAoc2NvcGVzLCBzb3VyY2VzKSA9PlxuICAgICAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIC4uLk9iamVjdC5lbnRyaWVzKHNjb3BlcykubWFwKChbaWQsIGVudHJ5XSkgPT4gKHtcbiAgICAgICAgICAgICAgW2lkXToge1xuICAgICAgICAgICAgICAgIC4uLmVudHJ5LFxuXG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbjoganNvbnBvaW50ZXIuZ2V0KFxuICAgICAgICAgICAgICAgICAgc291cmNlc1tlbnRyeS5zb3VyY2VJZF0uYXN0LFxuICAgICAgICAgICAgICAgICAgZW50cnkucG9pbnRlclxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgKVxuICAgICAgKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBkYXRhLnZpZXdzLmRlY29kZXJcbiAgICAgKlxuICAgICAqIHNlbGVjdG9yIHJldHVybnMgKGFzdCBub2RlIGRlZmluaXRpb24sIGRhdGEgcmVmZXJlbmNlKSA9PiBQcm9taXNlPHZhbHVlPlxuICAgICAqL1xuICAgIGRlY29kZXI6IGNyZWF0ZUxlYWYoXG4gICAgICBbXCIvdmlld3Mvc2NvcGVzL2lubGluZWRcIiwgXCIvbmV4dC9zdGF0ZVwiLCBcIi9wcm9jL21hcHBpbmdLZXlzXCJdLFxuXG4gICAgICAoc2NvcGVzLCBzdGF0ZSwgbWFwcGluZ0tleXMpID0+IChkZWZpbml0aW9uLCByZWYpID0+XG4gICAgICAgIGZvckV2bVN0YXRlKGRlZmluaXRpb24sIHJlZiwge1xuICAgICAgICAgIHNjb3BlcyxcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICBtYXBwaW5nS2V5c1xuICAgICAgICB9KVxuICAgIClcbiAgfSxcblxuICAvKipcbiAgICogZGF0YS5pbmZvXG4gICAqL1xuICBpbmZvOiB7XG4gICAgLyoqXG4gICAgICogZGF0YS5pbmZvLnNjb3Blc1xuICAgICAqL1xuICAgIHNjb3BlczogY3JlYXRlTGVhZihbXCIvc3RhdGVcIl0sIHN0YXRlID0+IHN0YXRlLmluZm8uc2NvcGVzLmJ5SWQpXG4gIH0sXG5cbiAgLyoqXG4gICAqIGRhdGEucHJvY1xuICAgKi9cbiAgcHJvYzoge1xuICAgIC8qKlxuICAgICAqIGRhdGEucHJvYy5hc3NpZ25tZW50c1xuICAgICAqL1xuICAgIGFzc2lnbm1lbnRzOiBjcmVhdGVMZWFmKFxuICAgICAgW1wiL3N0YXRlXCJdLFxuICAgICAgc3RhdGUgPT4gc3RhdGUucHJvYy5hc3NpZ25tZW50c1xuICAgICAgLy9ub3RlOiB0aGlzIG5vIGxvbmdlciBmZXRjaGVzIGp1c3QgdGhlIGJ5SWQsIGJ1dCByYXRoZXIgdGhlIHdob2xlXG4gICAgICAvL2Fzc2lnbm1lbnRzIG9iamVjdFxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBkYXRhLnByb2MubWFwcGluZ0tleXNcbiAgICAgKlxuICAgICAqIGtub3duIGtleXMgZm9yIGVhY2ggbWFwcGluZyAoaWRlbnRpZmllZCBieSBub2RlIElEKVxuICAgICAqL1xuICAgIG1hcHBpbmdLZXlzOiBjcmVhdGVMZWFmKFtcIi9zdGF0ZVwiXSwgc3RhdGUgPT4gc3RhdGUucHJvYy5tYXBwaW5nS2V5cy5ieUlkKSxcblxuICAgIC8qKlxuICAgICAqIGRhdGEucHJvYy5kZWNvZGluZ01hcHBpbmdLZXlzXG4gICAgICpcbiAgICAgKiBudW1iZXIgb2YgbWFwcGluZyBrZXlzIHRoYXQgYXJlIHN0aWxsIGRlY29kaW5nXG4gICAgICovXG4gICAgZGVjb2RpbmdNYXBwaW5nS2V5czogY3JlYXRlTGVhZihcbiAgICAgIFtcIi9zdGF0ZVwiXSxcbiAgICAgIHN0YXRlID0+IHN0YXRlLnByb2MubWFwcGluZ0tleXMuZGVjb2RpbmdTdGFydGVkXG4gICAgKVxuICB9LFxuXG4gIC8qKlxuICAgKiBkYXRhLmN1cnJlbnRcbiAgICovXG4gIGN1cnJlbnQ6IHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIGRhdGEuY3VycmVudC5zY29wZVxuICAgICAqL1xuICAgIHNjb3BlOiB7XG4gICAgICAvKipcbiAgICAgICAqIGRhdGEuY3VycmVudC5zY29wZS5pZFxuICAgICAgICovXG4gICAgICBpZDogY3JlYXRlTGVhZihbYXN0LmN1cnJlbnQubm9kZV0sIG5vZGUgPT4gbm9kZS5pZClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZGF0YS5jdXJyZW50LnN0YXRlXG4gICAgICovXG4gICAgc3RhdGU6IGNyZWF0ZVN0YXRlU2VsZWN0b3JzKGV2bS5jdXJyZW50LnN0YXRlKSxcblxuICAgIC8qKlxuICAgICAqIGRhdGEuY3VycmVudC5mdW5jdGlvbkRlcHRoXG4gICAgICovXG5cbiAgICBmdW5jdGlvbkRlcHRoOiBjcmVhdGVMZWFmKFtzb2xpZGl0eS5jdXJyZW50LmZ1bmN0aW9uRGVwdGhdLCBpZGVudGl0eSksXG5cbiAgICAvKipcbiAgICAgKiBkYXRhLmN1cnJlbnQuYWRkcmVzc1xuICAgICAqIE5vdGU6IE1heSBiZSB1bmRlZmluZWQgKGlmIGluIGFuIGluaXRpYWxpemVyKVxuICAgICAqL1xuXG4gICAgYWRkcmVzczogY3JlYXRlTGVhZihbZXZtLmN1cnJlbnQuY2FsbF0sIGNhbGwgPT4gY2FsbC5hZGRyZXNzKSxcblxuICAgIC8qKlxuICAgICAqIGRhdGEuY3VycmVudC5kdW1teUFkZHJlc3NcbiAgICAgKi9cblxuICAgIGR1bW15QWRkcmVzczogY3JlYXRlTGVhZihbZXZtLmN1cnJlbnQuY3JlYXRpb25EZXB0aF0sIGlkZW50aXR5KSxcblxuICAgIC8qKlxuICAgICAqIGRhdGEuY3VycmVudC5pZGVudGlmaWVycyAobmFtZXNwYWNlKVxuICAgICAqL1xuICAgIGlkZW50aWZpZXJzOiB7XG4gICAgICAvKipcbiAgICAgICAqIGRhdGEuY3VycmVudC5pZGVudGlmaWVycyAoc2VsZWN0b3IpXG4gICAgICAgKlxuICAgICAgICogcmV0dXJucyBpZGVudGlmZXJzIGFuZCBjb3JyZXNwb25kaW5nIGRlZmluaXRpb24gbm9kZSBJRFxuICAgICAgICovXG4gICAgICBfOiBjcmVhdGVMZWFmKFxuICAgICAgICBbXCIvdmlld3Mvc2NvcGVzL2lubGluZWRcIiwgXCIvY3VycmVudC9zY29wZVwiXSxcblxuICAgICAgICAoc2NvcGVzLCBzY29wZSkgPT4ge1xuICAgICAgICAgIGxldCBjdXIgPSBzY29wZS5pZDtcbiAgICAgICAgICBsZXQgdmFyaWFibGVzID0ge307XG5cbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICB2YXJpYWJsZXMgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAgICB2YXJpYWJsZXMsXG4gICAgICAgICAgICAgIC4uLihzY29wZXNbY3VyXS52YXJpYWJsZXMgfHwgW10pXG4gICAgICAgICAgICAgICAgLmZpbHRlcih2ID0+IHYubmFtZSAhPT0gXCJcIikgLy9leGNsdWRlIGFub255bW91cyBvdXRwdXQgcGFyYW1zXG4gICAgICAgICAgICAgICAgLmZpbHRlcih2ID0+IHZhcmlhYmxlc1t2Lm5hbWVdID09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAubWFwKHYgPT4gKHsgW3YubmFtZV06IHYuaWQgfSkpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBjdXIgPSBzY29wZXNbY3VyXS5wYXJlbnRJZDtcbiAgICAgICAgICB9IHdoaWxlIChjdXIgIT0gbnVsbCk7XG5cbiAgICAgICAgICByZXR1cm4gdmFyaWFibGVzO1xuICAgICAgICB9XG4gICAgICApLFxuXG4gICAgICAvKipcbiAgICAgICAqIGRhdGEuY3VycmVudC5pZGVudGlmaWVycy5kZWZpbml0aW9uc1xuICAgICAgICpcbiAgICAgICAqIGN1cnJlbnQgdmFyaWFibGUgZGVmaW5pdGlvbnNcbiAgICAgICAqL1xuICAgICAgZGVmaW5pdGlvbnM6IGNyZWF0ZUxlYWYoXG4gICAgICAgIFtcIi92aWV3cy9zY29wZXMvaW5saW5lZFwiLCBcIi4vX1wiXSxcblxuICAgICAgICAoc2NvcGVzLCBpZGVudGlmaWVycykgPT5cbiAgICAgICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICAuLi5PYmplY3QuZW50cmllcyhpZGVudGlmaWVycykubWFwKChbaWRlbnRpZmllciwgaWRdKSA9PiB7XG4gICAgICAgICAgICAgIGxldCB7IGRlZmluaXRpb24gfSA9IHNjb3Blc1tpZF07XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHsgW2lkZW50aWZpZXJdOiBkZWZpbml0aW9uIH07XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIClcbiAgICAgICksXG5cbiAgICAgIC8qKlxuICAgICAgICogZGF0YS5jdXJyZW50LmlkZW50aWZpZXJzLnJlZnNcbiAgICAgICAqXG4gICAgICAgKiBjdXJyZW50IHZhcmlhYmxlcycgdmFsdWUgcmVmc1xuICAgICAgICovXG4gICAgICByZWZzOiBjcmVhdGVMZWFmKFxuICAgICAgICBbXG4gICAgICAgICAgXCIvcHJvYy9hc3NpZ25tZW50c1wiLFxuICAgICAgICAgIFwiLi9fXCIsXG4gICAgICAgICAgc29saWRpdHkuY3VycmVudC5mdW5jdGlvbkRlcHRoLCAvL2ZvciBwcnVuaW5nIHRoaW5ncyB0b28gZGVlcCBvbiBzdGFja1xuICAgICAgICAgIFwiL2N1cnJlbnQvYWRkcmVzc1wiLCAvL2ZvciBjb250cmFjdCB2YXJpYWJsZXNcbiAgICAgICAgICBcIi9jdXJyZW50L2R1bW15QWRkcmVzc1wiIC8vZm9yIGNvbnRyYWN0IHZhcnMgd2hlbiBpbiBjcmVhdGlvbiBjYWxsXG4gICAgICAgIF0sXG5cbiAgICAgICAgKGFzc2lnbm1lbnRzLCBpZGVudGlmaWVycywgY3VycmVudERlcHRoLCBhZGRyZXNzLCBkdW1teUFkZHJlc3MpID0+XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgLi4uT2JqZWN0LmVudHJpZXMoaWRlbnRpZmllcnMpLm1hcCgoW2lkZW50aWZpZXIsIGFzdElkXSkgPT4ge1xuICAgICAgICAgICAgICAvL25vdGU6IHRoaXMgbmVlZHMgdHdlYWtpbmcgZm9yIHNwZWNpYWxzIGxhdGVyXG4gICAgICAgICAgICAgIGxldCBpZDtcblxuICAgICAgICAgICAgICAvL2ZpcnN0LCBjaGVjayBpZiBpdCdzIGEgY29udHJhY3QgdmFyXG4gICAgICAgICAgICAgIGlmIChhZGRyZXNzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2hJZHMgPSAoYXNzaWdubWVudHMuYnlBc3RJZFthc3RJZF0gfHwgW10pLmZpbHRlcihcbiAgICAgICAgICAgICAgICAgIGlkSGFzaCA9PiBhc3NpZ25tZW50cy5ieUlkW2lkSGFzaF0uYWRkcmVzcyA9PT0gYWRkcmVzc1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoSWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIGlkID0gbWF0Y2hJZHNbMF07IC8vdGhlcmUgc2hvdWxkIG9ubHkgYmUgb25lIVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2hJZHMgPSAoYXNzaWdubWVudHMuYnlBc3RJZFthc3RJZF0gfHwgW10pLmZpbHRlcihcbiAgICAgICAgICAgICAgICAgIGlkSGFzaCA9PlxuICAgICAgICAgICAgICAgICAgICBhc3NpZ25tZW50cy5ieUlkW2lkSGFzaF0uZHVtbXlBZGRyZXNzID09PSBkdW1teUFkZHJlc3NcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaElkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICBpZCA9IG1hdGNoSWRzWzBdOyAvL2FnYWluLCB0aGVyZSBzaG91bGQgb25seSBiZSBvbmUhXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy9pZiBub3QgY29udHJhY3QsIGl0J3MgbG9jYWwsIHNvIGZpbmQgdGhlIGlubmVybW9zdFxuICAgICAgICAgICAgICAvLyhidXQgbm90IGJleW9uZCBjdXJyZW50IGRlcHRoKVxuICAgICAgICAgICAgICBpZiAoaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaEZyYW1lcyA9IChhc3NpZ25tZW50cy5ieUFzdElkW2FzdElkXSB8fCBbXSlcbiAgICAgICAgICAgICAgICAgIC5tYXAoaWQgPT4gYXNzaWdubWVudHMuYnlJZFtpZF0uc3RhY2tmcmFtZSlcbiAgICAgICAgICAgICAgICAgIC5maWx0ZXIoc3RhY2tmcmFtZSA9PiBzdGFja2ZyYW1lICE9PSB1bmRlZmluZWQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoRnJhbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIC8vdGhpcyBjaGVjayBpc24ndCAqcmVhbGx5KlxuICAgICAgICAgICAgICAgICAgLy9uZWNlc3NhcnksIGJ1dCBtYXkgYXMgd2VsbCBwcmV2ZW50IHN0dXBpZCBzdHVmZlxuICAgICAgICAgICAgICAgICAgbGV0IG1heE1hdGNoID0gTWF0aC5taW4oXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnREZXB0aCxcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoLi4ubWF0Y2hGcmFtZXMpXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgaWQgPSBzdGFibGVLZWNjYWsyNTYoeyBhc3RJZCwgc3RhY2tmcmFtZTogbWF4TWF0Y2ggfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy9pZiB3ZSBzdGlsbCBkaWRuJ3QgZmluZCBpdCwgb2ggd2VsbFxuXG4gICAgICAgICAgICAgIGxldCB7IHJlZiB9ID0gYXNzaWdubWVudHMuYnlJZFtpZF0gfHwge307XG4gICAgICAgICAgICAgIGlmICghcmVmKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgW2lkZW50aWZpZXJdOiByZWZcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgKSxcblxuICAgICAgLyoqXG4gICAgICAgKiBkYXRhLmN1cnJlbnQuaWRlbnRpZmllcnMuZGVjb2RlZFxuICAgICAgICpcbiAgICAgICAqIFJldHVybnMgYW4gb2JqZWN0IHdpdGggdmFsdWVzIGFzIFByb21pc2VzXG4gICAgICAgKi9cbiAgICAgIGRlY29kZWQ6IGNyZWF0ZUxlYWYoXG4gICAgICAgIFtcIi92aWV3cy9kZWNvZGVyXCIsIFwiLi9kZWZpbml0aW9uc1wiLCBcIi4vcmVmc1wiXSxcblxuICAgICAgICBhc3luYyAoZGVjb2RlLCBkZWZpbml0aW9ucywgcmVmcykgPT4ge1xuICAgICAgICAgIGNvbnN0IGtleWVkUHJvbWlzZXMgPSBPYmplY3QuZW50cmllcyhyZWZzKS5tYXAoXG4gICAgICAgICAgICBhc3luYyAoW2lkZW50aWZpZXIsIHJlZl0pID0+ICh7XG4gICAgICAgICAgICAgIFtpZGVudGlmaWVyXTogYXdhaXQgZGVjb2RlKGRlZmluaXRpb25zW2lkZW50aWZpZXJdLCByZWYpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3Qga2V5ZWRSZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoa2V5ZWRQcm9taXNlcyk7XG4gICAgICAgICAgcmV0dXJuIFRydWZmbGVEZWNvZGVVdGlscy5Db252ZXJzaW9uLmNsZWFuTWFwcGluZ3MoXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCAuLi5rZXllZFJlc3VsdHMpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgKSxcblxuICAgICAgLyoqXG4gICAgICAgKiBkYXRhLmN1cnJlbnQuaWRlbnRpZmllcnMubmF0aXZlXG4gICAgICAgKlxuICAgICAgICogUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB2YWx1ZXMgYXMgUHJvbWlzZXNcbiAgICAgICAqL1xuICAgICAgbmF0aXZlOiBjcmVhdGVMZWFmKFtcIi4vZGVjb2RlZFwiXSwgYXN5bmMgZGVjb2RlZCA9PiB7XG4gICAgICAgIHJldHVybiBUcnVmZmxlRGVjb2RlVXRpbHMuQ29udmVyc2lvbi5jbGVhbkJOcyhhd2FpdCBkZWNvZGVkKTtcbiAgICAgIH0pXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBkYXRhLm5leHRcbiAgICovXG4gIG5leHQ6IHtcbiAgICAvKipcbiAgICAgKiBkYXRhLm5leHQuc3RhdGVcbiAgICAgKi9cbiAgICBzdGF0ZTogY3JlYXRlU3RhdGVTZWxlY3RvcnMoZXZtLm5leHQuc3RhdGUpXG4gIH1cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBkYXRhO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9kYXRhL3NlbGVjdG9ycy9pbmRleC5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qva2V5c1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qva2V5c1wiXG4vLyBtb2R1bGUgaWQgPSAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L3ZhbHVlc1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvdmFsdWVzXCJcbi8vIG1vZHVsZSBpZCA9IDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjphc3Q6bWFwXCIpO1xuXG5pbXBvcnQgSW50ZXJ2YWxUcmVlIGZyb20gXCJub2RlLWludGVydmFsLXRyZWVcIjtcblxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRSYW5nZShub2RlKSB7XG4gIC8vIHNyYzogXCI8c3RhcnQ+OjxsZW5ndGg+OjxfPlwiXG4gIC8vIHJldHVybnMgW3N0YXJ0LCBlbmRdXG4gIGxldCBbc3RhcnQsIGxlbmd0aF0gPSBub2RlLnNyY1xuICAgIC5zcGxpdChcIjpcIilcbiAgICAuc2xpY2UoMCwgMilcbiAgICAubWFwKCAoaSkgPT4gcGFyc2VJbnQoaSkgKTtcblxuICByZXR1cm4gW3N0YXJ0LCBzdGFydCArIGxlbmd0aF07XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlTm9kZXMobm9kZSwgcG9pbnRlciA9IFwiXCIpIHtcbiAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIHJldHVybiBbXS5jb25jYXQoXG4gICAgICAuLi5ub2RlLm1hcCggKHN1YiwgaSkgPT4gcmFuZ2VOb2RlcyhzdWIsIGAke3BvaW50ZXJ9LyR7aX1gKSApXG4gICAgKTtcbiAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgbGV0IHJlc3VsdHMgPSBbXTtcblxuICAgIGlmIChub2RlLnNyYykge1xuICAgICAgcmVzdWx0cy5wdXNoKHtwb2ludGVyLCByYW5nZTogZ2V0UmFuZ2Uobm9kZSl9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cy5jb25jYXQoXG4gICAgICAuLi5PYmplY3Qua2V5cyhub2RlKS5tYXAoXG4gICAgICAgIChrZXkpID0+IHJhbmdlTm9kZXMobm9kZVtrZXldLCBgJHtwb2ludGVyfS8ke2tleX1gKVxuICAgICAgKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRSYW5nZShub2RlLCBzb3VyY2VTdGFydCwgc291cmNlTGVuZ3RoKSB7XG4gIGxldCByYW5nZXMgPSByYW5nZU5vZGVzKG5vZGUpO1xuICBsZXQgdHJlZSA9IG5ldyBJbnRlcnZhbFRyZWUoKTtcblxuICByYW5nZXMuZm9yRWFjaCggKHtyYW5nZSwgcG9pbnRlcn0pID0+IHtcbiAgICBsZXQgW3N0YXJ0LCBlbmRdID0gcmFuZ2U7XG5cbiAgICB0cmVlLmluc2VydChzdGFydCwgZW5kLCB7cmFuZ2UsIHBvaW50ZXJ9KTtcbiAgfSk7XG5cbiAgbGV0IHNvdXJjZUVuZCA9IHNvdXJjZVN0YXJ0ICsgc291cmNlTGVuZ3RoO1xuXG4gIGxldCBvdmVybGFwcGluZyA9IHRyZWUuc2VhcmNoKHNvdXJjZVN0YXJ0LCBzb3VyY2VFbmQpO1xuXG4gIC8vIGZpbmQgbm9kZXMgdGhhdCBmdWxseSBjb250YWluIHJlcXVlc3RlZCByYW5nZSxcbiAgLy8gcmV0dXJuIGxvbmdlc3QgcG9pbnRlclxuICByZXR1cm4gb3ZlcmxhcHBpbmdcbiAgICAuZmlsdGVyKCAoe3JhbmdlfSkgPT4gc291cmNlU3RhcnQgPj0gcmFuZ2VbMF0gJiYgc291cmNlRW5kIDw9IHJhbmdlWzFdIClcbiAgICAubWFwKCAoe3BvaW50ZXJ9KSA9PiBwb2ludGVyIClcbiAgICAucmVkdWNlKCAoYSwgYikgPT4gYS5sZW5ndGggPiBiLmxlbmd0aCA/IGEgOiBiLCBcIlwiICk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2FzdC9tYXAuanMiLCJleHBvcnQgY29uc3QgU0NPUEUgPSBcIlNDT1BFXCI7XG5leHBvcnQgZnVuY3Rpb24gc2NvcGUoaWQsIHBvaW50ZXIsIHBhcmVudElkLCBzb3VyY2VJZCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFNDT1BFLFxuICAgIGlkLFxuICAgIHBvaW50ZXIsXG4gICAgcGFyZW50SWQsXG4gICAgc291cmNlSWRcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IERFQ0xBUkUgPSBcIkRFQ0xBUkVfVkFSSUFCTEVcIjtcbmV4cG9ydCBmdW5jdGlvbiBkZWNsYXJlKG5vZGUpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBERUNMQVJFLFxuICAgIG5vZGVcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IEFTU0lHTiA9IFwiQVNTSUdOXCI7XG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKGNvbnRleHQsIGFzc2lnbm1lbnRzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQVNTSUdOLFxuICAgIGNvbnRleHQsXG4gICAgYXNzaWdubWVudHNcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IE1BUF9LRVkgPSBcIk1BUF9LRVlcIjtcbmV4cG9ydCBmdW5jdGlvbiBtYXBLZXkoaWQsIGtleSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IE1BUF9LRVksXG4gICAgaWQsXG4gICAga2V5XG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBNQVBfS0VZX0RFQ09ESU5HID0gXCJNQVBfS0VZX0RFQ09ESU5HXCI7XG5leHBvcnQgZnVuY3Rpb24gbWFwS2V5RGVjb2Rpbmcoc3RhcnRlZCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IE1BUF9LRVlfREVDT0RJTkcsXG4gICAgc3RhcnRlZFxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgUkVTRVQgPSBcIkRBVEFfUkVTRVRcIjtcbmV4cG9ydCBmdW5jdGlvbiByZXNldCgpIHtcbiAgcmV0dXJuIHsgdHlwZTogUkVTRVQgfTtcbn1cblxuZXhwb3J0IGNvbnN0IExFQVJOX0FERFJFU1MgPSBcIkxFQVJOX0FERFJFU1NcIjtcbmV4cG9ydCBmdW5jdGlvbiBsZWFybkFkZHJlc3MoZHVtbXlBZGRyZXNzLCBhZGRyZXNzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogTEVBUk5fQUREUkVTUyxcbiAgICBkdW1teUFkZHJlc3MsXG4gICAgYWRkcmVzc1xuICB9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9kYXRhL2FjdGlvbnMvaW5kZXguanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6dHJhY2U6c2FnYXNcIik7XG5cbmltcG9ydCB7IHRha2UsIHRha2VFdmVyeSwgcHV0LCBzZWxlY3QgfSBmcm9tIFwicmVkdXgtc2FnYS9lZmZlY3RzXCI7XG5pbXBvcnQgeyBwcmVmaXhOYW1lLCBpc0NhbGxNbmVtb25pYyB9IGZyb20gXCJsaWIvaGVscGVyc1wiO1xuXG5pbXBvcnQgKiBhcyBhY3Rpb25zIGZyb20gXCIuLi9hY3Rpb25zXCI7XG5cbmltcG9ydCB0cmFjZSBmcm9tIFwiLi4vc2VsZWN0b3JzXCI7XG5cbmZ1bmN0aW9uKiB3YWl0Rm9yVHJhY2UoKSB7XG4gIGxldCB7IHN0ZXBzIH0gPSB5aWVsZCB0YWtlKGFjdGlvbnMuU0FWRV9TVEVQUyk7XG5cbiAgbGV0IGFkZHJlc3NlcyA9IFtcbiAgICAuLi5uZXcgU2V0KFxuICAgICAgc3RlcHNcbiAgICAgICAgLmZpbHRlcigoeyBvcCB9KSA9PiBpc0NhbGxNbmVtb25pYyhvcCkpXG4gICAgICAgIC5tYXAoKHsgc3RhY2sgfSkgPT4gXCIweFwiICsgc3RhY2tbc3RhY2subGVuZ3RoIC0gMl0uc3Vic3RyaW5nKDI0KSlcbiAgICApXG4gIF07XG5cbiAgeWllbGQgcHV0KGFjdGlvbnMucmVjZWl2ZUFkZHJlc3NlcyhhZGRyZXNzZXMpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiBhZHZhbmNlKCkge1xuICB5aWVsZCBwdXQoYWN0aW9ucy5uZXh0KCkpO1xuXG4gIGRlYnVnKFwiVE9DSyB0byB0YWtlXCIpO1xuICB5aWVsZCB0YWtlKFthY3Rpb25zLlRPQ0ssIGFjdGlvbnMuRU5EX09GX1RSQUNFXSk7XG4gIGRlYnVnKFwiVE9DSyB0YWtlblwiKTtcbn1cblxuZnVuY3Rpb24qIG5leHQoKSB7XG4gIGxldCByZW1haW5pbmcgPSB5aWVsZCBzZWxlY3QodHJhY2Uuc3RlcHNSZW1haW5pbmcpO1xuICBkZWJ1ZyhcInJlbWFpbmluZzogJW9cIiwgcmVtYWluaW5nKTtcbiAgbGV0IHN0ZXBzID0geWllbGQgc2VsZWN0KHRyYWNlLnN0ZXBzKTtcbiAgZGVidWcoXCJ0b3RhbCBzdGVwczogJW9cIiwgc3RlcHMubGVuZ3RoKTtcblxuICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgIGRlYnVnKFwicHV0dGluZyBUSUNLXCIpO1xuICAgIC8vIHVwZGF0ZXMgc3RhdGUgZm9yIGN1cnJlbnQgc3RlcFxuICAgIHlpZWxkIHB1dChhY3Rpb25zLnRpY2soKSk7XG4gICAgZGVidWcoXCJwdXQgVElDS1wiKTtcblxuICAgIHJlbWFpbmluZy0tOyAvLyBsb2NhbCB1cGRhdGUsIGp1c3QgZm9yIGNvbnZlbmllbmNlXG4gIH1cblxuICBpZiAocmVtYWluaW5nKSB7XG4gICAgZGVidWcoXCJwdXR0aW5nIFRPQ0tcIik7XG4gICAgLy8gdXBkYXRlcyBzdGVwIHRvIG5leHQgc3RlcCBpbiB0cmFjZVxuICAgIHlpZWxkIHB1dChhY3Rpb25zLnRvY2soKSk7XG4gICAgZGVidWcoXCJwdXQgVE9DS1wiKTtcbiAgfSBlbHNlIHtcbiAgICBkZWJ1ZyhcInB1dHRpbmcgRU5EX09GX1RSQUNFXCIpO1xuICAgIHlpZWxkIHB1dChhY3Rpb25zLmVuZFRyYWNlKCkpO1xuICAgIGRlYnVnKFwicHV0IEVORF9PRl9UUkFDRVwiKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24qIHByb2Nlc3NUcmFjZSh0cmFjZSkge1xuICB5aWVsZCBwdXQoYWN0aW9ucy5zYXZlU3RlcHModHJhY2UpKTtcblxuICBsZXQgeyBhZGRyZXNzZXMgfSA9IHlpZWxkIHRha2UoYWN0aW9ucy5SRUNFSVZFX0FERFJFU1NFUyk7XG4gIGRlYnVnKFwicmVjZWl2ZWQgYWRkcmVzc2VzXCIpO1xuXG4gIHJldHVybiBhZGRyZXNzZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogcmVzZXQoKSB7XG4gIHlpZWxkIHB1dChhY3Rpb25zLnJlc2V0KCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24qIHNhZ2EoKSB7XG4gIC8vIHdhaXQgZm9yIHRyYWNlIHRvIGJlIGRlZmluZWRcbiAgeWllbGQqIHdhaXRGb3JUcmFjZSgpO1xuXG4gIHlpZWxkIHRha2VFdmVyeShhY3Rpb25zLk5FWFQsIG5leHQpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBwcmVmaXhOYW1lKFwidHJhY2VcIiwgc2FnYSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3RyYWNlL3NhZ2FzL2luZGV4LmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOmV2bTpzYWdhc1wiKTtcblxuaW1wb3J0IHsgY2FsbCwgcHV0LCB0YWtlLCBzZWxlY3QgfSBmcm9tIFwicmVkdXgtc2FnYS9lZmZlY3RzXCI7XG5pbXBvcnQgeyBwcmVmaXhOYW1lLCBrZWNjYWsyNTYgfSBmcm9tIFwibGliL2hlbHBlcnNcIjtcbmltcG9ydCAqIGFzIFRydWZmbGVEZWNvZGVVdGlscyBmcm9tIFwidHJ1ZmZsZS1kZWNvZGUtdXRpbHNcIjtcblxuaW1wb3J0IHsgVElDSyB9IGZyb20gXCJsaWIvdHJhY2UvYWN0aW9uc1wiO1xuaW1wb3J0ICogYXMgYWN0aW9ucyBmcm9tIFwiLi4vYWN0aW9uc1wiO1xuXG5pbXBvcnQgZXZtIGZyb20gXCIuLi9zZWxlY3RvcnNcIjtcblxuaW1wb3J0ICogYXMgZGF0YSBmcm9tIFwibGliL2RhdGEvc2FnYXNcIjtcblxuLyoqXG4gKiBBZGRzIEVWTSBieXRlY29kZSBjb250ZXh0XG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBJRCAoMHgtcHJlZml4ZWQga2VjY2FrIG9mIGJpbmFyeSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uKiBhZGRDb250ZXh0KGNvbnRyYWN0TmFtZSwgeyBhZGRyZXNzLCBiaW5hcnkgfSwgY29tcGlsZXIpIHtcbiAgY29uc3QgcmF3ID0gYmluYXJ5IHx8IGFkZHJlc3M7XG4gIGNvbnN0IGNvbnRleHQgPSBrZWNjYWsyNTYocmF3KTtcblxuICB5aWVsZCBwdXQoYWN0aW9ucy5hZGRDb250ZXh0KGNvbnRyYWN0TmFtZSwgcmF3LCBjb21waWxlcikpO1xuXG4gIGlmIChiaW5hcnkpIHtcbiAgICB5aWVsZCBwdXQoYWN0aW9ucy5hZGRCaW5hcnkoY29udGV4dCwgYmluYXJ5KSk7XG4gIH1cblxuICByZXR1cm4gY29udGV4dDtcbn1cblxuLyoqXG4gKiBBZGRzIGtub3duIGRlcGxveWVkIGluc3RhbmNlIG9mIGJpbmFyeSBhdCBhZGRyZXNzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJpbmFyeSAtIG1heSBiZSB1bmRlZmluZWQgKGUuZy4gcHJlY29tcGlsZXMpXG4gKiBAcmV0dXJuIHtzdHJpbmd9IElEICgweC1wcmVmaXhlZCBrZWNjYWsgb2YgYmluYXJ5KVxuICovXG5leHBvcnQgZnVuY3Rpb24qIGFkZEluc3RhbmNlKGFkZHJlc3MsIGJpbmFyeSkge1xuICBsZXQgc2VhcmNoID0geWllbGQgc2VsZWN0KGV2bS5pbmZvLmJpbmFyaWVzLnNlYXJjaCk7XG4gIGxldCB7IGNvbnRleHQgfSA9IHNlYXJjaChiaW5hcnkpO1xuXG4gIC8vIGluIGNhc2UgYmluYXJ5IGlzIHVua25vd24sIGFkZCBjb250ZXh0IGZvciBhZGRyZXNzXG4gIGlmICghY29udGV4dCkge1xuICAgIGNvbnRleHQgPSB5aWVsZCogYWRkQ29udGV4dCh1bmRlZmluZWQsIHsgYWRkcmVzcyB9LCB1bmRlZmluZWQpO1xuICB9XG5cbiAgeWllbGQgcHV0KGFjdGlvbnMuYWRkSW5zdGFuY2UoYWRkcmVzcywgY29udGV4dCwgYmluYXJ5KSk7XG5cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogYmVnaW4oeyBhZGRyZXNzLCBiaW5hcnkgfSkge1xuICBpZiAoYWRkcmVzcykge1xuICAgIHlpZWxkIHB1dChhY3Rpb25zLmNhbGwoYWRkcmVzcykpO1xuICB9IGVsc2Uge1xuICAgIHlpZWxkIHB1dChhY3Rpb25zLmNyZWF0ZShiaW5hcnkpKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24qIGNhbGxzdGFja1NhZ2EoKSB7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgeWllbGQgdGFrZShUSUNLKTtcblxuICAgIGlmICh5aWVsZCBzZWxlY3QoZXZtLmN1cnJlbnQuc3RlcC5pc0NhbGwpKSB7XG4gICAgICBkZWJ1ZyhcImdvdCBjYWxsXCIpO1xuICAgICAgbGV0IGFkZHJlc3MgPSB5aWVsZCBzZWxlY3QoZXZtLmN1cnJlbnQuc3RlcC5jYWxsQWRkcmVzcyk7XG5cbiAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGJpbmFyeSAoZS5nLiBpbiB0aGUgY2FzZSBvZiBwcmVjb21waWxlZCBjb250cmFjdHMpLFxuICAgICAgLy8gdGhlbiB0aGVyZSB3aWxsIGJlIG5vIHRyYWNlIHN0ZXBzIGZvciB0aGUgY2FsbGVkIGNvZGUsIGFuZCBzbyB3ZVxuICAgICAgLy8gc2hvdWxkbid0IHRlbGwgdGhlIGRlYnVnZ2VyIHRoYXQgd2UncmUgZW50ZXJpbmcgYW5vdGhlciBleGVjdXRpb25cbiAgICAgIC8vIGNvbnRleHRcbiAgICAgIGlmICh5aWVsZCBzZWxlY3QoZXZtLmN1cnJlbnQuc3RlcC5jYWxsc1ByZWNvbXBpbGUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB5aWVsZCBwdXQoYWN0aW9ucy5jYWxsKGFkZHJlc3MpKTtcbiAgICB9IGVsc2UgaWYgKHlpZWxkIHNlbGVjdChldm0uY3VycmVudC5zdGVwLmlzQ3JlYXRlKSkge1xuICAgICAgZGVidWcoXCJnb3QgY3JlYXRlXCIpO1xuICAgICAgbGV0IGJpbmFyeSA9IHlpZWxkIHNlbGVjdChldm0uY3VycmVudC5zdGVwLmNyZWF0ZUJpbmFyeSk7XG5cbiAgICAgIHlpZWxkIHB1dChhY3Rpb25zLmNyZWF0ZShiaW5hcnkpKTtcbiAgICB9IGVsc2UgaWYgKHlpZWxkIHNlbGVjdChldm0uY3VycmVudC5zdGVwLmlzSGFsdGluZykpIHtcbiAgICAgIGRlYnVnKFwiZ290IHJldHVyblwiKTtcblxuICAgICAgbGV0IGNhbGxzdGFjayA9IHlpZWxkIHNlbGVjdChldm0uY3VycmVudC5jYWxsc3RhY2spO1xuXG4gICAgICAvL2lmIHRoZSBwcm9ncmFtJ3Mgbm90IGVuZGluZywgYW5kIHdlIGp1c3QgcmV0dXJuZWQgZnJvbSBhIGNvbnN0cnVjdG9yLFxuICAgICAgLy9sZWFybiB0aGUgYWRkcmVzcyBvZiB3aGF0IHdlIGp1c3QgaW5pdGlhbGl6ZWRcbiAgICAgIC8vKGRvIHRoaXMgYmVmb3JlIHdlIHB1dCB0aGUgcmV0dXJuIGFjdGlvbiB0byBhdm9pZCBvZmYtYnktb25lIGVycm9yKVxuICAgICAgaWYgKFxuICAgICAgICBjYWxsc3RhY2subGVuZ3RoID4gMSAmJlxuICAgICAgICBjYWxsc3RhY2tbY2FsbHN0YWNrLmxlbmd0aCAtIDFdLmFkZHJlc3MgPT09IHVuZGVmaW5lZFxuICAgICAgKSB7XG4gICAgICAgIGxldCBkdW1teUFkZHJlc3MgPSB5aWVsZCBzZWxlY3QoZXZtLmN1cnJlbnQuY3JlYXRpb25EZXB0aCk7XG4gICAgICAgIGRlYnVnKFwiZHVtbXlBZGRyZXNzICVkXCIsIGR1bW15QWRkcmVzcyk7XG5cbiAgICAgICAgbGV0IHN0YWNrID0geWllbGQgc2VsZWN0KGV2bS5uZXh0LnN0YXRlLnN0YWNrKTtcbiAgICAgICAgbGV0IGNyZWF0ZWRBZGRyZXNzID0gVHJ1ZmZsZURlY29kZVV0aWxzLkNvbnZlcnNpb24udG9IZXhTdHJpbmcoXG4gICAgICAgICAgVHJ1ZmZsZURlY29kZVV0aWxzLkNvbnZlcnNpb24udG9CeXRlcyhcbiAgICAgICAgICAgIFRydWZmbGVEZWNvZGVVdGlscy5Db252ZXJzaW9uLnRvQk4oXG4gICAgICAgICAgICAgIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgICBUcnVmZmxlRGVjb2RlVXRpbHMuRVZNLldPUkRfU0laRVxuICAgICAgICAgICAgKVxuICAgICAgICAgICksXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgICBkZWJ1ZyhcImNyZWF0ZWRBZGRyZXNzICVzXCIsIGNyZWF0ZWRBZGRyZXNzKTtcblxuICAgICAgICB5aWVsZCogZGF0YS5sZWFybkFkZHJlc3NTYWdhKGR1bW15QWRkcmVzcywgY3JlYXRlZEFkZHJlc3MpO1xuICAgICAgICBkZWJ1ZyhcImFkZHJlc3MgbGVhcm50XCIpO1xuICAgICAgfVxuXG4gICAgICB5aWVsZCBwdXQoYWN0aW9ucy5yZXR1cm5DYWxsKCkpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24qIHJlc2V0KCkge1xuICB5aWVsZCBwdXQoYWN0aW9ucy5yZXNldCgpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiBzYWdhKCkge1xuICB5aWVsZCBjYWxsKGNhbGxzdGFja1NhZ2EpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBwcmVmaXhOYW1lKFwiZXZtXCIsIHNhZ2EpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9ldm0vc2FnYXMvaW5kZXguanMiLCJleHBvcnQgY29uc3QgQUREX0NPTlRFWFQgPSBcIkVWTV9BRERfQ09OVEVYVFwiO1xuZXhwb3J0IGZ1bmN0aW9uIGFkZENvbnRleHQoY29udHJhY3ROYW1lLCByYXcsIGNvbXBpbGVyKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQUREX0NPTlRFWFQsXG4gICAgY29udHJhY3ROYW1lLFxuICAgIHJhdyxcbiAgICBjb21waWxlclxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgQUREX0JJTkFSWSA9IFwiRVZNX0FERF9CSU5BUllcIjtcbmV4cG9ydCBmdW5jdGlvbiBhZGRCaW5hcnkoY29udGV4dCwgYmluYXJ5KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQUREX0JJTkFSWSxcbiAgICBjb250ZXh0LFxuICAgIGJpbmFyeVxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgQUREX0lOU1RBTkNFID0gXCJFVk1fQUREX0lOU1RBTkNFXCI7XG5leHBvcnQgZnVuY3Rpb24gYWRkSW5zdGFuY2UoYWRkcmVzcywgY29udGV4dCwgYmluYXJ5KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQUREX0lOU1RBTkNFLFxuICAgIGFkZHJlc3MsXG4gICAgY29udGV4dCxcbiAgICBiaW5hcnlcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IENBTEwgPSBcIkNBTExcIjtcbmV4cG9ydCBmdW5jdGlvbiBjYWxsKGFkZHJlc3MpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBDQUxMLFxuICAgIGFkZHJlc3NcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IENSRUFURSA9IFwiQ1JFQVRFXCI7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKGJpbmFyeSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IENSRUFURSxcbiAgICBiaW5hcnlcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFJFVFVSTiA9IFwiUkVUVVJOXCI7XG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuQ2FsbCgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBSRVRVUk5cbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFJFU0VUID0gXCJFVk1fUkVTRVRcIjtcbmV4cG9ydCBmdW5jdGlvbiByZXNldCgpIHtcbiAgcmV0dXJuIHsgdHlwZTogUkVTRVQgfTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvZXZtL2FjdGlvbnMvaW5kZXguanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6c29saWRpdHk6c2FnYXNcIik7XG5cbmltcG9ydCB7IGNhbGwsIHB1dCwgdGFrZSwgc2VsZWN0IH0gZnJvbSBcInJlZHV4LXNhZ2EvZWZmZWN0c1wiO1xuaW1wb3J0IHsgcHJlZml4TmFtZSB9IGZyb20gXCJsaWIvaGVscGVyc1wiO1xuXG5pbXBvcnQgKiBhcyBhY3Rpb25zIGZyb20gXCIuLi9hY3Rpb25zXCI7XG5pbXBvcnQgeyBUSUNLIH0gZnJvbSBcImxpYi90cmFjZS9hY3Rpb25zXCI7XG5cbmltcG9ydCBzb2xpZGl0eSBmcm9tIFwiLi4vc2VsZWN0b3JzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiogYWRkU291cmNlKHNvdXJjZSwgc291cmNlUGF0aCwgYXN0KSB7XG4gIHlpZWxkIHB1dChhY3Rpb25zLmFkZFNvdXJjZShzb3VyY2UsIHNvdXJjZVBhdGgsIGFzdCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24qIGFkZFNvdXJjZU1hcChiaW5hcnksIHNvdXJjZU1hcCkge1xuICB5aWVsZCBwdXQoYWN0aW9ucy5hZGRTb3VyY2VNYXAoYmluYXJ5LCBzb3VyY2VNYXApKTtcbn1cblxuZnVuY3Rpb24qIHRpY2tTYWdhKCkge1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHlpZWxkIHRha2UoVElDSyk7XG4gICAgZGVidWcoXCJnb3QgVElDS1wiKTtcblxuICAgIHlpZWxkKiBmdW5jdGlvbkRlcHRoU2FnYSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uKiBmdW5jdGlvbkRlcHRoU2FnYSgpIHtcbiAgaWYgKHlpZWxkIHNlbGVjdChzb2xpZGl0eS5jdXJyZW50LndpbGxKdW1wKSkge1xuICAgIGxldCBqdW1wRGlyZWN0aW9uID0geWllbGQgc2VsZWN0KHNvbGlkaXR5LmN1cnJlbnQuanVtcERpcmVjdGlvbik7XG4gICAgeWllbGQgcHV0KGFjdGlvbnMuanVtcChqdW1wRGlyZWN0aW9uKSk7XG4gIH0gZWxzZSBpZiAoeWllbGQgc2VsZWN0KHNvbGlkaXR5LmN1cnJlbnQud2lsbENhbGwpKSB7XG4gICAgLy93ZSBoYXZlIHNldmVyYWwgY2FzZXMgaGVyZTpcbiAgICAvLzEuIHByZWNvbXBpbGUgLS0gKmRvbid0KiBwdXQgYW55IGp1bXBcbiAgICAvLzIuIHdvcmthcm91bmQgY2FzZSAtLSBwdXQgYSBkb3VibGUganVtcCAoc2VlIGJlbG93KVxuICAgIC8vMy4gZ2VuZXJhbCBjYXNlIC0tIHB1dCBhIHNpbmdsZSBqdW1wIGFzIGV4cGVjdGVkXG5cbiAgICBkZWJ1ZyhcImFib3V0IHRvIGNhbGxcIik7XG4gICAgaWYgKHlpZWxkIHNlbGVjdChzb2xpZGl0eS5jdXJyZW50LmNhbGxzUHJlY29tcGlsZSkpIHtcbiAgICAgIC8vY2FsbCB0byBwcmVjb21waWxlOyBkbyBub3RoaW5nXG4gICAgfSBlbHNlIGlmIChcbiAgICAgICh5aWVsZCBzZWxlY3Qoc29saWRpdHkuY3VycmVudC5uZWVkc0Z1bmN0aW9uRGVwdGhXb3JrYXJvdW5kKSkgJiZcbiAgICAgICh5aWVsZCBzZWxlY3Qoc29saWRpdHkuY3VycmVudC5pc0NvbnRyYWN0Q2FsbCkpXG4gICAgKSB7XG4gICAgICAvL2FsbCB0aGVzZSBwYXJlbnRoZXNlcyBhcmUgbmVjZXNzYXJ5XG4gICAgICAvL0hBQ0sgV09SS0FST1VORFxuICAgICAgLy9iZWNhdXNlIG9mIHRoZSBwcm9ibGVtIGluIHNvbGMgPDAuNS4xIHdoZXJlIGNvbnRyYWN0IG1ldGhvZCBjYWxsc1xuICAgICAgLy9lc3NlbnRpYWxseSByZXR1cm4gdHdpY2UsIHdlIGNvbXBlbnNhdGUgYnkgcHV0dGluZyAqdHdvKiBpbndhcmQganVtcHNcbiAgICAgIC8vZm9yIHN1Y2ggYSBjYWxsLlxuICAgICAgLy9Ob3RlIHRoYXQgdGhpcyB3b24ndCB3b3JrIGlmIHRoZSBjb250cmFjdCBtZXRob2Qgd2FzIHByZXZpb3VzbHkgcGxhY2VkXG4gICAgICAvL2luIGEgZnVuY3Rpb24gdmFyaWFibGUhICBUaG9zZSB3aWxsIGNvbnRpbnVlIHRvIHNjcmV3IHRoaW5ncyB1cCEgIEJ1dFxuICAgICAgLy9pZiBhIGNvbnRyYWN0IGNhbGwgaXMgYmVpbmcgbWFkZSBkaXJlY3RseSwgd2UgY2FuIGRldGVjdCB0aGF0LlxuICAgICAgLy9PZiBjb3Vyc2UsIGFsbCBvZiB0aGlzIHNob3VsZCB3b3JrIGZpbmUgYXMgb2Ygc29saWRpdHkgMC41LjEsIHdpdGggbm9cbiAgICAgIC8vd29ya2Fyb3VuZCBuZWNlc3Nhcnk7IHRoaXMgYnJhbmNoIHNob3VsZCBvbmx5IGdldCB0YWtlIG9uIG9sZFxuICAgICAgLy9jb250cmFjdHMuXG4gICAgICBkZWJ1ZyhcIndvcmthcm91bmQgaW52b2tlZCFcIik7XG4gICAgICB5aWVsZCBwdXQoYWN0aW9ucy5qdW1wKFwiMlwiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vYW4gb3JkaW5hcnkgY2FsbCwgbm90IHRvIGEgcHJlY29tcGlsZSAmIHdpdGggbm8gd29ya2Fyb3VuZCBuZWVkZWRcbiAgICAgIHlpZWxkIHB1dChhY3Rpb25zLmp1bXAoXCJpXCIpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoeWllbGQgc2VsZWN0KHNvbGlkaXR5LmN1cnJlbnQud2lsbENyZWF0ZSkpIHtcbiAgICAvL3RoaXMgY2FzZSwgdGhhbmtmdWxseSwgbmVlZHMgbm8gZnVydGhlciBicmVha2Rvd25cbiAgICB5aWVsZCBwdXQoYWN0aW9ucy5qdW1wKFwiaVwiKSk7XG4gIH0gZWxzZSBpZiAoeWllbGQgc2VsZWN0KHNvbGlkaXR5LmN1cnJlbnQud2lsbFJldHVybikpIHtcbiAgICB5aWVsZCBwdXQoYWN0aW9ucy5qdW1wKFwib1wiKSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uKiByZXNldCgpIHtcbiAgeWllbGQgcHV0KGFjdGlvbnMucmVzZXQoKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogc2FnYSgpIHtcbiAgeWllbGQgY2FsbCh0aWNrU2FnYSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHByZWZpeE5hbWUoXCJzb2xpZGl0eVwiLCBzYWdhKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvc29saWRpdHkvc2FnYXMvaW5kZXguanMiLCJleHBvcnQgY29uc3QgQUREX1NPVVJDRSA9IFwiU09MSURJVFlfQUREX1NPVVJDRVwiO1xuZXhwb3J0IGZ1bmN0aW9uIGFkZFNvdXJjZShzb3VyY2UsIHNvdXJjZVBhdGgsIGFzdCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IEFERF9TT1VSQ0UsXG4gICAgc291cmNlLFxuICAgIHNvdXJjZVBhdGgsXG4gICAgYXN0XG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBBRERfU09VUkNFTUFQID0gXCJTT0xJRElUWV9BRERfU09VUkNFTUFQXCI7XG5leHBvcnQgZnVuY3Rpb24gYWRkU291cmNlTWFwKGJpbmFyeSwgc291cmNlTWFwKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogQUREX1NPVVJDRU1BUCxcbiAgICBiaW5hcnksXG4gICAgc291cmNlTWFwXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBKVU1QID0gXCJKVU1QXCI7XG5leHBvcnQgZnVuY3Rpb24ganVtcChqdW1wRGlyZWN0aW9uKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogSlVNUCxcbiAgICBqdW1wRGlyZWN0aW9uXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBSRVNFVCA9IFwiU09MSURJVFlfUkVTRVRcIjtcbmV4cG9ydCBmdW5jdGlvbiByZXNldCgpIHtcbiAgcmV0dXJuIHsgdHlwZTogUkVTRVQgfTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvc29saWRpdHkvYWN0aW9ucy9pbmRleC5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpjb250cm9sbGVyOnNhZ2FzXCIpO1xuXG5pbXBvcnQgeyBjcmVhdGVTZWxlY3RvclRyZWUsIGNyZWF0ZUxlYWYgfSBmcm9tIFwicmVzZWxlY3QtdHJlZVwiO1xuXG5pbXBvcnQgZXZtIGZyb20gXCJsaWIvZXZtL3NlbGVjdG9yc1wiO1xuaW1wb3J0IHNvbGlkaXR5IGZyb20gXCJsaWIvc29saWRpdHkvc2VsZWN0b3JzXCI7XG5pbXBvcnQgYXN0IGZyb20gXCJsaWIvYXN0L3NlbGVjdG9yc1wiO1xuaW1wb3J0IHRyYWNlIGZyb20gXCJsaWIvdHJhY2Uvc2VsZWN0b3JzXCI7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgaWRlbnRpdHkgPSAoeCkgPT4geDtcblxuLyoqXG4gKiBjb250cm9sbGVyXG4gKi9cbmNvbnN0IGNvbnRyb2xsZXIgPSBjcmVhdGVTZWxlY3RvclRyZWUoe1xuXG4gIC8qKlxuICAgKiBjb250cm9sbGVyLnN0YXRlXG4gICAqL1xuICBzdGF0ZTogKChzdGF0ZSkgPT4gc3RhdGUuY29udHJvbGxlciksXG4gIC8qKlxuICAgKiBjb250cm9sbGVyLmN1cnJlbnRcbiAgICovXG4gIGN1cnJlbnQ6IHtcbiAgICAvKipcbiAgICAgKiBjb250cm9sbGVyLmN1cnJlbnQuZnVuY3Rpb25EZXB0aFxuICAgICAqL1xuICAgIGZ1bmN0aW9uRGVwdGg6IGNyZWF0ZUxlYWYoW3NvbGlkaXR5LmN1cnJlbnQuZnVuY3Rpb25EZXB0aF0sIGlkZW50aXR5KSxcblxuICAgIC8qKlxuICAgICAqIGNvbnRyb2xsZXIuY3VycmVudC5leGVjdXRpb25Db250ZXh0XG4gICAgICovXG4gICAgZXhlY3V0aW9uQ29udGV4dDogY3JlYXRlTGVhZihbZXZtLmN1cnJlbnQuY2FsbF0sIGlkZW50aXR5KSxcblxuICAgIC8qKlxuICAgICAqIGNvbnRyb2xsZXIuY3VycmVudC53aWxsSnVtcFxuICAgICAqL1xuICAgIHdpbGxKdW1wOiBjcmVhdGVMZWFmKFtldm0uY3VycmVudC5zdGVwLmlzSnVtcF0sIGlkZW50aXR5KSxcblxuICAgIC8qKlxuICAgICAqIGNvbnRyb2xsZXIuY3VycmVudC5sb2NhdGlvblxuICAgICAqL1xuICAgIGxvY2F0aW9uOiB7XG4gICAgICAvKipcbiAgICAgICAqIGNvbnRyb2xsZXIuY3VycmVudC5sb2NhdGlvbi5zb3VyY2VSYW5nZVxuICAgICAgICovXG4gICAgICBzb3VyY2VSYW5nZTogY3JlYXRlTGVhZihbc29saWRpdHkuY3VycmVudC5zb3VyY2VSYW5nZV0sIGlkZW50aXR5KSxcblxuICAgICAgLyoqXG4gICAgICAgKiBjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb24uc291cmNlXG4gICAgICAgKi9cbiAgICAgIHNvdXJjZTogY3JlYXRlTGVhZihbc29saWRpdHkuY3VycmVudC5zb3VyY2VdLCBpZGVudGl0eSksXG5cbiAgICAgIC8qKlxuICAgICAgICogY29udHJvbGxlci5jdXJyZW50LmxvY2F0aW9uLm5vZGVcbiAgICAgICAqL1xuICAgICAgbm9kZTogY3JlYXRlTGVhZihbYXN0LmN1cnJlbnQubm9kZV0sIGlkZW50aXR5KSxcblxuICAgICAgLyoqXG4gICAgICAgKiBjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb24uaXNNdWx0aWxpbmVcbiAgICAgICAqL1xuICAgICAgaXNNdWx0aWxpbmU6IGNyZWF0ZUxlYWYoW3NvbGlkaXR5LmN1cnJlbnQuaXNNdWx0aWxpbmVdLCBpZGVudGl0eSksXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBjb250cm9sbGVyLmJyZWFrcG9pbnRzXG4gICAqL1xuICBicmVha3BvaW50czogY3JlYXRlTGVhZihbXCIuL3N0YXRlXCJdLCAoc3RhdGUpID0+IHN0YXRlLmJyZWFrcG9pbnRzKSxcblxuICAvKipcbiAgICogY29udHJvbGxlci5maW5pc2hlZFxuICAgKi9cbiAgZmluaXNoZWQ6IGNyZWF0ZUxlYWYoW3RyYWNlLmZpbmlzaGVkXSwgaWRlbnRpdHkpLFxuXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgY29udHJvbGxlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvY29udHJvbGxlci9zZWxlY3RvcnMvaW5kZXguanMiLCJ2YXIgRGVidWdnZXIgPSByZXF1aXJlKFwiLi9saWIvZGVidWdnZXJcIikuZGVmYXVsdDtcblxubW9kdWxlLmV4cG9ydHMgPSBEZWJ1Z2dlcjtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9kZWJ1Z2dlci5qc1xuLy8gbW9kdWxlIGlkID0gMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gJ2RlYnVnJztcbmltcG9ydCBleHBlY3QgZnJvbSBcInRydWZmbGUtZXhwZWN0XCI7XG5cbmltcG9ydCBTZXNzaW9uIGZyb20gXCIuL3Nlc3Npb25cIjtcblxuaW1wb3J0IHsgY3JlYXRlTmVzdGVkU2VsZWN0b3IgfSBmcm9tIFwicmVzZWxlY3QtdHJlZVwiO1xuXG5pbXBvcnQgZGF0YVNlbGVjdG9yIGZyb20gXCIuL2RhdGEvc2VsZWN0b3JzXCI7XG5pbXBvcnQgYXN0U2VsZWN0b3IgZnJvbSBcIi4vYXN0L3NlbGVjdG9yc1wiO1xuaW1wb3J0IHRyYWNlU2VsZWN0b3IgZnJvbSBcIi4vdHJhY2Uvc2VsZWN0b3JzXCI7XG5pbXBvcnQgZXZtU2VsZWN0b3IgZnJvbSBcIi4vZXZtL3NlbGVjdG9yc1wiO1xuaW1wb3J0IHNvbGlkaXR5U2VsZWN0b3IgZnJvbSBcIi4vc29saWRpdHkvc2VsZWN0b3JzXCI7XG5pbXBvcnQgc2Vzc2lvblNlbGVjdG9yIGZyb20gXCIuL3Nlc3Npb24vc2VsZWN0b3JzXCI7XG5pbXBvcnQgY29udHJvbGxlclNlbGVjdG9yIGZyb20gXCIuL2NvbnRyb2xsZXIvc2VsZWN0b3JzXCI7XG5cbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlclwiKTtcblxuLyoqXG4gKiBAZXhhbXBsZVxuICogbGV0IHNlc3Npb24gPSBEZWJ1Z2dlclxuICogICAuZm9yVHgoPHR4SGFzaD4sIHtcbiAqICAgICBjb250cmFjdHM6IFs8Y29udHJhY3Qgb2JqPiwgLi4uXSxcbiAqICAgICBwcm92aWRlcjogPHByb3ZpZGVyIGluc3RhbmNlPlxuICogICB9KVxuICogICAuY29ubmVjdCgpO1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEZWJ1Z2dlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1Nlc3Npb259IHNlc3Npb24gLSBkZWJ1Z2dlciBzZXNzaW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzZXNzaW9uKSB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9zZXNzaW9uID0gc2Vzc2lvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnN0YW50aWF0ZXMgYSBEZWJ1Z2dlciBmb3IgYSBnaXZlbiB0cmFuc2FjdGlvbiBoYXNoLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHhIYXNoIC0gdHJhbnNhY3Rpb24gaGFzaCB3aXRoIGxlYWRpbmcgXCIweFwiXG4gICAqIEBwYXJhbSB7e2NvbnRyYWN0czogQXJyYXk8Q29udHJhY3Q+LCBmaWxlczogQXJyYXk8U3RyaW5nPiwgcHJvdmlkZXI6IFdlYjNQcm92aWRlcn19IG9wdGlvbnMgLVxuICAgKiBAcmV0dXJuIHtEZWJ1Z2dlcn0gaW5zdGFuY2VcbiAgICovXG4gIHN0YXRpYyBhc3luYyBmb3JUeCh0eEhhc2gsIG9wdGlvbnMgPSB7fSkge1xuICAgIGV4cGVjdC5vcHRpb25zKG9wdGlvbnMsIFtcbiAgICAgIFwiY29udHJhY3RzXCIsXG4gICAgICBcInByb3ZpZGVyXCJcbiAgICBdKTtcblxuICAgIGxldCBzZXNzaW9uID0gbmV3IFNlc3Npb24oXG4gICAgICBvcHRpb25zLmNvbnRyYWN0cywgb3B0aW9ucy5maWxlcyxcbiAgICAgIHR4SGFzaCwgb3B0aW9ucy5wcm92aWRlclxuICAgICk7XG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgc2Vzc2lvbi5yZWFkeSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyB0aGlzKHNlc3Npb24pO1xuICB9XG5cblxuICAvKipcbiAgICogQ29ubmVjdHMgdG8gdGhlIGluc3RhbnRpYXRlZCBEZWJ1Z2dlci5cbiAgICpcbiAgICogQHJldHVybiB7U2Vzc2lvbn0gc2Vzc2lvbiBpbnN0YW5jZVxuICAgKi9cbiAgY29ubmVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2Vzc2lvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvcnRlZCBzZWxlY3RvcnNcbiAgICpcbiAgICogU2VlIGluZGl2aWR1YWwgc2VsZWN0b3IgZG9jcyBmb3IgZnVsbCBsaXN0aW5nXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIERlYnVnZ2VyLnNlbGVjdG9ycy5hc3QuY3VycmVudC50cmVlXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIERlYnVnZ2VyLnNlbGVjdG9ycy5zb2xpZGl0eS5jdXJyZW50Lmluc3RydWN0aW9uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIERlYnVnZ2VyLnNlbGVjdG9ycy50cmFjZS5zdGVwc1xuICAgKi9cbiAgc3RhdGljIGdldCBzZWxlY3RvcnMoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZU5lc3RlZFNlbGVjdG9yKHtcbiAgICAgIGFzdDogYXN0U2VsZWN0b3IsXG4gICAgICBkYXRhOiBkYXRhU2VsZWN0b3IsXG4gICAgICB0cmFjZTogdHJhY2VTZWxlY3RvcixcbiAgICAgIGV2bTogZXZtU2VsZWN0b3IsXG4gICAgICBzb2xpZGl0eTogc29saWRpdHlTZWxlY3RvcixcbiAgICAgIHNlc3Npb246IHNlc3Npb25TZWxlY3RvcixcbiAgICAgIGNvbnRyb2xsZXI6IGNvbnRyb2xsZXJTZWxlY3RvcixcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENvbnRyYWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gY29udHJhY3ROYW1lIGNvbnRyYWN0IG5hbWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzb3VyY2Ugc29saWRpdHkgc291cmNlIGNvZGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzb3VyY2VQYXRoIHBhdGggdG8gc291cmNlIGZpbGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBiaW5hcnkgMHgtcHJlZml4ZWQgaGV4IHN0cmluZyB3aXRoIGNyZWF0ZSBieXRlY29kZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNvdXJjZU1hcCBzb2xpZGl0eSBzb3VyY2UgbWFwIGZvciBjcmVhdGUgYnl0ZWNvZGVcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBhc3QgQWJzdHJhY3QgU3ludGF4IFRyZWUgZnJvbSBTb2xpZGl0eVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGRlcGxveWVkQmluYXJ5IDB4LXByZWZpeGVkIGNvbXBpbGVkIGJpbmFyeSAob24gY2hhaW4pXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZGVwbG95ZWRTb3VyY2VNYXAgc29saWRpdHkgc291cmNlIG1hcCBmb3Igb24tY2hhaW4gYnl0ZWNvZGVcbiAqL1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9kZWJ1Z2dlci5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInRydWZmbGUtZXhwZWN0XCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwidHJ1ZmZsZS1leHBlY3RcIlxuLy8gbW9kdWxlIGlkID0gMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOnNlc3Npb25cIik7IC8vZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG5pbXBvcnQgY29uZmlndXJlU3RvcmUgZnJvbSBcImxpYi9zdG9yZVwiO1xuXG5pbXBvcnQgKiBhcyBjb250cm9sbGVyIGZyb20gXCJsaWIvY29udHJvbGxlci9hY3Rpb25zXCI7XG5pbXBvcnQgKiBhcyBhY3Rpb25zIGZyb20gXCIuL2FjdGlvbnNcIjtcbmltcG9ydCBkYXRhIGZyb20gXCJsaWIvZGF0YS9zZWxlY3RvcnNcIjtcblxuaW1wb3J0IHJvb3RTYWdhIGZyb20gXCIuL3NhZ2FzXCI7XG5pbXBvcnQgcmVkdWNlciBmcm9tIFwiLi9yZWR1Y2Vyc1wiO1xuXG4vKipcbiAqIERlYnVnZ2VyIFNlc3Npb25cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2Vzc2lvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PENvbnRyYWN0Pn0gY29udHJhY3RzIC0gY29udHJhY3QgZGVmaW5pdGlvbnNcbiAgICogQHBhcmFtIHtBcnJheTxTdHJpbmc+fSBmaWxlcyAtIGFycmF5IG9mIGZpbGVuYW1lcyBmb3Igc291cmNlTWFwIGluZGV4ZXNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR4SGFzaCAtIHRyYW5zYWN0aW9uIGhhc2hcbiAgICogQHBhcmFtIHtXZWIzUHJvdmlkZXJ9IHByb3ZpZGVyIC0gd2ViMyBwcm92aWRlclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IoY29udHJhY3RzLCBmaWxlcywgdHhIYXNoLCBwcm92aWRlcikge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fc3RvcmUgPSBjb25maWd1cmVTdG9yZShyZWR1Y2VyLCByb290U2FnYSk7XG5cbiAgICBsZXQgeyBjb250ZXh0cywgc291cmNlcyB9ID0gU2Vzc2lvbi5ub3JtYWxpemUoY29udHJhY3RzLCBmaWxlcyk7XG5cbiAgICAvLyByZWNvcmQgY29udHJhY3RzXG4gICAgdGhpcy5fc3RvcmUuZGlzcGF0Y2goYWN0aW9ucy5yZWNvcmRDb250cmFjdHMoY29udGV4dHMsIHNvdXJjZXMpKTtcblxuICAgIHRoaXMuX3N0b3JlLmRpc3BhdGNoKGFjdGlvbnMuc3RhcnQodHhIYXNoLCBwcm92aWRlcikpO1xuICB9XG5cbiAgcmVhZHkoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChhY2NlcHQsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5fc3RvcmUuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc2Vzc2lvbi5zdGF0dXMgPT0gXCJBQ1RJVkVcIikge1xuICAgICAgICAgIGFjY2VwdCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLnN0YXRlLnNlc3Npb24uc3RhdHVzID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICByZWplY3QodGhpcy5zdGF0ZS5zZXNzaW9uLnN0YXR1cy5lcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0IHVwIGFydGlmYWN0cyBpbnRvIFwiY29udGV4dHNcIiBhbmQgXCJzb3VyY2VzXCIsIGRpdmlkaW5nIGFydGlmYWN0XG4gICAqIGRhdGEgaW50byBhcHByb3ByaWF0ZSBidWNrZXRzLlxuICAgKlxuICAgKiBNdWx0aXBsZSBjb250cmFjdHMgY2FuIGJlIGRlZmluZWQgaW4gdGhlIHNhbWUgc291cmNlIGZpbGUsIGJ1dCBoYXZlXG4gICAqIGRpZmZlcmVudCBieXRlY29kZXMuXG4gICAqXG4gICAqIFRoaXMgaXRlcmF0ZXMgb3ZlciB0aGUgY29udHJhY3RzIGFuZCBjb2xsZWN0cyBiaW5hcmllcyBzZXBhcmF0ZWx5XG4gICAqIGZyb20gc291cmNlcywgdXNpbmcgdGhlIG9wdGlvbmFsIGBmaWxlc2AgYXJndW1lbnQgdG8gZm9yY2VcbiAgICogc291cmNlIG9yZGVyaW5nLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhdGljIG5vcm1hbGl6ZShjb250cmFjdHMsIGZpbGVzID0gbnVsbCkge1xuICAgIGxldCBzb3VyY2VzQnlQYXRoID0ge307XG4gICAgbGV0IGNvbnRleHRzID0gW107XG4gICAgbGV0IHNvdXJjZXM7XG5cbiAgICBmb3IgKGxldCBjb250cmFjdCBvZiBjb250cmFjdHMpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIGNvbnRyYWN0TmFtZSxcbiAgICAgICAgYmluYXJ5LFxuICAgICAgICBzb3VyY2VNYXAsXG4gICAgICAgIGRlcGxveWVkQmluYXJ5LFxuICAgICAgICBkZXBsb3llZFNvdXJjZU1hcCxcbiAgICAgICAgc291cmNlUGF0aCxcbiAgICAgICAgc291cmNlLFxuICAgICAgICBhc3QsXG4gICAgICAgIGNvbXBpbGVyXG4gICAgICB9ID0gY29udHJhY3Q7XG5cbiAgICAgIGRlYnVnKFwic291cmNlTWFwICVvXCIsIHNvdXJjZU1hcCk7XG4gICAgICBkZWJ1ZyhcImNvbXBpbGVyICVvXCIsIGNvbXBpbGVyKTtcblxuICAgICAgc291cmNlc0J5UGF0aFtzb3VyY2VQYXRoXSA9IHsgc291cmNlUGF0aCwgc291cmNlLCBhc3QgfTtcblxuICAgICAgaWYgKGJpbmFyeSAmJiBiaW5hcnkgIT0gXCIweFwiKSB7XG4gICAgICAgIGNvbnRleHRzLnB1c2goe1xuICAgICAgICAgIGNvbnRyYWN0TmFtZSxcbiAgICAgICAgICBiaW5hcnksXG4gICAgICAgICAgc291cmNlTWFwXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGVwbG95ZWRCaW5hcnkgJiYgZGVwbG95ZWRCaW5hcnkgIT0gXCIweFwiKSB7XG4gICAgICAgIGNvbnRleHRzLnB1c2goe1xuICAgICAgICAgIGNvbnRyYWN0TmFtZSxcbiAgICAgICAgICBiaW5hcnk6IGRlcGxveWVkQmluYXJ5LFxuICAgICAgICAgIHNvdXJjZU1hcDogZGVwbG95ZWRTb3VyY2VNYXAsXG4gICAgICAgICAgY29tcGlsZXJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFmaWxlcykge1xuICAgICAgc291cmNlcyA9IE9iamVjdC52YWx1ZXMoc291cmNlc0J5UGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNvdXJjZXMgPSBmaWxlcy5tYXAoZmlsZSA9PiBzb3VyY2VzQnlQYXRoW2ZpbGVdKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyBjb250ZXh0cywgc291cmNlcyB9O1xuICB9XG5cbiAgZ2V0IHN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9zdG9yZS5nZXRTdGF0ZSgpO1xuICB9XG5cbiAgdmlldyhzZWxlY3Rvcikge1xuICAgIHJldHVybiBzZWxlY3Rvcih0aGlzLnN0YXRlKTtcbiAgfVxuXG4gIGRpc3BhdGNoKGFjdGlvbikge1xuICAgIHRoaXMuX3N0b3JlLmRpc3BhdGNoKGFjdGlvbik7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGludGVycnVwdCgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChjb250cm9sbGVyLmludGVycnVwdCgpKTtcbiAgfVxuXG4gIGFkdmFuY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goY29udHJvbGxlci5hZHZhbmNlKCkpO1xuICB9XG5cbiAgc3RlcE5leHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goY29udHJvbGxlci5zdGVwTmV4dCgpKTtcbiAgfVxuXG4gIHN0ZXBPdmVyKCkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKGNvbnRyb2xsZXIuc3RlcE92ZXIoKSk7XG4gIH1cblxuICBzdGVwSW50bygpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChjb250cm9sbGVyLnN0ZXBJbnRvKCkpO1xuICB9XG5cbiAgc3RlcE91dCgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChjb250cm9sbGVyLnN0ZXBPdXQoKSk7XG4gIH1cblxuICByZXNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChjb250cm9sbGVyLnJlc2V0KCkpO1xuICB9XG5cbiAgY29udGludWVVbnRpbEJyZWFrcG9pbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goY29udHJvbGxlci5jb250aW51ZVVudGlsQnJlYWtwb2ludCgpKTtcbiAgfVxuXG4gIGFkZEJyZWFrcG9pbnQoYnJlYWtwb2ludCkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKGNvbnRyb2xsZXIuYWRkQnJlYWtwb2ludChicmVha3BvaW50KSk7XG4gIH1cblxuICByZW1vdmVCcmVha3BvaW50KGJyZWFrcG9pbnQpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChjb250cm9sbGVyLnJlbW92ZUJyZWFrcG9pbnQoYnJlYWtwb2ludCkpO1xuICB9XG5cbiAgcmVtb3ZlQWxsQnJlYWtwb2ludHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goY29udHJvbGxlci5yZW1vdmVBbGxCcmVha3BvaW50cygpKTtcbiAgfVxuXG4gIGFzeW5jIGRlY29kZVJlYWR5KCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGxldCBoYXZlUmVzb2x2ZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gdGhpcy5fc3RvcmUuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uRGVjb2RpbmdTdGFydGVkID0gdGhpcy52aWV3KFxuICAgICAgICAgIGRhdGEucHJvYy5kZWNvZGluZ01hcHBpbmdLZXlzXG4gICAgICAgICk7XG5cbiAgICAgICAgZGVidWcoXCJmb2xsb3dpbmcgZGVjb2Rpbmcgc3RhcnRlZDogJWRcIiwgc3Vic2NyaXB0aW9uRGVjb2RpbmdTdGFydGVkKTtcblxuICAgICAgICBpZiAoc3Vic2NyaXB0aW9uRGVjb2RpbmdTdGFydGVkIDw9IDAgJiYgIWhhdmVSZXNvbHZlZCkge1xuICAgICAgICAgIGhhdmVSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBkZWNvZGluZ1N0YXJ0ZWQgPSB0aGlzLnZpZXcoZGF0YS5wcm9jLmRlY29kaW5nTWFwcGluZ0tleXMpO1xuXG4gICAgICBkZWJ1ZyhcImluaXRpYWwgZGVjb2Rpbmcgc3RhcnRlZDogJWRcIiwgZGVjb2RpbmdTdGFydGVkKTtcblxuICAgICAgaWYgKGRlY29kaW5nU3RhcnRlZCA8PSAwKSB7XG4gICAgICAgIGhhdmVSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIHZhcmlhYmxlKG5hbWUpIHtcbiAgICBhd2FpdCB0aGlzLmRlY29kZVJlYWR5KCk7XG5cbiAgICBjb25zdCBkZWZpbml0aW9ucyA9IHRoaXMudmlldyhkYXRhLmN1cnJlbnQuaWRlbnRpZmllcnMuZGVmaW5pdGlvbnMpO1xuICAgIGNvbnN0IHJlZnMgPSB0aGlzLnZpZXcoZGF0YS5jdXJyZW50LmlkZW50aWZpZXJzLnJlZnMpO1xuXG4gICAgY29uc3QgZGVjb2RlID0gdGhpcy52aWV3KGRhdGEudmlld3MuZGVjb2Rlcik7XG4gICAgcmV0dXJuIGF3YWl0IGRlY29kZShkZWZpbml0aW9uc1tuYW1lXSwgcmVmc1tuYW1lXSk7XG4gIH1cblxuICBhc3luYyB2YXJpYWJsZXMoKSB7XG4gICAgYXdhaXQgdGhpcy5kZWNvZGVSZWFkeSgpO1xuXG4gICAgcmV0dXJuIGF3YWl0IHRoaXMudmlldyhkYXRhLmN1cnJlbnQuaWRlbnRpZmllcnMuZGVjb2RlZCk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvc2Vzc2lvbi9pbmRleC5qcyIsImlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PSBcInByb2R1Y3Rpb25cIikge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3Byb2R1Y3Rpb25cIik7XG59IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09IFwidGVzdFwiKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vdGVzdFwiKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vZGV2ZWxvcG1lbnRcIik7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3N0b3JlL2luZGV4LmpzIiwiaW1wb3J0IGNvbmZpZ3VyZVN0b3JlIGZyb20gXCIuL2NvbW1vblwiO1xuZXhwb3J0IGRlZmF1bHQgY29uZmlndXJlU3RvcmU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3N0b3JlL3Byb2R1Y3Rpb24uanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6c3RvcmU6Y29tbW9uXCIpO1xuY29uc3QgcmVkdXhEZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6cmVkdXhcIik7XG5cbmltcG9ydCB7IGNvbXBvc2UsIGNyZWF0ZVN0b3JlLCBhcHBseU1pZGRsZXdhcmUgfSBmcm9tIFwicmVkdXhcIjtcbmltcG9ydCBjcmVhdGVTYWdhTWlkZGxld2FyZSBmcm9tIFwicmVkdXgtc2FnYVwiO1xuaW1wb3J0IGNyZWF0ZUxvZ2dlciBmcm9tIFwicmVkdXgtY2xpLWxvZ2dlclwiO1xuXG5leHBvcnQgZnVuY3Rpb24gYWJicmV2aWF0ZVZhbHVlcyh2YWx1ZSwgb3B0aW9ucyA9IHt9LCBkZXB0aCA9IDApIHtcbiAgb3B0aW9ucy5zdHJpbmdMaW1pdCA9IG9wdGlvbnMuc3RyaW5nTGltaXQgfHwgNjY7XG4gIG9wdGlvbnMuYXJyYXlMaW1pdCA9IG9wdGlvbnMuYXJyYXlMaW1pdCB8fCA4O1xuICBvcHRpb25zLnJlY3Vyc2VMaW1pdCA9IG9wdGlvbnMucmVjdXJzZUxpbWl0IHx8IDQ7XG5cbiAgaWYgKGRlcHRoID4gb3B0aW9ucy5yZWN1cnNlTGltaXQpIHtcbiAgICByZXR1cm4gXCIuLi5cIjtcbiAgfVxuXG4gIGNvbnN0IHJlY3Vyc2UgPSAoY2hpbGQpID0+IGFiYnJldmlhdGVWYWx1ZXMoY2hpbGQsIG9wdGlvbnMsIGRlcHRoICsgMSk7XG5cbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICBpZiAodmFsdWUubGVuZ3RoID4gb3B0aW9ucy5hcnJheUxpbWl0KSB7XG4gICAgICB2YWx1ZSA9IFtcbiAgICAgICAgLi4udmFsdWUuc2xpY2UoMCwgb3B0aW9ucy5hcnJheUxpbWl0IC8gMiksXG4gICAgICAgIFwiLi4uXCIsXG4gICAgICAgIC4uLnZhbHVlLnNsaWNlKHZhbHVlLmxlbmd0aCAtIG9wdGlvbnMuYXJyYXlMaW1pdCAvIDIgKyAxKVxuICAgICAgXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWUubWFwKHJlY3Vyc2UpO1xuXG4gIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSxcbiAgICAgIC4uLk9iamVjdC5lbnRyaWVzKHZhbHVlKS5tYXAoXG4gICAgICAgIChbaywgdl0pID0+ICh7IFtyZWN1cnNlKGspXTogcmVjdXJzZSh2KSB9KVxuICAgICAgKVxuICAgICk7XG5cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUubGVuZ3RoID4gb3B0aW9ucy5zdHJpbmdMaW1pdCkge1xuICAgIGxldCBpbm5lciA9IFwiLi4uXCI7XG4gICAgbGV0IGV4dHJhY3RBbW91bnQgPSAob3B0aW9ucy5zdHJpbmdMaW1pdCAtIGlubmVyLmxlbmd0aCkgLyAyO1xuICAgIGxldCBsZWFkaW5nID0gdmFsdWUuc2xpY2UoMCwgTWF0aC5jZWlsKGV4dHJhY3RBbW91bnQpKTtcbiAgICBsZXQgdHJhaWxpbmcgPSB2YWx1ZS5zbGljZSh2YWx1ZS5sZW5ndGggLSBNYXRoLmZsb29yKGV4dHJhY3RBbW91bnQpKTtcbiAgICByZXR1cm4gYCR7bGVhZGluZ30ke2lubmVyfSR7dHJhaWxpbmd9YDtcblxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb25maWd1cmVTdG9yZSAocmVkdWNlciwgc2FnYSwgaW5pdGlhbFN0YXRlLCBjb21wb3NlRW5oYW5jZXJzKSB7XG4gIGNvbnN0IHNhZ2FNaWRkbGV3YXJlID0gY3JlYXRlU2FnYU1pZGRsZXdhcmUoKTtcblxuICBpZiAoIWNvbXBvc2VFbmhhbmNlcnMpIHtcbiAgICBjb21wb3NlRW5oYW5jZXJzID0gY29tcG9zZTtcbiAgfVxuXG4gIGNvbnN0IGxvZ2dlck1pZGRsZXdhcmUgPSBjcmVhdGVMb2dnZXIoe1xuICAgIGxvZzogcmVkdXhEZWJ1ZyxcbiAgICBzdGF0ZVRyYW5zZm9ybWVyOiAoc3RhdGUpID0+IGFiYnJldmlhdGVWYWx1ZXMoc3RhdGUsIHtcbiAgICAgIGFycmF5TGltaXQ6IDQsXG4gICAgICByZWN1cnNlTGltaXQ6IDNcbiAgICB9KSxcbiAgICBhY3Rpb25UcmFuc2Zvcm1lcjogYWJicmV2aWF0ZVZhbHVlcyxcbiAgfSk7XG5cbiAgbGV0IHN0b3JlID0gY3JlYXRlU3RvcmUoXG4gICAgcmVkdWNlciwgaW5pdGlhbFN0YXRlLFxuXG4gICAgY29tcG9zZUVuaGFuY2VycyhcbiAgICAgIGFwcGx5TWlkZGxld2FyZShcbiAgICAgICAgc2FnYU1pZGRsZXdhcmUsXG4gICAgICAgIGxvZ2dlck1pZGRsZXdhcmVcbiAgICAgIClcbiAgICApXG4gICk7XG5cbiAgc2FnYU1pZGRsZXdhcmUucnVuKHNhZ2EpO1xuXG4gIHJldHVybiBzdG9yZTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvc3RvcmUvY29tbW9uLmpzIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVkdXgtc2FnYVwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInJlZHV4LXNhZ2FcIlxuLy8gbW9kdWxlIGlkID0gMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVkdXgtY2xpLWxvZ2dlclwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInJlZHV4LWNsaS1sb2dnZXJcIlxuLy8gbW9kdWxlIGlkID0gNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGpzb24gPSB0eXBlb2YgSlNPTiAhPT0gJ3VuZGVmaW5lZCcgPyBKU09OIDogcmVxdWlyZSgnanNvbmlmeScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmosIG9wdHMpIHtcbiAgICBpZiAoIW9wdHMpIG9wdHMgPSB7fTtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIG9wdHMgPSB7IGNtcDogb3B0cyB9O1xuICAgIHZhciBzcGFjZSA9IG9wdHMuc3BhY2UgfHwgJyc7XG4gICAgaWYgKHR5cGVvZiBzcGFjZSA9PT0gJ251bWJlcicpIHNwYWNlID0gQXJyYXkoc3BhY2UrMSkuam9pbignICcpO1xuICAgIHZhciBjeWNsZXMgPSAodHlwZW9mIG9wdHMuY3ljbGVzID09PSAnYm9vbGVhbicpID8gb3B0cy5jeWNsZXMgOiBmYWxzZTtcbiAgICB2YXIgcmVwbGFjZXIgPSBvcHRzLnJlcGxhY2VyIHx8IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuXG4gICAgdmFyIGNtcCA9IG9wdHMuY21wICYmIChmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHZhciBhb2JqID0geyBrZXk6IGEsIHZhbHVlOiBub2RlW2FdIH07XG4gICAgICAgICAgICAgICAgdmFyIGJvYmogPSB7IGtleTogYiwgdmFsdWU6IG5vZGVbYl0gfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZihhb2JqLCBib2JqKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfSkob3B0cy5jbXApO1xuXG4gICAgdmFyIHNlZW4gPSBbXTtcbiAgICByZXR1cm4gKGZ1bmN0aW9uIHN0cmluZ2lmeSAocGFyZW50LCBrZXksIG5vZGUsIGxldmVsKSB7XG4gICAgICAgIHZhciBpbmRlbnQgPSBzcGFjZSA/ICgnXFxuJyArIG5ldyBBcnJheShsZXZlbCArIDEpLmpvaW4oc3BhY2UpKSA6ICcnO1xuICAgICAgICB2YXIgY29sb25TZXBhcmF0b3IgPSBzcGFjZSA/ICc6ICcgOiAnOic7XG5cbiAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS50b0pTT04gJiYgdHlwZW9mIG5vZGUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBub2RlID0gbm9kZS50b0pTT04oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSByZXBsYWNlci5jYWxsKHBhcmVudCwga2V5LCBub2RlKTtcblxuICAgICAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JyB8fCBub2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4ganNvbi5zdHJpbmdpZnkobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gc3RyaW5naWZ5KG5vZGUsIGksIG5vZGVbaV0sIGxldmVsKzEpIHx8IGpzb24uc3RyaW5naWZ5KG51bGwpO1xuICAgICAgICAgICAgICAgIG91dC5wdXNoKGluZGVudCArIHNwYWNlICsgaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ1snICsgb3V0LmpvaW4oJywnKSArIGluZGVudCArICddJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzZWVuLmluZGV4T2Yobm9kZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN5Y2xlcykgcmV0dXJuIGpzb24uc3RyaW5naWZ5KCdfX2N5Y2xlX18nKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb252ZXJ0aW5nIGNpcmN1bGFyIHN0cnVjdHVyZSB0byBKU09OJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHNlZW4ucHVzaChub2RlKTtcblxuICAgICAgICAgICAgdmFyIGtleXMgPSBvYmplY3RLZXlzKG5vZGUpLnNvcnQoY21wICYmIGNtcChub2RlKSk7XG4gICAgICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBzdHJpbmdpZnkobm9kZSwga2V5LCBub2RlW2tleV0sIGxldmVsKzEpO1xuXG4gICAgICAgICAgICAgICAgaWYoIXZhbHVlKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIHZhciBrZXlWYWx1ZSA9IGpzb24uc3RyaW5naWZ5KGtleSlcbiAgICAgICAgICAgICAgICAgICAgKyBjb2xvblNlcGFyYXRvclxuICAgICAgICAgICAgICAgICAgICArIHZhbHVlO1xuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBvdXQucHVzaChpbmRlbnQgKyBzcGFjZSArIGtleVZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlZW4uc3BsaWNlKHNlZW4uaW5kZXhPZihub2RlKSwgMSk7XG4gICAgICAgICAgICByZXR1cm4gJ3snICsgb3V0LmpvaW4oJywnKSArIGluZGVudCArICd9JztcbiAgICAgICAgfVxuICAgIH0pKHsgJyc6IG9iaiB9LCAnJywgb2JqLCAwKTtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiB7fS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkgfHwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZSB9O1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoaGFzLmNhbGwob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL1VzZXJzL2duaWRhbi9zcmMvd29yay90cnVmZmxlL25vZGVfbW9kdWxlcy9qc29uLXN0YWJsZS1zdHJpbmdpZnkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2xpYi9wYXJzZScpO1xuZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2xpYi9zdHJpbmdpZnknKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9Vc2Vycy9nbmlkYW4vc3JjL3dvcmsvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvanNvbmlmeS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGF0LCAvLyBUaGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgY2hhcmFjdGVyXG4gICAgY2gsIC8vIFRoZSBjdXJyZW50IGNoYXJhY3RlclxuICAgIGVzY2FwZWUgPSB7XG4gICAgICAgICdcIic6ICAnXCInLFxuICAgICAgICAnXFxcXCc6ICdcXFxcJyxcbiAgICAgICAgJy8nOiAgJy8nLFxuICAgICAgICBiOiAgICAnXFxiJyxcbiAgICAgICAgZjogICAgJ1xcZicsXG4gICAgICAgIG46ICAgICdcXG4nLFxuICAgICAgICByOiAgICAnXFxyJyxcbiAgICAgICAgdDogICAgJ1xcdCdcbiAgICB9LFxuICAgIHRleHQsXG5cbiAgICBlcnJvciA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIC8vIENhbGwgZXJyb3Igd2hlbiBzb21ldGhpbmcgaXMgd3JvbmcuXG4gICAgICAgIHRocm93IHtcbiAgICAgICAgICAgIG5hbWU6ICAgICdTeW50YXhFcnJvcicsXG4gICAgICAgICAgICBtZXNzYWdlOiBtLFxuICAgICAgICAgICAgYXQ6ICAgICAgYXQsXG4gICAgICAgICAgICB0ZXh0OiAgICB0ZXh0XG4gICAgICAgIH07XG4gICAgfSxcbiAgICBcbiAgICBuZXh0ID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgLy8gSWYgYSBjIHBhcmFtZXRlciBpcyBwcm92aWRlZCwgdmVyaWZ5IHRoYXQgaXQgbWF0Y2hlcyB0aGUgY3VycmVudCBjaGFyYWN0ZXIuXG4gICAgICAgIGlmIChjICYmIGMgIT09IGNoKSB7XG4gICAgICAgICAgICBlcnJvcihcIkV4cGVjdGVkICdcIiArIGMgKyBcIicgaW5zdGVhZCBvZiAnXCIgKyBjaCArIFwiJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gR2V0IHRoZSBuZXh0IGNoYXJhY3Rlci4gV2hlbiB0aGVyZSBhcmUgbm8gbW9yZSBjaGFyYWN0ZXJzLFxuICAgICAgICAvLyByZXR1cm4gdGhlIGVtcHR5IHN0cmluZy5cbiAgICAgICAgXG4gICAgICAgIGNoID0gdGV4dC5jaGFyQXQoYXQpO1xuICAgICAgICBhdCArPSAxO1xuICAgICAgICByZXR1cm4gY2g7XG4gICAgfSxcbiAgICBcbiAgICBudW1iZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFBhcnNlIGEgbnVtYmVyIHZhbHVlLlxuICAgICAgICB2YXIgbnVtYmVyLFxuICAgICAgICAgICAgc3RyaW5nID0gJyc7XG4gICAgICAgIFxuICAgICAgICBpZiAoY2ggPT09ICctJykge1xuICAgICAgICAgICAgc3RyaW5nID0gJy0nO1xuICAgICAgICAgICAgbmV4dCgnLScpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChjaCA+PSAnMCcgJiYgY2ggPD0gJzknKSB7XG4gICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoID09PSAnLicpIHtcbiAgICAgICAgICAgIHN0cmluZyArPSAnLic7XG4gICAgICAgICAgICB3aGlsZSAobmV4dCgpICYmIGNoID49ICcwJyAmJiBjaCA8PSAnOScpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoID09PSAnZScgfHwgY2ggPT09ICdFJykge1xuICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnLScgfHwgY2ggPT09ICcrJykge1xuICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY2ggPj0gJzAnICYmIGNoIDw9ICc5Jykge1xuICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbnVtYmVyID0gK3N0cmluZztcbiAgICAgICAgaWYgKCFpc0Zpbml0ZShudW1iZXIpKSB7XG4gICAgICAgICAgICBlcnJvcihcIkJhZCBudW1iZXJcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBzdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFBhcnNlIGEgc3RyaW5nIHZhbHVlLlxuICAgICAgICB2YXIgaGV4LFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIHN0cmluZyA9ICcnLFxuICAgICAgICAgICAgdWZmZmY7XG4gICAgICAgIFxuICAgICAgICAvLyBXaGVuIHBhcnNpbmcgZm9yIHN0cmluZyB2YWx1ZXMsIHdlIG11c3QgbG9vayBmb3IgXCIgYW5kIFxcIGNoYXJhY3RlcnMuXG4gICAgICAgIGlmIChjaCA9PT0gJ1wiJykge1xuICAgICAgICAgICAgd2hpbGUgKG5leHQoKSkge1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1wiJykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAndScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVmZmZmID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA0OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZXggPSBwYXJzZUludChuZXh0KCksIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRmluaXRlKGhleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVmZmZmID0gdWZmZmYgKiAxNiArIGhleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHVmZmZmKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZXNjYXBlZVtjaF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gZXNjYXBlZVtjaF07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3IoXCJCYWQgc3RyaW5nXCIpO1xuICAgIH0sXG5cbiAgICB3aGl0ZSA9IGZ1bmN0aW9uICgpIHtcblxuLy8gU2tpcCB3aGl0ZXNwYWNlLlxuXG4gICAgICAgIHdoaWxlIChjaCAmJiBjaCA8PSAnICcpIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB3b3JkID0gZnVuY3Rpb24gKCkge1xuXG4vLyB0cnVlLCBmYWxzZSwgb3IgbnVsbC5cblxuICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgbmV4dCgndCcpO1xuICAgICAgICAgICAgbmV4dCgncicpO1xuICAgICAgICAgICAgbmV4dCgndScpO1xuICAgICAgICAgICAgbmV4dCgnZScpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgbmV4dCgnZicpO1xuICAgICAgICAgICAgbmV4dCgnYScpO1xuICAgICAgICAgICAgbmV4dCgnbCcpO1xuICAgICAgICAgICAgbmV4dCgncycpO1xuICAgICAgICAgICAgbmV4dCgnZScpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjYXNlICduJzpcbiAgICAgICAgICAgIG5leHQoJ24nKTtcbiAgICAgICAgICAgIG5leHQoJ3UnKTtcbiAgICAgICAgICAgIG5leHQoJ2wnKTtcbiAgICAgICAgICAgIG5leHQoJ2wnKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yKFwiVW5leHBlY3RlZCAnXCIgKyBjaCArIFwiJ1wiKTtcbiAgICB9LFxuXG4gICAgdmFsdWUsICAvLyBQbGFjZSBob2xkZXIgZm9yIHRoZSB2YWx1ZSBmdW5jdGlvbi5cblxuICAgIGFycmF5ID0gZnVuY3Rpb24gKCkge1xuXG4vLyBQYXJzZSBhbiBhcnJheSB2YWx1ZS5cblxuICAgICAgICB2YXIgYXJyYXkgPSBbXTtcblxuICAgICAgICBpZiAoY2ggPT09ICdbJykge1xuICAgICAgICAgICAgbmV4dCgnWycpO1xuICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ10nKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgnXScpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheTsgICAvLyBlbXB0eSBhcnJheVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNoKSB7XG4gICAgICAgICAgICAgICAgYXJyYXkucHVzaCh2YWx1ZSgpKTtcbiAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ10nKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ10nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0KCcsJyk7XG4gICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlcnJvcihcIkJhZCBhcnJheVwiKTtcbiAgICB9LFxuXG4gICAgb2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuXG4vLyBQYXJzZSBhbiBvYmplY3QgdmFsdWUuXG5cbiAgICAgICAgdmFyIGtleSxcbiAgICAgICAgICAgIG9iamVjdCA9IHt9O1xuXG4gICAgICAgIGlmIChjaCA9PT0gJ3snKSB7XG4gICAgICAgICAgICBuZXh0KCd7Jyk7XG4gICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnfScpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCd9Jyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDsgICAvLyBlbXB0eSBvYmplY3RcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjaCkge1xuICAgICAgICAgICAgICAgIGtleSA9IHN0cmluZygpO1xuICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAgICAgbmV4dCgnOicpO1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IoJ0R1cGxpY2F0ZSBrZXkgXCInICsga2V5ICsgJ1wiJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9iamVjdFtrZXldID0gdmFsdWUoKTtcbiAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ30nKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ30nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dCgnLCcpO1xuICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3IoXCJCYWQgb2JqZWN0XCIpO1xuICAgIH07XG5cbnZhbHVlID0gZnVuY3Rpb24gKCkge1xuXG4vLyBQYXJzZSBhIEpTT04gdmFsdWUuIEl0IGNvdWxkIGJlIGFuIG9iamVjdCwgYW4gYXJyYXksIGEgc3RyaW5nLCBhIG51bWJlcixcbi8vIG9yIGEgd29yZC5cblxuICAgIHdoaXRlKCk7XG4gICAgc3dpdGNoIChjaCkge1xuICAgIGNhc2UgJ3snOlxuICAgICAgICByZXR1cm4gb2JqZWN0KCk7XG4gICAgY2FzZSAnWyc6XG4gICAgICAgIHJldHVybiBhcnJheSgpO1xuICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgcmV0dXJuIHN0cmluZygpO1xuICAgIGNhc2UgJy0nOlxuICAgICAgICByZXR1cm4gbnVtYmVyKCk7XG4gICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGNoID49ICcwJyAmJiBjaCA8PSAnOScgPyBudW1iZXIoKSA6IHdvcmQoKTtcbiAgICB9XG59O1xuXG4vLyBSZXR1cm4gdGhlIGpzb25fcGFyc2UgZnVuY3Rpb24uIEl0IHdpbGwgaGF2ZSBhY2Nlc3MgdG8gYWxsIG9mIHRoZSBhYm92ZVxuLy8gZnVuY3Rpb25zIGFuZCB2YXJpYWJsZXMuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNvdXJjZSwgcmV2aXZlcikge1xuICAgIHZhciByZXN1bHQ7XG4gICAgXG4gICAgdGV4dCA9IHNvdXJjZTtcbiAgICBhdCA9IDA7XG4gICAgY2ggPSAnICc7XG4gICAgcmVzdWx0ID0gdmFsdWUoKTtcbiAgICB3aGl0ZSgpO1xuICAgIGlmIChjaCkge1xuICAgICAgICBlcnJvcihcIlN5bnRheCBlcnJvclwiKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBhIHJldml2ZXIgZnVuY3Rpb24sIHdlIHJlY3Vyc2l2ZWx5IHdhbGsgdGhlIG5ldyBzdHJ1Y3R1cmUsXG4gICAgLy8gcGFzc2luZyBlYWNoIG5hbWUvdmFsdWUgcGFpciB0byB0aGUgcmV2aXZlciBmdW5jdGlvbiBmb3IgcG9zc2libGVcbiAgICAvLyB0cmFuc2Zvcm1hdGlvbiwgc3RhcnRpbmcgd2l0aCBhIHRlbXBvcmFyeSByb290IG9iamVjdCB0aGF0IGhvbGRzIHRoZSByZXN1bHRcbiAgICAvLyBpbiBhbiBlbXB0eSBrZXkuIElmIHRoZXJlIGlzIG5vdCBhIHJldml2ZXIgZnVuY3Rpb24sIHdlIHNpbXBseSByZXR1cm4gdGhlXG4gICAgLy8gcmVzdWx0LlxuXG4gICAgcmV0dXJuIHR5cGVvZiByZXZpdmVyID09PSAnZnVuY3Rpb24nID8gKGZ1bmN0aW9uIHdhbGsoaG9sZGVyLCBrZXkpIHtcbiAgICAgICAgdmFyIGssIHYsIHZhbHVlID0gaG9sZGVyW2tleV07XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBmb3IgKGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrKSkge1xuICAgICAgICAgICAgICAgICAgICB2ID0gd2Fsayh2YWx1ZSwgayk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2tdID0gdjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtrXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV2aXZlci5jYWxsKGhvbGRlciwga2V5LCB2YWx1ZSk7XG4gICAgfSh7Jyc6IHJlc3VsdH0sICcnKSkgOiByZXN1bHQ7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL1VzZXJzL2duaWRhbi9zcmMvd29yay90cnVmZmxlL25vZGVfbW9kdWxlcy9qc29uaWZ5L2xpYi9wYXJzZS5qc1xuLy8gbW9kdWxlIGlkID0gNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGN4ID0gL1tcXHUwMDAwXFx1MDBhZFxcdTA2MDAtXFx1MDYwNFxcdTA3MGZcXHUxN2I0XFx1MTdiNVxcdTIwMGMtXFx1MjAwZlxcdTIwMjgtXFx1MjAyZlxcdTIwNjAtXFx1MjA2ZlxcdWZlZmZcXHVmZmYwLVxcdWZmZmZdL2csXG4gICAgZXNjYXBhYmxlID0gL1tcXFxcXFxcIlxceDAwLVxceDFmXFx4N2YtXFx4OWZcXHUwMGFkXFx1MDYwMC1cXHUwNjA0XFx1MDcwZlxcdTE3YjRcXHUxN2I1XFx1MjAwYy1cXHUyMDBmXFx1MjAyOC1cXHUyMDJmXFx1MjA2MC1cXHUyMDZmXFx1ZmVmZlxcdWZmZjAtXFx1ZmZmZl0vZyxcbiAgICBnYXAsXG4gICAgaW5kZW50LFxuICAgIG1ldGEgPSB7ICAgIC8vIHRhYmxlIG9mIGNoYXJhY3RlciBzdWJzdGl0dXRpb25zXG4gICAgICAgICdcXGInOiAnXFxcXGInLFxuICAgICAgICAnXFx0JzogJ1xcXFx0JyxcbiAgICAgICAgJ1xcbic6ICdcXFxcbicsXG4gICAgICAgICdcXGYnOiAnXFxcXGYnLFxuICAgICAgICAnXFxyJzogJ1xcXFxyJyxcbiAgICAgICAgJ1wiJyA6ICdcXFxcXCInLFxuICAgICAgICAnXFxcXCc6ICdcXFxcXFxcXCdcbiAgICB9LFxuICAgIHJlcDtcblxuZnVuY3Rpb24gcXVvdGUoc3RyaW5nKSB7XG4gICAgLy8gSWYgdGhlIHN0cmluZyBjb250YWlucyBubyBjb250cm9sIGNoYXJhY3RlcnMsIG5vIHF1b3RlIGNoYXJhY3RlcnMsIGFuZCBub1xuICAgIC8vIGJhY2tzbGFzaCBjaGFyYWN0ZXJzLCB0aGVuIHdlIGNhbiBzYWZlbHkgc2xhcCBzb21lIHF1b3RlcyBhcm91bmQgaXQuXG4gICAgLy8gT3RoZXJ3aXNlIHdlIG11c3QgYWxzbyByZXBsYWNlIHRoZSBvZmZlbmRpbmcgY2hhcmFjdGVycyB3aXRoIHNhZmUgZXNjYXBlXG4gICAgLy8gc2VxdWVuY2VzLlxuICAgIFxuICAgIGVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICAgIHJldHVybiBlc2NhcGFibGUudGVzdChzdHJpbmcpID8gJ1wiJyArIHN0cmluZy5yZXBsYWNlKGVzY2FwYWJsZSwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIGMgPSBtZXRhW2FdO1xuICAgICAgICByZXR1cm4gdHlwZW9mIGMgPT09ICdzdHJpbmcnID8gYyA6XG4gICAgICAgICAgICAnXFxcXHUnICsgKCcwMDAwJyArIGEuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcbiAgICB9KSArICdcIicgOiAnXCInICsgc3RyaW5nICsgJ1wiJztcbn1cblxuZnVuY3Rpb24gc3RyKGtleSwgaG9sZGVyKSB7XG4gICAgLy8gUHJvZHVjZSBhIHN0cmluZyBmcm9tIGhvbGRlcltrZXldLlxuICAgIHZhciBpLCAgICAgICAgICAvLyBUaGUgbG9vcCBjb3VudGVyLlxuICAgICAgICBrLCAgICAgICAgICAvLyBUaGUgbWVtYmVyIGtleS5cbiAgICAgICAgdiwgICAgICAgICAgLy8gVGhlIG1lbWJlciB2YWx1ZS5cbiAgICAgICAgbGVuZ3RoLFxuICAgICAgICBtaW5kID0gZ2FwLFxuICAgICAgICBwYXJ0aWFsLFxuICAgICAgICB2YWx1ZSA9IGhvbGRlcltrZXldO1xuICAgIFxuICAgIC8vIElmIHRoZSB2YWx1ZSBoYXMgYSB0b0pTT04gbWV0aG9kLCBjYWxsIGl0IHRvIG9idGFpbiBhIHJlcGxhY2VtZW50IHZhbHVlLlxuICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKGtleSk7XG4gICAgfVxuICAgIFxuICAgIC8vIElmIHdlIHdlcmUgY2FsbGVkIHdpdGggYSByZXBsYWNlciBmdW5jdGlvbiwgdGhlbiBjYWxsIHRoZSByZXBsYWNlciB0b1xuICAgIC8vIG9idGFpbiBhIHJlcGxhY2VtZW50IHZhbHVlLlxuICAgIGlmICh0eXBlb2YgcmVwID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbHVlID0gcmVwLmNhbGwoaG9sZGVyLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgXG4gICAgLy8gV2hhdCBoYXBwZW5zIG5leHQgZGVwZW5kcyBvbiB0aGUgdmFsdWUncyB0eXBlLlxuICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICByZXR1cm4gcXVvdGUodmFsdWUpO1xuICAgICAgICBcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgIC8vIEpTT04gbnVtYmVycyBtdXN0IGJlIGZpbml0ZS4gRW5jb2RlIG5vbi1maW5pdGUgbnVtYmVycyBhcyBudWxsLlxuICAgICAgICAgICAgcmV0dXJuIGlzRmluaXRlKHZhbHVlKSA/IFN0cmluZyh2YWx1ZSkgOiAnbnVsbCc7XG4gICAgICAgIFxuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgY2FzZSAnbnVsbCc6XG4gICAgICAgICAgICAvLyBJZiB0aGUgdmFsdWUgaXMgYSBib29sZWFuIG9yIG51bGwsIGNvbnZlcnQgaXQgdG8gYSBzdHJpbmcuIE5vdGU6XG4gICAgICAgICAgICAvLyB0eXBlb2YgbnVsbCBkb2VzIG5vdCBwcm9kdWNlICdudWxsJy4gVGhlIGNhc2UgaXMgaW5jbHVkZWQgaGVyZSBpblxuICAgICAgICAgICAgLy8gdGhlIHJlbW90ZSBjaGFuY2UgdGhhdCB0aGlzIGdldHMgZml4ZWQgc29tZWRheS5cbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgXG4gICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICBpZiAoIXZhbHVlKSByZXR1cm4gJ251bGwnO1xuICAgICAgICAgICAgZ2FwICs9IGluZGVudDtcbiAgICAgICAgICAgIHBhcnRpYWwgPSBbXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQXJyYXkuaXNBcnJheVxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsW2ldID0gc3RyKGksIHZhbHVlKSB8fCAnbnVsbCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIEpvaW4gYWxsIG9mIHRoZSBlbGVtZW50cyB0b2dldGhlciwgc2VwYXJhdGVkIHdpdGggY29tbWFzLCBhbmRcbiAgICAgICAgICAgICAgICAvLyB3cmFwIHRoZW0gaW4gYnJhY2tldHMuXG4gICAgICAgICAgICAgICAgdiA9IHBhcnRpYWwubGVuZ3RoID09PSAwID8gJ1tdJyA6IGdhcCA/XG4gICAgICAgICAgICAgICAgICAgICdbXFxuJyArIGdhcCArIHBhcnRpYWwuam9pbignLFxcbicgKyBnYXApICsgJ1xcbicgKyBtaW5kICsgJ10nIDpcbiAgICAgICAgICAgICAgICAgICAgJ1snICsgcGFydGlhbC5qb2luKCcsJykgKyAnXSc7XG4gICAgICAgICAgICAgICAgZ2FwID0gbWluZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gSWYgdGhlIHJlcGxhY2VyIGlzIGFuIGFycmF5LCB1c2UgaXQgdG8gc2VsZWN0IHRoZSBtZW1iZXJzIHRvIGJlXG4gICAgICAgICAgICAvLyBzdHJpbmdpZmllZC5cbiAgICAgICAgICAgIGlmIChyZXAgJiYgdHlwZW9mIHJlcCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSByZXAubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBrID0gcmVwW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGsgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gc3RyKGssIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbC5wdXNoKHF1b3RlKGspICsgKGdhcCA/ICc6ICcgOiAnOicpICsgdik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIGl0ZXJhdGUgdGhyb3VnaCBhbGwgb2YgdGhlIGtleXMgaW4gdGhlIG9iamVjdC5cbiAgICAgICAgICAgICAgICBmb3IgKGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgaykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBzdHIoaywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsLnB1c2gocXVvdGUoaykgKyAoZ2FwID8gJzogJyA6ICc6JykgKyB2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAvLyBKb2luIGFsbCBvZiB0aGUgbWVtYmVyIHRleHRzIHRvZ2V0aGVyLCBzZXBhcmF0ZWQgd2l0aCBjb21tYXMsXG4gICAgICAgIC8vIGFuZCB3cmFwIHRoZW0gaW4gYnJhY2VzLlxuXG4gICAgICAgIHYgPSBwYXJ0aWFsLmxlbmd0aCA9PT0gMCA/ICd7fScgOiBnYXAgP1xuICAgICAgICAgICAgJ3tcXG4nICsgZ2FwICsgcGFydGlhbC5qb2luKCcsXFxuJyArIGdhcCkgKyAnXFxuJyArIG1pbmQgKyAnfScgOlxuICAgICAgICAgICAgJ3snICsgcGFydGlhbC5qb2luKCcsJykgKyAnfSc7XG4gICAgICAgIGdhcCA9IG1pbmQ7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSkge1xuICAgIHZhciBpO1xuICAgIGdhcCA9ICcnO1xuICAgIGluZGVudCA9ICcnO1xuICAgIFxuICAgIC8vIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBudW1iZXIsIG1ha2UgYW4gaW5kZW50IHN0cmluZyBjb250YWluaW5nIHRoYXRcbiAgICAvLyBtYW55IHNwYWNlcy5cbiAgICBpZiAodHlwZW9mIHNwYWNlID09PSAnbnVtYmVyJykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3BhY2U7IGkgKz0gMSkge1xuICAgICAgICAgICAgaW5kZW50ICs9ICcgJztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGlzIGEgc3RyaW5nLCBpdCB3aWxsIGJlIHVzZWQgYXMgdGhlIGluZGVudCBzdHJpbmcuXG4gICAgZWxzZSBpZiAodHlwZW9mIHNwYWNlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpbmRlbnQgPSBzcGFjZTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBhIHJlcGxhY2VyLCBpdCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYW4gYXJyYXkuXG4gICAgLy8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvci5cbiAgICByZXAgPSByZXBsYWNlcjtcbiAgICBpZiAocmVwbGFjZXIgJiYgdHlwZW9mIHJlcGxhY2VyICE9PSAnZnVuY3Rpb24nXG4gICAgJiYgKHR5cGVvZiByZXBsYWNlciAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIHJlcGxhY2VyLmxlbmd0aCAhPT0gJ251bWJlcicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSlNPTi5zdHJpbmdpZnknKTtcbiAgICB9XG4gICAgXG4gICAgLy8gTWFrZSBhIGZha2Ugcm9vdCBvYmplY3QgY29udGFpbmluZyBvdXIgdmFsdWUgdW5kZXIgdGhlIGtleSBvZiAnJy5cbiAgICAvLyBSZXR1cm4gdGhlIHJlc3VsdCBvZiBzdHJpbmdpZnlpbmcgdGhlIHZhbHVlLlxuICAgIHJldHVybiBzdHIoJycsIHsnJzogdmFsdWV9KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvVXNlcnMvZ25pZGFuL3NyYy93b3JrL3RydWZmbGUvbm9kZV9tb2R1bGVzL2pzb25pZnkvbGliL3N0cmluZ2lmeS5qc1xuLy8gbW9kdWxlIGlkID0gNDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidHJ1ZmZsZS1zb2xpZGl0eS11dGlsc1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInRydWZmbGUtc29saWRpdHktdXRpbHNcIlxuLy8gbW9kdWxlIGlkID0gNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidHJ1ZmZsZS1jb2RlLXV0aWxzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwidHJ1ZmZsZS1jb2RlLXV0aWxzXCJcbi8vIG1vZHVsZSBpZCA9IDQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIlwidXNlIHN0cmljdFwiO1xyXG4vLyBBbiBhdWdtZW50ZWQgQVZMIFRyZWUgd2hlcmUgZWFjaCBub2RlIG1haW50YWlucyBhIGxpc3Qgb2YgcmVjb3JkcyBhbmQgdGhlaXIgc2VhcmNoIGludGVydmFscy5cclxuLy8gUmVjb3JkIGlzIGNvbXBvc2VkIG9mIGFuIGludGVydmFsIGFuZCBpdHMgdW5kZXJseWluZyBkYXRhLCBzZW50IGJ5IGEgY2xpZW50LiBUaGlzIGFsbG93cyB0aGVcclxuLy8gaW50ZXJ2YWwgdHJlZSB0byBoYXZlIHRoZSBzYW1lIGludGVydmFsIGluc2VydGVkIG11bHRpcGxlIHRpbWVzLCBhcyBsb25nIGl0cyBkYXRhIGlzIGRpZmZlcmVudC5cclxuLy8gQm90aCBpbnNlcnRpb24gYW5kIGRlbGV0aW9uIHJlcXVpcmUgTyhsb2cgbikgdGltZS4gU2VhcmNoaW5nIHJlcXVpcmVzIE8oaypsb2duKSB0aW1lLCB3aGVyZSBga2BcclxuLy8gaXMgdGhlIG51bWJlciBvZiBpbnRlcnZhbHMgaW4gdGhlIG91dHB1dCBsaXN0LlxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBpc1NhbWUgPSByZXF1aXJlKFwic2hhbGxvd2VxdWFsXCIpO1xyXG5mdW5jdGlvbiBoZWlnaHQobm9kZSkge1xyXG4gICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBub2RlLmhlaWdodDtcclxuICAgIH1cclxufVxyXG52YXIgTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE5vZGUoaW50ZXJ2YWxUcmVlLCByZWNvcmQpIHtcclxuICAgICAgICB0aGlzLmludGVydmFsVHJlZSA9IGludGVydmFsVHJlZTtcclxuICAgICAgICB0aGlzLnJlY29yZHMgPSBbXTtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IDA7XHJcbiAgICAgICAgdGhpcy5rZXkgPSByZWNvcmQubG93O1xyXG4gICAgICAgIHRoaXMubWF4ID0gcmVjb3JkLmhpZ2g7XHJcbiAgICAgICAgLy8gU2F2ZSB0aGUgYXJyYXkgb2YgYWxsIHJlY29yZHMgd2l0aCB0aGUgc2FtZSBrZXkgZm9yIHRoaXMgbm9kZVxyXG4gICAgICAgIHRoaXMucmVjb3Jkcy5wdXNoKHJlY29yZCk7XHJcbiAgICB9XHJcbiAgICAvLyBHZXRzIHRoZSBoaWdoZXN0IHJlY29yZC5oaWdoIHZhbHVlIGZvciB0aGlzIG5vZGVcclxuICAgIE5vZGUucHJvdG90eXBlLmdldE5vZGVIaWdoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBoaWdoID0gdGhpcy5yZWNvcmRzWzBdLmhpZ2g7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLnJlY29yZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucmVjb3Jkc1tpXS5oaWdoID4gaGlnaCkge1xyXG4gICAgICAgICAgICAgICAgaGlnaCA9IHRoaXMucmVjb3Jkc1tpXS5oaWdoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBoaWdoO1xyXG4gICAgfTtcclxuICAgIC8vIFVwZGF0ZXMgaGVpZ2h0IHZhbHVlIG9mIHRoZSBub2RlLiBDYWxsZWQgZHVyaW5nIGluc2VydGlvbiwgcmViYWxhbmNlLCByZW1vdmFsXHJcbiAgICBOb2RlLnByb3RvdHlwZS51cGRhdGVIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBNYXRoLm1heChoZWlnaHQodGhpcy5sZWZ0KSwgaGVpZ2h0KHRoaXMucmlnaHQpKSArIDE7XHJcbiAgICB9O1xyXG4gICAgLy8gVXBkYXRlcyB0aGUgbWF4IHZhbHVlIG9mIGFsbCB0aGUgcGFyZW50cyBhZnRlciBpbnNlcnRpbmcgaW50byBhbHJlYWR5IGV4aXN0aW5nIG5vZGUsIGFzIHdlbGwgYXNcclxuICAgIC8vIHJlbW92aW5nIHRoZSBub2RlIGNvbXBsZXRlbHkgb3IgcmVtb3ZpbmcgdGhlIHJlY29yZCBvZiBhbiBhbHJlYWR5IGV4aXN0aW5nIG5vZGUuIFN0YXJ0cyB3aXRoXHJcbiAgICAvLyB0aGUgcGFyZW50IG9mIGFuIGFmZmVjdGVkIG5vZGUgYW5kIGJ1YmJsZXMgdXAgdG8gcm9vdFxyXG4gICAgTm9kZS5wcm90b3R5cGUudXBkYXRlTWF4T2ZQYXJlbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdGhpc0hpZ2ggPSB0aGlzLmdldE5vZGVIaWdoKCk7XHJcbiAgICAgICAgaWYgKHRoaXMubGVmdCAhPT0gdW5kZWZpbmVkICYmIHRoaXMucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KE1hdGgubWF4KHRoaXMubGVmdC5tYXgsIHRoaXMucmlnaHQubWF4KSwgdGhpc0hpZ2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmxlZnQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSBNYXRoLm1heCh0aGlzLmxlZnQubWF4LCB0aGlzSGlnaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMubGVmdCA9PT0gdW5kZWZpbmVkICYmIHRoaXMucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KHRoaXMucmlnaHQubWF4LCB0aGlzSGlnaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IHRoaXNIaWdoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQudXBkYXRlTWF4T2ZQYXJlbnRzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBMZWZ0LUxlZnQgY2FzZTpcclxuICBcclxuICAgICAgICAgICB6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5XHJcbiAgICAgICAgICAvIFxcICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvICAgXFxcclxuICAgICAgICAgeSAgIFQ0ICAgICAgUmlnaHQgUm90YXRlICh6KSAgICAgICAgICB4ICAgICB6XHJcbiAgICAgICAgLyBcXCAgICAgICAgICAtIC0gLSAtIC0gLSAtIC0gLT4gICAgICAgLyBcXCAgIC8gXFxcclxuICAgICAgIHggICBUMyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVDEgVDIgVDMgVDRcclxuICAgICAgLyBcXFxyXG4gICAgVDEgICBUMlxyXG4gIFxyXG4gICAgTGVmdC1SaWdodCBjYXNlOlxyXG4gIFxyXG4gICAgICAgICB6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHogICAgICAgICAgICAgICAgICAgICAgICAgICB4XHJcbiAgICAgICAgLyBcXCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyBcXCAgICAgICAgICAgICAgICAgICAgICAgIC8gICBcXFxyXG4gICAgICAgeSAgIFQ0ICBMZWZ0IFJvdGF0ZSAoeSkgICAgICAgICB4ICBUNCAgUmlnaHQgUm90YXRlKHopICAgICB5ICAgICB6XHJcbiAgICAgIC8gXFwgICAgICAtIC0gLSAtIC0gLSAtIC0gLT4gICAgIC8gXFwgICAgICAtIC0gLSAtIC0gLSAtIC0+ICAvIFxcICAgLyBcXFxyXG4gICAgVDEgICB4ICAgICAgICAgICAgICAgICAgICAgICAgICAgeSAgVDMgICAgICAgICAgICAgICAgICAgICAgVDEgVDIgVDMgVDRcclxuICAgICAgICAvIFxcICAgICAgICAgICAgICAgICAgICAgICAgIC8gXFxcclxuICAgICAgVDIgICBUMyAgICAgICAgICAgICAgICAgICAgICBUMSBUMlxyXG4gICAgKi9cclxuICAgIC8vIEhhbmRsZXMgTGVmdC1MZWZ0IGNhc2UgYW5kIExlZnQtUmlnaHQgY2FzZSBhZnRlciByZWJhbGFuY2luZyBBVkwgdHJlZVxyXG4gICAgTm9kZS5wcm90b3R5cGUuX3VwZGF0ZU1heEFmdGVyUmlnaHRSb3RhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgIHZhciBsZWZ0ID0gcGFyZW50LmxlZnQ7XHJcbiAgICAgICAgLy8gVXBkYXRlIG1heCBvZiBsZWZ0IHNpYmxpbmcgKHggaW4gZmlyc3QgY2FzZSwgeSBpbiBzZWNvbmQpXHJcbiAgICAgICAgdmFyIHRoaXNQYXJlbnRMZWZ0SGlnaCA9IGxlZnQuZ2V0Tm9kZUhpZ2goKTtcclxuICAgICAgICBpZiAobGVmdC5sZWZ0ID09PSB1bmRlZmluZWQgJiYgbGVmdC5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGxlZnQubWF4ID0gTWF0aC5tYXgodGhpc1BhcmVudExlZnRIaWdoLCBsZWZ0LnJpZ2h0Lm1heCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxlZnQubGVmdCAhPT0gdW5kZWZpbmVkICYmIGxlZnQucmlnaHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBsZWZ0Lm1heCA9IE1hdGgubWF4KHRoaXNQYXJlbnRMZWZ0SGlnaCwgbGVmdC5sZWZ0Lm1heCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxlZnQubGVmdCA9PT0gdW5kZWZpbmVkICYmIGxlZnQucmlnaHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBsZWZ0Lm1heCA9IHRoaXNQYXJlbnRMZWZ0SGlnaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxlZnQubWF4ID0gTWF0aC5tYXgoTWF0aC5tYXgobGVmdC5sZWZ0Lm1heCwgbGVmdC5yaWdodC5tYXgpLCB0aGlzUGFyZW50TGVmdEhpZ2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBVcGRhdGUgbWF4IG9mIGl0c2VsZiAoeilcclxuICAgICAgICB2YXIgdGhpc0hpZ2ggPSB0aGlzLmdldE5vZGVIaWdoKCk7XHJcbiAgICAgICAgaWYgKHRoaXMubGVmdCA9PT0gdW5kZWZpbmVkICYmIHRoaXMucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KHRoaXNIaWdoLCB0aGlzLnJpZ2h0Lm1heCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMubGVmdCAhPT0gdW5kZWZpbmVkICYmIHRoaXMucmlnaHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KHRoaXNIaWdoLCB0aGlzLmxlZnQubWF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5sZWZ0ID09PSB1bmRlZmluZWQgJiYgdGhpcy5yaWdodCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gdGhpc0hpZ2g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KE1hdGgubWF4KHRoaXMubGVmdC5tYXgsIHRoaXMucmlnaHQubWF4KSwgdGhpc0hpZ2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBVcGRhdGUgbWF4IG9mIHBhcmVudCAoeSBpbiBmaXJzdCBjYXNlLCB4IGluIHNlY29uZClcclxuICAgICAgICBwYXJlbnQubWF4ID0gTWF0aC5tYXgoTWF0aC5tYXgocGFyZW50LmxlZnQubWF4LCBwYXJlbnQucmlnaHQubWF4KSwgcGFyZW50LmdldE5vZGVIaWdoKCkpO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBSaWdodC1SaWdodCBjYXNlOlxyXG4gIFxyXG4gICAgICB6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlcclxuICAgICAvIFxcICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8gICBcXFxyXG4gICAgVDEgIHkgICAgIExlZnQgUm90YXRlKHopICAgICAgIHogICAgIHhcclxuICAgICAgIC8gXFwgICAtIC0gLSAtIC0gLSAtIC0+ICAgICAvIFxcICAgLyBcXFxyXG4gICAgICBUMiAgeCAgICAgICAgICAgICAgICAgICAgICBUMSBUMiBUMyBUNFxyXG4gICAgICAgICAvIFxcXHJcbiAgICAgICAgVDMgVDRcclxuICBcclxuICAgIFJpZ2h0LUxlZnQgY2FzZTpcclxuICBcclxuICAgICAgIHogICAgICAgICAgICAgICAgICAgICAgICAgICAgeiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4XHJcbiAgICAgIC8gXFwgICAgICAgICAgICAgICAgICAgICAgICAgIC8gXFwgICAgICAgICAgICAgICAgICAgICAgICAgLyAgIFxcXHJcbiAgICAgVDEgIHkgICBSaWdodCBSb3RhdGUgKHkpICAgICBUMSAgeCAgICAgIExlZnQgUm90YXRlKHopICAgeiAgICAgeVxyXG4gICAgICAgIC8gXFwgIC0gLSAtIC0gLSAtIC0gLSAtPiAgICAgIC8gXFwgICAtIC0gLSAtIC0gLSAtIC0+ICAvIFxcICAgLyBcXFxyXG4gICAgICAgeCAgVDQgICAgICAgICAgICAgICAgICAgICAgICBUMiAgeSAgICAgICAgICAgICAgICAgICBUMSBUMiBUMyBUNFxyXG4gICAgICAvIFxcICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyBcXFxyXG4gICAgVDIgICBUMyAgICAgICAgICAgICAgICAgICAgICAgICAgIFQzIFQ0XHJcbiAgICAqL1xyXG4gICAgLy8gSGFuZGxlcyBSaWdodC1SaWdodCBjYXNlIGFuZCBSaWdodC1MZWZ0IGNhc2UgaW4gcmViYWxhbmNpbmcgQVZMIHRyZWVcclxuICAgIE5vZGUucHJvdG90eXBlLl91cGRhdGVNYXhBZnRlckxlZnRSb3RhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgIHZhciByaWdodCA9IHBhcmVudC5yaWdodDtcclxuICAgICAgICAvLyBVcGRhdGUgbWF4IG9mIHJpZ2h0IHNpYmxpbmcgKHggaW4gZmlyc3QgY2FzZSwgeSBpbiBzZWNvbmQpXHJcbiAgICAgICAgdmFyIHRoaXNQYXJlbnRSaWdodEhpZ2ggPSByaWdodC5nZXROb2RlSGlnaCgpO1xyXG4gICAgICAgIGlmIChyaWdodC5sZWZ0ID09PSB1bmRlZmluZWQgJiYgcmlnaHQucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByaWdodC5tYXggPSBNYXRoLm1heCh0aGlzUGFyZW50UmlnaHRIaWdoLCByaWdodC5yaWdodC5tYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChyaWdodC5sZWZ0ICE9PSB1bmRlZmluZWQgJiYgcmlnaHQucmlnaHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByaWdodC5tYXggPSBNYXRoLm1heCh0aGlzUGFyZW50UmlnaHRIaWdoLCByaWdodC5sZWZ0Lm1heCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHJpZ2h0LmxlZnQgPT09IHVuZGVmaW5lZCAmJiByaWdodC5yaWdodCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJpZ2h0Lm1heCA9IHRoaXNQYXJlbnRSaWdodEhpZ2g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByaWdodC5tYXggPSBNYXRoLm1heChNYXRoLm1heChyaWdodC5sZWZ0Lm1heCwgcmlnaHQucmlnaHQubWF4KSwgdGhpc1BhcmVudFJpZ2h0SGlnaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFVwZGF0ZSBtYXggb2YgaXRzZWxmICh6KVxyXG4gICAgICAgIHZhciB0aGlzSGlnaCA9IHRoaXMuZ2V0Tm9kZUhpZ2goKTtcclxuICAgICAgICBpZiAodGhpcy5sZWZ0ID09PSB1bmRlZmluZWQgJiYgdGhpcy5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gTWF0aC5tYXgodGhpc0hpZ2gsIHRoaXMucmlnaHQubWF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5sZWZ0ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5yaWdodCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gTWF0aC5tYXgodGhpc0hpZ2gsIHRoaXMubGVmdC5tYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmxlZnQgPT09IHVuZGVmaW5lZCAmJiB0aGlzLnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSB0aGlzSGlnaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gTWF0aC5tYXgoTWF0aC5tYXgodGhpcy5sZWZ0Lm1heCwgdGhpcy5yaWdodC5tYXgpLCB0aGlzSGlnaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFVwZGF0ZSBtYXggb2YgcGFyZW50ICh5IGluIGZpcnN0IGNhc2UsIHggaW4gc2Vjb25kKVxyXG4gICAgICAgIHBhcmVudC5tYXggPSBNYXRoLm1heChNYXRoLm1heChwYXJlbnQubGVmdC5tYXgsIHJpZ2h0Lm1heCksIHBhcmVudC5nZXROb2RlSGlnaCgpKTtcclxuICAgIH07XHJcbiAgICBOb2RlLnByb3RvdHlwZS5fbGVmdFJvdGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmlnaHRDaGlsZCA9IHRoaXMucmlnaHQ7XHJcbiAgICAgICAgcmlnaHRDaGlsZC5wYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICBpZiAocmlnaHRDaGlsZC5wYXJlbnQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLmludGVydmFsVHJlZS5yb290ID0gcmlnaHRDaGlsZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChyaWdodENoaWxkLnBhcmVudC5sZWZ0ID09PSB0aGlzKSB7XHJcbiAgICAgICAgICAgICAgICByaWdodENoaWxkLnBhcmVudC5sZWZ0ID0gcmlnaHRDaGlsZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChyaWdodENoaWxkLnBhcmVudC5yaWdodCA9PT0gdGhpcykge1xyXG4gICAgICAgICAgICAgICAgcmlnaHRDaGlsZC5wYXJlbnQucmlnaHQgPSByaWdodENoaWxkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmlnaHQgPSByaWdodENoaWxkLmxlZnQ7XHJcbiAgICAgICAgaWYgKHRoaXMucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLnJpZ2h0LnBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJpZ2h0Q2hpbGQubGVmdCA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSByaWdodENoaWxkO1xyXG4gICAgICAgIHRoaXMudXBkYXRlSGVpZ2h0KCk7XHJcbiAgICAgICAgcmlnaHRDaGlsZC51cGRhdGVIZWlnaHQoKTtcclxuICAgIH07XHJcbiAgICBOb2RlLnByb3RvdHlwZS5fcmlnaHRSb3RhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGxlZnRDaGlsZCA9IHRoaXMubGVmdDtcclxuICAgICAgICBsZWZ0Q2hpbGQucGFyZW50ID0gdGhpcy5wYXJlbnQ7XHJcbiAgICAgICAgaWYgKGxlZnRDaGlsZC5wYXJlbnQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLmludGVydmFsVHJlZS5yb290ID0gbGVmdENoaWxkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGxlZnRDaGlsZC5wYXJlbnQubGVmdCA9PT0gdGhpcykge1xyXG4gICAgICAgICAgICAgICAgbGVmdENoaWxkLnBhcmVudC5sZWZ0ID0gbGVmdENoaWxkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGxlZnRDaGlsZC5wYXJlbnQucmlnaHQgPT09IHRoaXMpIHtcclxuICAgICAgICAgICAgICAgIGxlZnRDaGlsZC5wYXJlbnQucmlnaHQgPSBsZWZ0Q2hpbGQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdENoaWxkLnJpZ2h0O1xyXG4gICAgICAgIGlmICh0aGlzLmxlZnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLmxlZnQucGFyZW50ID0gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgbGVmdENoaWxkLnJpZ2h0ID0gdGhpcztcclxuICAgICAgICB0aGlzLnBhcmVudCA9IGxlZnRDaGlsZDtcclxuICAgICAgICB0aGlzLnVwZGF0ZUhlaWdodCgpO1xyXG4gICAgICAgIGxlZnRDaGlsZC51cGRhdGVIZWlnaHQoKTtcclxuICAgIH07XHJcbiAgICAvLyBSZWJhbGFuY2VzIHRoZSB0cmVlIGlmIHRoZSBoZWlnaHQgdmFsdWUgYmV0d2VlbiB0d28gbm9kZXMgb2YgdGhlIHNhbWUgcGFyZW50IGlzIGdyZWF0ZXIgdGhhblxyXG4gICAgLy8gdHdvLiBUaGVyZSBhcmUgNCBjYXNlcyB0aGF0IGNhbiBoYXBwZW4gd2hpY2ggYXJlIG91dGxpbmVkIGluIHRoZSBncmFwaGljcyBhYm92ZVxyXG4gICAgTm9kZS5wcm90b3R5cGUuX3JlYmFsYW5jZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoaGVpZ2h0KHRoaXMubGVmdCkgPj0gMiArIGhlaWdodCh0aGlzLnJpZ2h0KSkge1xyXG4gICAgICAgICAgICB2YXIgbGVmdCA9IHRoaXMubGVmdDtcclxuICAgICAgICAgICAgaWYgKGhlaWdodChsZWZ0LmxlZnQpID49IGhlaWdodChsZWZ0LnJpZ2h0KSkge1xyXG4gICAgICAgICAgICAgICAgLy8gTGVmdC1MZWZ0IGNhc2VcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JpZ2h0Um90YXRlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVNYXhBZnRlclJpZ2h0Um90YXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBMZWZ0LVJpZ2h0IGNhc2VcclxuICAgICAgICAgICAgICAgIGxlZnQuX2xlZnRSb3RhdGUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JpZ2h0Um90YXRlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVNYXhBZnRlclJpZ2h0Um90YXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaGVpZ2h0KHRoaXMucmlnaHQpID49IDIgKyBoZWlnaHQodGhpcy5sZWZ0KSkge1xyXG4gICAgICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLnJpZ2h0O1xyXG4gICAgICAgICAgICBpZiAoaGVpZ2h0KHJpZ2h0LnJpZ2h0KSA+PSBoZWlnaHQocmlnaHQubGVmdCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFJpZ2h0LVJpZ2h0IGNhc2VcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xlZnRSb3RhdGUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZU1heEFmdGVyTGVmdFJvdGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gUmlnaHQtTGVmdCBjYXNlXHJcbiAgICAgICAgICAgICAgICByaWdodC5fcmlnaHRSb3RhdGUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xlZnRSb3RhdGUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZU1heEFmdGVyTGVmdFJvdGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE5vZGUucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcclxuICAgICAgICBpZiAocmVjb3JkLmxvdyA8IHRoaXMua2V5KSB7XHJcbiAgICAgICAgICAgIC8vIEluc2VydCBpbnRvIGxlZnQgc3VidHJlZVxyXG4gICAgICAgICAgICBpZiAodGhpcy5sZWZ0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGVmdCA9IG5ldyBOb2RlKHRoaXMuaW50ZXJ2YWxUcmVlLCByZWNvcmQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sZWZ0LnBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxlZnQuaW5zZXJ0KHJlY29yZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEluc2VydCBpbnRvIHJpZ2h0IHN1YnRyZWVcclxuICAgICAgICAgICAgaWYgKHRoaXMucmlnaHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yaWdodCA9IG5ldyBOb2RlKHRoaXMuaW50ZXJ2YWxUcmVlLCByZWNvcmQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yaWdodC5wYXJlbnQgPSB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yaWdodC5pbnNlcnQocmVjb3JkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBVcGRhdGUgdGhlIG1heCB2YWx1ZSBvZiB0aGlzIGFuY2VzdG9yIGlmIG5lZWRlZFxyXG4gICAgICAgIGlmICh0aGlzLm1heCA8IHJlY29yZC5oaWdoKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gcmVjb3JkLmhpZ2g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFVwZGF0ZSBoZWlnaHQgb2YgZWFjaCBub2RlXHJcbiAgICAgICAgdGhpcy51cGRhdGVIZWlnaHQoKTtcclxuICAgICAgICAvLyBSZWJhbGFuY2UgdGhlIHRyZWUgdG8gZW5zdXJlIGFsbCBvcGVyYXRpb25zIGFyZSBleGVjdXRlZCBpbiBPKGxvZ24pIHRpbWUuIFRoaXMgaXMgZXNwZWNpYWxseVxyXG4gICAgICAgIC8vIGltcG9ydGFudCBpbiBzZWFyY2hpbmcsIGFzIHRoZSB0cmVlIGhhcyBhIGhpZ2ggY2hhbmNlIG9mIGRlZ2VuZXJhdGluZyB3aXRob3V0IHRoZSByZWJhbGFuY2luZ1xyXG4gICAgICAgIHRoaXMuX3JlYmFsYW5jZSgpO1xyXG4gICAgfTtcclxuICAgIE5vZGUucHJvdG90eXBlLl9nZXRPdmVybGFwcGluZ1JlY29yZHMgPSBmdW5jdGlvbiAoY3VycmVudE5vZGUsIGxvdywgaGlnaCkge1xyXG4gICAgICAgIGlmIChjdXJyZW50Tm9kZS5rZXkgPD0gaGlnaCAmJiBsb3cgPD0gY3VycmVudE5vZGUuZ2V0Tm9kZUhpZ2goKSkge1xyXG4gICAgICAgICAgICAvLyBOb2RlcyBhcmUgb3ZlcmxhcHBpbmcsIGNoZWNrIGlmIGluZGl2aWR1YWwgcmVjb3JkcyBpbiB0aGUgbm9kZSBhcmUgb3ZlcmxhcHBpbmdcclxuICAgICAgICAgICAgdmFyIHRlbXBSZXN1bHRzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3VycmVudE5vZGUucmVjb3Jkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlLnJlY29yZHNbaV0uaGlnaCA+PSBsb3cpIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wUmVzdWx0cy5wdXNoKGN1cnJlbnROb2RlLnJlY29yZHNbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0ZW1wUmVzdWx0cztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfTtcclxuICAgIE5vZGUucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uIChsb3csIGhpZ2gpIHtcclxuICAgICAgICAvLyBEb24ndCBzZWFyY2ggbm9kZXMgdGhhdCBkb24ndCBleGlzdFxyXG4gICAgICAgIGlmICh0aGlzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbGVmdFNlYXJjaCA9IFtdO1xyXG4gICAgICAgIHZhciBvd25TZWFyY2ggPSBbXTtcclxuICAgICAgICB2YXIgcmlnaHRTZWFyY2ggPSBbXTtcclxuICAgICAgICAvLyBJZiBpbnRlcnZhbCBpcyB0byB0aGUgcmlnaHQgb2YgdGhlIHJpZ2h0bW9zdCBwb2ludCBvZiBhbnkgaW50ZXJ2YWwgaW4gdGhpcyBub2RlIGFuZCBhbGwgaXRzXHJcbiAgICAgICAgLy8gY2hpbGRyZW4sIHRoZXJlIHdvbid0IGJlIGFueSBtYXRjaGVzXHJcbiAgICAgICAgaWYgKGxvdyA+IHRoaXMubWF4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU2VhcmNoIGxlZnQgY2hpbGRyZW5cclxuICAgICAgICBpZiAodGhpcy5sZWZ0ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5sZWZ0Lm1heCA+PSBsb3cpIHtcclxuICAgICAgICAgICAgbGVmdFNlYXJjaCA9IHRoaXMubGVmdC5zZWFyY2gobG93LCBoaWdoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2hlY2sgdGhpcyBub2RlXHJcbiAgICAgICAgb3duU2VhcmNoID0gdGhpcy5fZ2V0T3ZlcmxhcHBpbmdSZWNvcmRzKHRoaXMsIGxvdywgaGlnaCk7XHJcbiAgICAgICAgLy8gSWYgaW50ZXJ2YWwgaXMgdG8gdGhlIGxlZnQgb2YgdGhlIHN0YXJ0IG9mIHRoaXMgaW50ZXJ2YWwsIHRoZW4gaXQgY2FuJ3QgYmUgaW4gYW55IGNoaWxkIHRvXHJcbiAgICAgICAgLy8gdGhlIHJpZ2h0XHJcbiAgICAgICAgaWYgKGhpZ2ggPCB0aGlzLmtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbGVmdFNlYXJjaC5jb25jYXQob3duU2VhcmNoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBzZWFyY2ggcmlnaHQgY2hpbGRyZW5cclxuICAgICAgICBpZiAodGhpcy5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJpZ2h0U2VhcmNoID0gdGhpcy5yaWdodC5zZWFyY2gobG93LCBoaWdoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmV0dXJuIGFjY3VtdWxhdGVkIHJlc3VsdHMsIGlmIGFueVxyXG4gICAgICAgIHJldHVybiBsZWZ0U2VhcmNoLmNvbmNhdChvd25TZWFyY2gsIHJpZ2h0U2VhcmNoKTtcclxuICAgIH07XHJcbiAgICAvLyBTZWFyY2hlcyBmb3IgYSBub2RlIGJ5IGEgYGtleWAgdmFsdWVcclxuICAgIE5vZGUucHJvdG90eXBlLnNlYXJjaEV4aXN0aW5nID0gZnVuY3Rpb24gKGxvdykge1xyXG4gICAgICAgIGlmICh0aGlzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMua2V5ID09PSBsb3cpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxvdyA8IHRoaXMua2V5KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxlZnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5zZWFyY2hFeGlzdGluZyhsb3cpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yaWdodC5zZWFyY2hFeGlzdGluZyhsb3cpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9O1xyXG4gICAgLy8gUmV0dXJucyB0aGUgc21hbGxlc3Qgbm9kZSBvZiB0aGUgc3VidHJlZVxyXG4gICAgTm9kZS5wcm90b3R5cGUuX21pblZhbHVlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmxlZnQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQuX21pblZhbHVlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE5vZGUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgIGlmIChub2RlLmtleSA8IHRoaXMua2V5KSB7XHJcbiAgICAgICAgICAgIC8vIE5vZGUgdG8gYmUgcmVtb3ZlZCBpcyBvbiB0aGUgbGVmdCBzaWRlXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxlZnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdC5yZW1vdmUobm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG5vZGUua2V5ID4gdGhpcy5rZXkpIHtcclxuICAgICAgICAgICAgLy8gTm9kZSB0byBiZSByZW1vdmVkIGlzIG9uIHRoZSByaWdodCBzaWRlXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJpZ2h0LnJlbW92ZShub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxlZnQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vZGUgaGFzIHR3byBjaGlsZHJlblxyXG4gICAgICAgICAgICAgICAgdmFyIG1pblZhbHVlID0gdGhpcy5yaWdodC5fbWluVmFsdWUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMua2V5ID0gbWluVmFsdWUua2V5O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvcmRzID0gbWluVmFsdWUucmVjb3JkcztcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJpZ2h0LnJlbW92ZSh0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChwYXJlbnQubGVmdCA9PT0gdGhpcykge1xyXG4gICAgICAgICAgICAgICAgLy8gT25lIGNoaWxkIG9yIG5vIGNoaWxkIGNhc2Ugb24gbGVmdCBzaWRlXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmxlZnQgPSB0aGlzLnJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmlnaHQucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmxlZnQgPSB0aGlzLmxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubGVmdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGVmdC5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcGFyZW50LnVwZGF0ZU1heE9mUGFyZW50cygpO1xyXG4gICAgICAgICAgICAgICAgcGFyZW50LnVwZGF0ZUhlaWdodCgpO1xyXG4gICAgICAgICAgICAgICAgcGFyZW50Ll9yZWJhbGFuY2UoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcmVudC5yaWdodCA9PT0gdGhpcykge1xyXG4gICAgICAgICAgICAgICAgLy8gT25lIGNoaWxkIG9yIG5vIGNoaWxkIGNhc2Ugb24gcmlnaHQgc2lkZVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5yaWdodCA9IHRoaXMucmlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yaWdodC5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQucmlnaHQgPSB0aGlzLmxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubGVmdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGVmdC5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcGFyZW50LnVwZGF0ZU1heE9mUGFyZW50cygpO1xyXG4gICAgICAgICAgICAgICAgcGFyZW50LnVwZGF0ZUhlaWdodCgpO1xyXG4gICAgICAgICAgICAgICAgcGFyZW50Ll9yZWJhbGFuY2UoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBOb2RlO1xyXG59KCkpO1xyXG5leHBvcnRzLk5vZGUgPSBOb2RlO1xyXG52YXIgSW50ZXJ2YWxUcmVlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSW50ZXJ2YWxUcmVlKCkge1xyXG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xyXG4gICAgfVxyXG4gICAgSW50ZXJ2YWxUcmVlLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAocmVjb3JkKSB7XHJcbiAgICAgICAgaWYgKHJlY29yZC5sb3cgPiByZWNvcmQuaGlnaCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Bsb3dgIHZhbHVlIG11c3QgYmUgbG93ZXIgb3IgZXF1YWwgdG8gYGhpZ2hgIHZhbHVlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnJvb3QgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAvLyBCYXNlIGNhc2U6IFRyZWUgaXMgZW1wdHksIG5ldyBub2RlIGJlY29tZXMgcm9vdFxyXG4gICAgICAgICAgICB0aGlzLnJvb3QgPSBuZXcgTm9kZSh0aGlzLCByZWNvcmQpO1xyXG4gICAgICAgICAgICB0aGlzLmNvdW50Kys7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBjaGVjayBpZiBub2RlIGFscmVhZHkgZXhpc3RzIHdpdGggdGhlIHNhbWUga2V5XHJcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5yb290LnNlYXJjaEV4aXN0aW5nKHJlY29yZC5sb3cpO1xyXG4gICAgICAgICAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGUgcmVjb3JkcyBpbiB0aGlzIG5vZGUgaWYgdGhlcmUgYWxyZWFkeSBpcyB0aGUgb25lIHdpdGggc2FtZSBsb3csIGhpZ2gsIGRhdGFcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5yZWNvcmRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2FtZShub2RlLnJlY29yZHNbaV0sIHJlY29yZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyByZWNvcmQgaXMgc2FtZSBhcyB0aGUgb25lIHdlJ3JlIHRyeWluZyB0byBpbnNlcnQ7IHJldHVybiBmYWxzZSB0byBpbmRpY2F0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub3RoaW5nIGhhcyBiZWVuIGluc2VydGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIHJlY29yZCB0byB0aGUgbm9kZVxyXG4gICAgICAgICAgICAgICAgbm9kZS5yZWNvcmRzLnB1c2gocmVjb3JkKTtcclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBtYXggb2YgdGhlIG5vZGUgYW5kIGl0cyBwYXJlbnRzIGlmIG5lY2Vzc2FyeVxyXG4gICAgICAgICAgICAgICAgaWYgKHJlY29yZC5oaWdoID4gbm9kZS5tYXgpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLm1heCA9IHJlY29yZC5oaWdoO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudC51cGRhdGVNYXhPZlBhcmVudHMoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50Kys7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vZGUgd2l0aCB0aGlzIGtleSBkb2Vzbid0IGFscmVhZHkgZXhpc3QuIENhbGwgaW5zZXJ0IGZ1bmN0aW9uIG9uIHJvb3QncyBub2RlXHJcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3QuaW5zZXJ0KHJlY29yZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50Kys7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBJbnRlcnZhbFRyZWUucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uIChsb3csIGhpZ2gpIHtcclxuICAgICAgICBpZiAodGhpcy5yb290ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgLy8gVHJlZSBpcyBlbXB0eTsgcmV0dXJuIGVtcHR5IGFycmF5XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvb3Quc2VhcmNoKGxvdywgaGlnaCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEludGVydmFsVHJlZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHJlY29yZCkge1xyXG4gICAgICAgIGlmICh0aGlzLnJvb3QgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAvLyBUcmVlIGlzIGVtcHR5OyBub3RoaW5nIHRvIHJlbW92ZVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMucm9vdC5zZWFyY2hFeGlzdGluZyhyZWNvcmQubG93KTtcclxuICAgICAgICAgICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUucmVjb3Jkcy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlZFJlY29yZCA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgIC8vIE5vZGUgd2l0aCB0aGlzIGtleSBoYXMgMiBvciBtb3JlIHJlY29yZHMuIEZpbmQgdGhlIG9uZSB3ZSBuZWVkIGFuZCByZW1vdmUgaXRcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5yZWNvcmRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2FtZShub2RlLnJlY29yZHNbaV0sIHJlY29yZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZFJlY29yZCA9IG5vZGUucmVjb3Jkc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5yZWNvcmRzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZWRSZWNvcmQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVkUmVjb3JkID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBtYXggb2YgdGhhdCBub2RlIGFuZCBpdHMgcGFyZW50cyBpZiBuZWNlc3NhcnlcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3JkLmhpZ2ggPT09IG5vZGUubWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlSGlnaCA9IG5vZGUuZ2V0Tm9kZUhpZ2goKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubGVmdCAhPT0gdW5kZWZpbmVkICYmIG5vZGUucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5tYXggPSBNYXRoLm1heChNYXRoLm1heChub2RlLmxlZnQubWF4LCBub2RlLnJpZ2h0Lm1heCksIG5vZGVIaWdoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlLmxlZnQgIT09IHVuZGVmaW5lZCAmJiBub2RlLnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubWF4ID0gTWF0aC5tYXgobm9kZS5sZWZ0Lm1heCwgbm9kZUhpZ2gpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUubGVmdCA9PT0gdW5kZWZpbmVkICYmIG5vZGUucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5tYXggPSBNYXRoLm1heChub2RlLnJpZ2h0Lm1heCwgbm9kZUhpZ2gpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5tYXggPSBub2RlSGlnaDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50LnVwZGF0ZU1heE9mUGFyZW50cygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY291bnQtLTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChub2RlLnJlY29yZHMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBOb2RlIHdpdGggdGhpcyBrZXkgaGFzIG9ubHkgMSByZWNvcmQuIENoZWNrIGlmIHRoZSByZW1haW5pbmcgcmVjb3JkIGluIHRoaXMgbm9kZSBpc1xyXG4gICAgICAgICAgICAgICAgLy8gYWN0dWFsbHkgdGhlIG9uZSB3ZSB3YW50IHRvIHJlbW92ZVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzU2FtZShub2RlLnJlY29yZHNbMF0sIHJlY29yZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcmVtYWluaW5nIHJlY29yZCBpcyB0aGUgb25lIHdlIHdhbnQgdG8gcmVtb3ZlLiBSZW1vdmUgdGhlIHdob2xlIG5vZGUgZnJvbSB0aGUgdHJlZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJvb3Qua2V5ID09PSBub2RlLmtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSdyZSByZW1vdmluZyB0aGUgcm9vdCBlbGVtZW50LiBDcmVhdGUgYSBkdW1teSBub2RlIHRoYXQgd2lsbCB0ZW1wb3JhcmlseSB0YWtlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJvb3QncyBwYXJlbnQgcm9sZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm9vdFBhcmVudCA9IG5ldyBOb2RlKHRoaXMsIHsgbG93OiByZWNvcmQubG93LCBoaWdoOiByZWNvcmQubG93IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByb290UGFyZW50LmxlZnQgPSB0aGlzLnJvb3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucm9vdC5wYXJlbnQgPSByb290UGFyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlZE5vZGUgPSB0aGlzLnJvb3QucmVtb3ZlKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJvb3QgPSByb290UGFyZW50LmxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJvb3QgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yb290LnBhcmVudCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVtb3ZlZE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWROb2RlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3VudC0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZW1vdmVkTm9kZSA9IHRoaXMucm9vdC5yZW1vdmUobm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZW1vdmVkTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZE5vZGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvdW50LS07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZW1haW5pbmcgcmVjb3JkIGlzIG5vdCB0aGUgb25lIHdlIHdhbnQgdG8gcmVtb3ZlXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gTm8gcmVjb3JkcyBhdCBhbGwgaW4gdGhpcyBub2RlPyEgU2hvdWxkbid0IGhhcHBlblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEludGVydmFsVHJlZS5wcm90b3R5cGUuaW5PcmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEluT3JkZXIodGhpcy5yb290KTtcclxuICAgIH07XHJcbiAgICBJbnRlcnZhbFRyZWUucHJvdG90eXBlLnByZU9yZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJlT3JkZXIodGhpcy5yb290KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gSW50ZXJ2YWxUcmVlO1xyXG59KCkpO1xyXG5leHBvcnRzLkludGVydmFsVHJlZSA9IEludGVydmFsVHJlZTtcclxudmFyIERhdGFJbnRlcnZhbFRyZWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEYXRhSW50ZXJ2YWxUcmVlKCkge1xyXG4gICAgICAgIHRoaXMudHJlZSA9IG5ldyBJbnRlcnZhbFRyZWUoKTtcclxuICAgIH1cclxuICAgIERhdGFJbnRlcnZhbFRyZWUucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChsb3csIGhpZ2gsIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmVlLmluc2VydCh7IGxvdzogbG93LCBoaWdoOiBoaWdoLCBkYXRhOiBkYXRhIH0pO1xyXG4gICAgfTtcclxuICAgIERhdGFJbnRlcnZhbFRyZWUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChsb3csIGhpZ2gsIGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmVlLnJlbW92ZSh7IGxvdzogbG93LCBoaWdoOiBoaWdoLCBkYXRhOiBkYXRhIH0pO1xyXG4gICAgfTtcclxuICAgIERhdGFJbnRlcnZhbFRyZWUucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uIChsb3csIGhpZ2gpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmVlLnNlYXJjaChsb3csIGhpZ2gpLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gdi5kYXRhOyB9KTtcclxuICAgIH07XHJcbiAgICBEYXRhSW50ZXJ2YWxUcmVlLnByb3RvdHlwZS5pbk9yZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRyZWUuaW5PcmRlcigpO1xyXG4gICAgfTtcclxuICAgIERhdGFJbnRlcnZhbFRyZWUucHJvdG90eXBlLnByZU9yZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRyZWUucHJlT3JkZXIoKTtcclxuICAgIH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0YUludGVydmFsVHJlZS5wcm90b3R5cGUsIFwiY291bnRcIiwge1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50cmVlLmNvdW50O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIERhdGFJbnRlcnZhbFRyZWU7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IERhdGFJbnRlcnZhbFRyZWU7XHJcbnZhciBJbk9yZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSW5PcmRlcihzdGFydE5vZGUpIHtcclxuICAgICAgICB0aGlzLnN0YWNrID0gW107XHJcbiAgICAgICAgaWYgKHN0YXJ0Tm9kZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHVzaChzdGFydE5vZGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIEluT3JkZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gV2lsbCBvbmx5IGhhcHBlbiBpZiBzdGFjayBpcyBlbXB0eSBhbmQgcG9wIGlzIGNhbGxlZFxyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnROb2RlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGRvbmU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBQcm9jZXNzIHRoaXMgbm9kZVxyXG4gICAgICAgIGlmICh0aGlzLmkgPCB0aGlzLmN1cnJlbnROb2RlLnJlY29yZHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBkb25lOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmN1cnJlbnROb2RlLnJlY29yZHNbdGhpcy5pKytdLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50Tm9kZS5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHVzaCh0aGlzLmN1cnJlbnROb2RlLnJpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE1pZ2h0IHBvcCB0aGUgbGFzdCBhbmQgc2V0IHRoaXMuY3VycmVudE5vZGUgPSB1bmRlZmluZWRcclxuICAgICAgICAgICAgdGhpcy5wb3AoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dCgpO1xyXG4gICAgfTtcclxuICAgIEluT3JkZXIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgIHRoaXMuY3VycmVudE5vZGUgPSBub2RlO1xyXG4gICAgICAgIHRoaXMuaSA9IDA7XHJcbiAgICAgICAgd2hpbGUgKHRoaXMuY3VycmVudE5vZGUubGVmdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLmN1cnJlbnROb2RlKTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50Tm9kZSA9IHRoaXMuY3VycmVudE5vZGUubGVmdDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSW5PcmRlci5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY3VycmVudE5vZGUgPSB0aGlzLnN0YWNrLnBvcCgpO1xyXG4gICAgICAgIHRoaXMuaSA9IDA7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEluT3JkZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuSW5PcmRlciA9IEluT3JkZXI7XHJcbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICBJbk9yZGVyLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcclxufVxyXG52YXIgUHJlT3JkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQcmVPcmRlcihzdGFydE5vZGUpIHtcclxuICAgICAgICB0aGlzLnN0YWNrID0gW107XHJcbiAgICAgICAgdGhpcy5pID0gMDtcclxuICAgICAgICB0aGlzLmN1cnJlbnROb2RlID0gc3RhcnROb2RlO1xyXG4gICAgfVxyXG4gICAgUHJlT3JkZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gV2lsbCBvbmx5IGhhcHBlbiBpZiBzdGFjayBpcyBlbXB0eSBhbmQgcG9wIGlzIGNhbGxlZCxcclxuICAgICAgICAvLyB3aGljaCBvbmx5IGhhcHBlbnMgaWYgdGhlcmUgaXMgbm8gcmlnaHQgbm9kZSAoaS5lIHdlIGFyZSBkb25lKVxyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnROb2RlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGRvbmU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBQcm9jZXNzIHRoaXMgbm9kZVxyXG4gICAgICAgIGlmICh0aGlzLmkgPCB0aGlzLmN1cnJlbnROb2RlLnJlY29yZHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBkb25lOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmN1cnJlbnROb2RlLnJlY29yZHNbdGhpcy5pKytdLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50Tm9kZS5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHVzaCh0aGlzLmN1cnJlbnROb2RlLnJpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudE5vZGUubGVmdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHVzaCh0aGlzLmN1cnJlbnROb2RlLmxlZnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBvcCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5leHQoKTtcclxuICAgIH07XHJcbiAgICBQcmVPcmRlci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICAgICAgdGhpcy5zdGFjay5wdXNoKG5vZGUpO1xyXG4gICAgfTtcclxuICAgIFByZU9yZGVyLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50Tm9kZSA9IHRoaXMuc3RhY2sucG9wKCk7XHJcbiAgICAgICAgdGhpcy5pID0gMDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUHJlT3JkZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuUHJlT3JkZXIgPSBQcmVPcmRlcjtcclxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcclxuICAgIFByZU9yZGVyLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvVXNlcnMvZ25pZGFuL3NyYy93b3JrL3RydWZmbGUvbm9kZV9tb2R1bGVzL25vZGUtaW50ZXJ2YWwtdHJlZS9saWIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIsIGNvbXBhcmUsIGNvbXBhcmVDb250ZXh0KSB7XG4gIHZhciByZXQgPSBjb21wYXJlID8gY29tcGFyZS5jYWxsKGNvbXBhcmVDb250ZXh0LCBvYmpBLCBvYmpCKSA6IHZvaWQgMDtcblxuICBpZiAocmV0ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gISFyZXQ7XG4gIH1cblxuICBpZiAob2JqQSA9PT0gb2JqQikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmpBICE9PSBcIm9iamVjdFwiIHx8ICFvYmpBIHx8IHR5cGVvZiBvYmpCICE9PSBcIm9iamVjdFwiIHx8ICFvYmpCKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKG9iakIpO1xuXG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBiSGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmJpbmQob2JqQik7XG5cbiAgLy8gVGVzdCBmb3IgQSdzIGtleXMgZGlmZmVyZW50IGZyb20gQi5cbiAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwga2V5c0EubGVuZ3RoOyBpZHgrKykge1xuICAgIHZhciBrZXkgPSBrZXlzQVtpZHhdO1xuXG4gICAgaWYgKCFiSGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZUEgPSBvYmpBW2tleV07XG4gICAgdmFyIHZhbHVlQiA9IG9iakJba2V5XTtcblxuICAgIHJldCA9IGNvbXBhcmUgPyBjb21wYXJlLmNhbGwoY29tcGFyZUNvbnRleHQsIHZhbHVlQSwgdmFsdWVCLCBrZXkpIDogdm9pZCAwO1xuXG4gICAgaWYgKHJldCA9PT0gZmFsc2UgfHwgKHJldCA9PT0gdm9pZCAwICYmIHZhbHVlQSAhPT0gdmFsdWVCKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC9Vc2Vycy9nbmlkYW4vc3JjL3dvcmsvdHJ1ZmZsZS9ub2RlX21vZHVsZXMvc2hhbGxvd2VxdWFsL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSA0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJmYXN0LWxldmVuc2h0ZWluXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiZmFzdC1sZXZlbnNodGVpblwiXG4vLyBtb2R1bGUgaWQgPSA0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBTZW1WZXI7XG5cbi8vIFRoZSBkZWJ1ZyBmdW5jdGlvbiBpcyBleGNsdWRlZCBlbnRpcmVseSBmcm9tIHRoZSBtaW5pZmllZCB2ZXJzaW9uLlxuLyogbm9taW4gKi8gdmFyIGRlYnVnO1xuLyogbm9taW4gKi8gaWYgKHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJlxuICAgIC8qIG5vbWluICovIHByb2Nlc3MuZW52ICYmXG4gICAgLyogbm9taW4gKi8gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyAmJlxuICAgIC8qIG5vbWluICovIC9cXGJzZW12ZXJcXGIvaS50ZXN0KHByb2Nlc3MuZW52Lk5PREVfREVCVUcpKVxuICAvKiBub21pbiAqLyBkZWJ1ZyA9IGZ1bmN0aW9uKCkge1xuICAgIC8qIG5vbWluICovIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICAvKiBub21pbiAqLyBhcmdzLnVuc2hpZnQoJ1NFTVZFUicpO1xuICAgIC8qIG5vbWluICovIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuICAgIC8qIG5vbWluICovIH07XG4vKiBub21pbiAqLyBlbHNlXG4gIC8qIG5vbWluICovIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcblxuLy8gTm90ZTogdGhpcyBpcyB0aGUgc2VtdmVyLm9yZyB2ZXJzaW9uIG9mIHRoZSBzcGVjIHRoYXQgaXQgaW1wbGVtZW50c1xuLy8gTm90IG5lY2Vzc2FyaWx5IHRoZSBwYWNrYWdlIHZlcnNpb24gb2YgdGhpcyBjb2RlLlxuZXhwb3J0cy5TRU1WRVJfU1BFQ19WRVJTSU9OID0gJzIuMC4wJztcblxudmFyIE1BWF9MRU5HVEggPSAyNTY7XG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSIHx8IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8vIE1heCBzYWZlIHNlZ21lbnQgbGVuZ3RoIGZvciBjb2VyY2lvbi5cbnZhciBNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIID0gMTY7XG5cbi8vIFRoZSBhY3R1YWwgcmVnZXhwcyBnbyBvbiBleHBvcnRzLnJlXG52YXIgcmUgPSBleHBvcnRzLnJlID0gW107XG52YXIgc3JjID0gZXhwb3J0cy5zcmMgPSBbXTtcbnZhciBSID0gMDtcblxuLy8gVGhlIGZvbGxvd2luZyBSZWd1bGFyIEV4cHJlc3Npb25zIGNhbiBiZSB1c2VkIGZvciB0b2tlbml6aW5nLFxuLy8gdmFsaWRhdGluZywgYW5kIHBhcnNpbmcgU2VtVmVyIHZlcnNpb24gc3RyaW5ncy5cblxuLy8gIyMgTnVtZXJpYyBJZGVudGlmaWVyXG4vLyBBIHNpbmdsZSBgMGAsIG9yIGEgbm9uLXplcm8gZGlnaXQgZm9sbG93ZWQgYnkgemVybyBvciBtb3JlIGRpZ2l0cy5cblxudmFyIE5VTUVSSUNJREVOVElGSUVSID0gUisrO1xuc3JjW05VTUVSSUNJREVOVElGSUVSXSA9ICcwfFsxLTldXFxcXGQqJztcbnZhciBOVU1FUklDSURFTlRJRklFUkxPT1NFID0gUisrO1xuc3JjW05VTUVSSUNJREVOVElGSUVSTE9PU0VdID0gJ1swLTldKyc7XG5cblxuLy8gIyMgTm9uLW51bWVyaWMgSWRlbnRpZmllclxuLy8gWmVybyBvciBtb3JlIGRpZ2l0cywgZm9sbG93ZWQgYnkgYSBsZXR0ZXIgb3IgaHlwaGVuLCBhbmQgdGhlbiB6ZXJvIG9yXG4vLyBtb3JlIGxldHRlcnMsIGRpZ2l0cywgb3IgaHlwaGVucy5cblxudmFyIE5PTk5VTUVSSUNJREVOVElGSUVSID0gUisrO1xuc3JjW05PTk5VTUVSSUNJREVOVElGSUVSXSA9ICdcXFxcZCpbYS16QS1aLV1bYS16QS1aMC05LV0qJztcblxuXG4vLyAjIyBNYWluIFZlcnNpb25cbi8vIFRocmVlIGRvdC1zZXBhcmF0ZWQgbnVtZXJpYyBpZGVudGlmaWVycy5cblxudmFyIE1BSU5WRVJTSU9OID0gUisrO1xuc3JjW01BSU5WRVJTSU9OXSA9ICcoJyArIHNyY1tOVU1FUklDSURFTlRJRklFUl0gKyAnKVxcXFwuJyArXG4gICAgICAgICAgICAgICAgICAgJygnICsgc3JjW05VTUVSSUNJREVOVElGSUVSXSArICcpXFxcXC4nICtcbiAgICAgICAgICAgICAgICAgICAnKCcgKyBzcmNbTlVNRVJJQ0lERU5USUZJRVJdICsgJyknO1xuXG52YXIgTUFJTlZFUlNJT05MT09TRSA9IFIrKztcbnNyY1tNQUlOVkVSU0lPTkxPT1NFXSA9ICcoJyArIHNyY1tOVU1FUklDSURFTlRJRklFUkxPT1NFXSArICcpXFxcXC4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcoJyArIHNyY1tOVU1FUklDSURFTlRJRklFUkxPT1NFXSArICcpXFxcXC4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcoJyArIHNyY1tOVU1FUklDSURFTlRJRklFUkxPT1NFXSArICcpJztcblxuLy8gIyMgUHJlLXJlbGVhc2UgVmVyc2lvbiBJZGVudGlmaWVyXG4vLyBBIG51bWVyaWMgaWRlbnRpZmllciwgb3IgYSBub24tbnVtZXJpYyBpZGVudGlmaWVyLlxuXG52YXIgUFJFUkVMRUFTRUlERU5USUZJRVIgPSBSKys7XG5zcmNbUFJFUkVMRUFTRUlERU5USUZJRVJdID0gJyg/OicgKyBzcmNbTlVNRVJJQ0lERU5USUZJRVJdICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnfCcgKyBzcmNbTk9OTlVNRVJJQ0lERU5USUZJRVJdICsgJyknO1xuXG52YXIgUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRSA9IFIrKztcbnNyY1tQUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXSA9ICcoPzonICsgc3JjW05VTUVSSUNJREVOVElGSUVSTE9PU0VdICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd8JyArIHNyY1tOT05OVU1FUklDSURFTlRJRklFUl0gKyAnKSc7XG5cblxuLy8gIyMgUHJlLXJlbGVhc2UgVmVyc2lvblxuLy8gSHlwaGVuLCBmb2xsb3dlZCBieSBvbmUgb3IgbW9yZSBkb3Qtc2VwYXJhdGVkIHByZS1yZWxlYXNlIHZlcnNpb25cbi8vIGlkZW50aWZpZXJzLlxuXG52YXIgUFJFUkVMRUFTRSA9IFIrKztcbnNyY1tQUkVSRUxFQVNFXSA9ICcoPzotKCcgKyBzcmNbUFJFUkVMRUFTRUlERU5USUZJRVJdICtcbiAgICAgICAgICAgICAgICAgICcoPzpcXFxcLicgKyBzcmNbUFJFUkVMRUFTRUlERU5USUZJRVJdICsgJykqKSknO1xuXG52YXIgUFJFUkVMRUFTRUxPT1NFID0gUisrO1xuc3JjW1BSRVJFTEVBU0VMT09TRV0gPSAnKD86LT8oJyArIHNyY1tQUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXSArXG4gICAgICAgICAgICAgICAgICAgICAgICcoPzpcXFxcLicgKyBzcmNbUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRV0gKyAnKSopKSc7XG5cbi8vICMjIEJ1aWxkIE1ldGFkYXRhIElkZW50aWZpZXJcbi8vIEFueSBjb21iaW5hdGlvbiBvZiBkaWdpdHMsIGxldHRlcnMsIG9yIGh5cGhlbnMuXG5cbnZhciBCVUlMRElERU5USUZJRVIgPSBSKys7XG5zcmNbQlVJTERJREVOVElGSUVSXSA9ICdbMC05QS1aYS16LV0rJztcblxuLy8gIyMgQnVpbGQgTWV0YWRhdGFcbi8vIFBsdXMgc2lnbiwgZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgcGVyaW9kLXNlcGFyYXRlZCBidWlsZCBtZXRhZGF0YVxuLy8gaWRlbnRpZmllcnMuXG5cbnZhciBCVUlMRCA9IFIrKztcbnNyY1tCVUlMRF0gPSAnKD86XFxcXCsoJyArIHNyY1tCVUlMRElERU5USUZJRVJdICtcbiAgICAgICAgICAgICAnKD86XFxcXC4nICsgc3JjW0JVSUxESURFTlRJRklFUl0gKyAnKSopKSc7XG5cblxuLy8gIyMgRnVsbCBWZXJzaW9uIFN0cmluZ1xuLy8gQSBtYWluIHZlcnNpb24sIGZvbGxvd2VkIG9wdGlvbmFsbHkgYnkgYSBwcmUtcmVsZWFzZSB2ZXJzaW9uIGFuZFxuLy8gYnVpbGQgbWV0YWRhdGEuXG5cbi8vIE5vdGUgdGhhdCB0aGUgb25seSBtYWpvciwgbWlub3IsIHBhdGNoLCBhbmQgcHJlLXJlbGVhc2Ugc2VjdGlvbnMgb2Zcbi8vIHRoZSB2ZXJzaW9uIHN0cmluZyBhcmUgY2FwdHVyaW5nIGdyb3Vwcy4gIFRoZSBidWlsZCBtZXRhZGF0YSBpcyBub3QgYVxuLy8gY2FwdHVyaW5nIGdyb3VwLCBiZWNhdXNlIGl0IHNob3VsZCBub3QgZXZlciBiZSB1c2VkIGluIHZlcnNpb25cbi8vIGNvbXBhcmlzb24uXG5cbnZhciBGVUxMID0gUisrO1xudmFyIEZVTExQTEFJTiA9ICd2PycgKyBzcmNbTUFJTlZFUlNJT05dICtcbiAgICAgICAgICAgICAgICBzcmNbUFJFUkVMRUFTRV0gKyAnPycgK1xuICAgICAgICAgICAgICAgIHNyY1tCVUlMRF0gKyAnPyc7XG5cbnNyY1tGVUxMXSA9ICdeJyArIEZVTExQTEFJTiArICckJztcblxuLy8gbGlrZSBmdWxsLCBidXQgYWxsb3dzIHYxLjIuMyBhbmQgPTEuMi4zLCB3aGljaCBwZW9wbGUgZG8gc29tZXRpbWVzLlxuLy8gYWxzbywgMS4wLjBhbHBoYTEgKHByZXJlbGVhc2Ugd2l0aG91dCB0aGUgaHlwaGVuKSB3aGljaCBpcyBwcmV0dHlcbi8vIGNvbW1vbiBpbiB0aGUgbnBtIHJlZ2lzdHJ5LlxudmFyIExPT1NFUExBSU4gPSAnW3Y9XFxcXHNdKicgKyBzcmNbTUFJTlZFUlNJT05MT09TRV0gK1xuICAgICAgICAgICAgICAgICBzcmNbUFJFUkVMRUFTRUxPT1NFXSArICc/JyArXG4gICAgICAgICAgICAgICAgIHNyY1tCVUlMRF0gKyAnPyc7XG5cbnZhciBMT09TRSA9IFIrKztcbnNyY1tMT09TRV0gPSAnXicgKyBMT09TRVBMQUlOICsgJyQnO1xuXG52YXIgR1RMVCA9IFIrKztcbnNyY1tHVExUXSA9ICcoKD86PHw+KT89PyknO1xuXG4vLyBTb21ldGhpbmcgbGlrZSBcIjIuKlwiIG9yIFwiMS4yLnhcIi5cbi8vIE5vdGUgdGhhdCBcIngueFwiIGlzIGEgdmFsaWQgeFJhbmdlIGlkZW50aWZlciwgbWVhbmluZyBcImFueSB2ZXJzaW9uXCJcbi8vIE9ubHkgdGhlIGZpcnN0IGl0ZW0gaXMgc3RyaWN0bHkgcmVxdWlyZWQuXG52YXIgWFJBTkdFSURFTlRJRklFUkxPT1NFID0gUisrO1xuc3JjW1hSQU5HRUlERU5USUZJRVJMT09TRV0gPSBzcmNbTlVNRVJJQ0lERU5USUZJRVJMT09TRV0gKyAnfHh8WHxcXFxcKic7XG52YXIgWFJBTkdFSURFTlRJRklFUiA9IFIrKztcbnNyY1tYUkFOR0VJREVOVElGSUVSXSA9IHNyY1tOVU1FUklDSURFTlRJRklFUl0gKyAnfHh8WHxcXFxcKic7XG5cbnZhciBYUkFOR0VQTEFJTiA9IFIrKztcbnNyY1tYUkFOR0VQTEFJTl0gPSAnW3Y9XFxcXHNdKignICsgc3JjW1hSQU5HRUlERU5USUZJRVJdICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAnKD86XFxcXC4oJyArIHNyY1tYUkFOR0VJREVOVElGSUVSXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgJyg/OlxcXFwuKCcgKyBzcmNbWFJBTkdFSURFTlRJRklFUl0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICcoPzonICsgc3JjW1BSRVJFTEVBU0VdICsgJyk/JyArXG4gICAgICAgICAgICAgICAgICAgc3JjW0JVSUxEXSArICc/JyArXG4gICAgICAgICAgICAgICAgICAgJyk/KT8nO1xuXG52YXIgWFJBTkdFUExBSU5MT09TRSA9IFIrKztcbnNyY1tYUkFOR0VQTEFJTkxPT1NFXSA9ICdbdj1cXFxcc10qKCcgKyBzcmNbWFJBTkdFSURFTlRJRklFUkxPT1NFXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKD86XFxcXC4oJyArIHNyY1tYUkFOR0VJREVOVElGSUVSTE9PU0VdICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcoPzpcXFxcLignICsgc3JjW1hSQU5HRUlERU5USUZJRVJMT09TRV0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyg/OicgKyBzcmNbUFJFUkVMRUFTRUxPT1NFXSArICcpPycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgc3JjW0JVSUxEXSArICc/JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKT8pPyc7XG5cbnZhciBYUkFOR0UgPSBSKys7XG5zcmNbWFJBTkdFXSA9ICdeJyArIHNyY1tHVExUXSArICdcXFxccyonICsgc3JjW1hSQU5HRVBMQUlOXSArICckJztcbnZhciBYUkFOR0VMT09TRSA9IFIrKztcbnNyY1tYUkFOR0VMT09TRV0gPSAnXicgKyBzcmNbR1RMVF0gKyAnXFxcXHMqJyArIHNyY1tYUkFOR0VQTEFJTkxPT1NFXSArICckJztcblxuLy8gQ29lcmNpb24uXG4vLyBFeHRyYWN0IGFueXRoaW5nIHRoYXQgY291bGQgY29uY2VpdmFibHkgYmUgYSBwYXJ0IG9mIGEgdmFsaWQgc2VtdmVyXG52YXIgQ09FUkNFID0gUisrO1xuc3JjW0NPRVJDRV0gPSAnKD86XnxbXlxcXFxkXSknICtcbiAgICAgICAgICAgICAgJyhcXFxcZHsxLCcgKyBNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIICsgJ30pJyArXG4gICAgICAgICAgICAgICcoPzpcXFxcLihcXFxcZHsxLCcgKyBNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIICsgJ30pKT8nICtcbiAgICAgICAgICAgICAgJyg/OlxcXFwuKFxcXFxkezEsJyArIE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEggKyAnfSkpPycgK1xuICAgICAgICAgICAgICAnKD86JHxbXlxcXFxkXSknO1xuXG4vLyBUaWxkZSByYW5nZXMuXG4vLyBNZWFuaW5nIGlzIFwicmVhc29uYWJseSBhdCBvciBncmVhdGVyIHRoYW5cIlxudmFyIExPTkVUSUxERSA9IFIrKztcbnNyY1tMT05FVElMREVdID0gJyg/On4+PyknO1xuXG52YXIgVElMREVUUklNID0gUisrO1xuc3JjW1RJTERFVFJJTV0gPSAnKFxcXFxzKiknICsgc3JjW0xPTkVUSUxERV0gKyAnXFxcXHMrJztcbnJlW1RJTERFVFJJTV0gPSBuZXcgUmVnRXhwKHNyY1tUSUxERVRSSU1dLCAnZycpO1xudmFyIHRpbGRlVHJpbVJlcGxhY2UgPSAnJDF+JztcblxudmFyIFRJTERFID0gUisrO1xuc3JjW1RJTERFXSA9ICdeJyArIHNyY1tMT05FVElMREVdICsgc3JjW1hSQU5HRVBMQUlOXSArICckJztcbnZhciBUSUxERUxPT1NFID0gUisrO1xuc3JjW1RJTERFTE9PU0VdID0gJ14nICsgc3JjW0xPTkVUSUxERV0gKyBzcmNbWFJBTkdFUExBSU5MT09TRV0gKyAnJCc7XG5cbi8vIENhcmV0IHJhbmdlcy5cbi8vIE1lYW5pbmcgaXMgXCJhdCBsZWFzdCBhbmQgYmFja3dhcmRzIGNvbXBhdGlibGUgd2l0aFwiXG52YXIgTE9ORUNBUkVUID0gUisrO1xuc3JjW0xPTkVDQVJFVF0gPSAnKD86XFxcXF4pJztcblxudmFyIENBUkVUVFJJTSA9IFIrKztcbnNyY1tDQVJFVFRSSU1dID0gJyhcXFxccyopJyArIHNyY1tMT05FQ0FSRVRdICsgJ1xcXFxzKyc7XG5yZVtDQVJFVFRSSU1dID0gbmV3IFJlZ0V4cChzcmNbQ0FSRVRUUklNXSwgJ2cnKTtcbnZhciBjYXJldFRyaW1SZXBsYWNlID0gJyQxXic7XG5cbnZhciBDQVJFVCA9IFIrKztcbnNyY1tDQVJFVF0gPSAnXicgKyBzcmNbTE9ORUNBUkVUXSArIHNyY1tYUkFOR0VQTEFJTl0gKyAnJCc7XG52YXIgQ0FSRVRMT09TRSA9IFIrKztcbnNyY1tDQVJFVExPT1NFXSA9ICdeJyArIHNyY1tMT05FQ0FSRVRdICsgc3JjW1hSQU5HRVBMQUlOTE9PU0VdICsgJyQnO1xuXG4vLyBBIHNpbXBsZSBndC9sdC9lcSB0aGluZywgb3IganVzdCBcIlwiIHRvIGluZGljYXRlIFwiYW55IHZlcnNpb25cIlxudmFyIENPTVBBUkFUT1JMT09TRSA9IFIrKztcbnNyY1tDT01QQVJBVE9STE9PU0VdID0gJ14nICsgc3JjW0dUTFRdICsgJ1xcXFxzKignICsgTE9PU0VQTEFJTiArICcpJHxeJCc7XG52YXIgQ09NUEFSQVRPUiA9IFIrKztcbnNyY1tDT01QQVJBVE9SXSA9ICdeJyArIHNyY1tHVExUXSArICdcXFxccyooJyArIEZVTExQTEFJTiArICcpJHxeJCc7XG5cblxuLy8gQW4gZXhwcmVzc2lvbiB0byBzdHJpcCBhbnkgd2hpdGVzcGFjZSBiZXR3ZWVuIHRoZSBndGx0IGFuZCB0aGUgdGhpbmdcbi8vIGl0IG1vZGlmaWVzLCBzbyB0aGF0IGA+IDEuMi4zYCA9PT4gYD4xLjIuM2BcbnZhciBDT01QQVJBVE9SVFJJTSA9IFIrKztcbnNyY1tDT01QQVJBVE9SVFJJTV0gPSAnKFxcXFxzKiknICsgc3JjW0dUTFRdICtcbiAgICAgICAgICAgICAgICAgICAgICAnXFxcXHMqKCcgKyBMT09TRVBMQUlOICsgJ3wnICsgc3JjW1hSQU5HRVBMQUlOXSArICcpJztcblxuLy8gdGhpcyBvbmUgaGFzIHRvIHVzZSB0aGUgL2cgZmxhZ1xucmVbQ09NUEFSQVRPUlRSSU1dID0gbmV3IFJlZ0V4cChzcmNbQ09NUEFSQVRPUlRSSU1dLCAnZycpO1xudmFyIGNvbXBhcmF0b3JUcmltUmVwbGFjZSA9ICckMSQyJDMnO1xuXG5cbi8vIFNvbWV0aGluZyBsaWtlIGAxLjIuMyAtIDEuMi40YFxuLy8gTm90ZSB0aGF0IHRoZXNlIGFsbCB1c2UgdGhlIGxvb3NlIGZvcm0sIGJlY2F1c2UgdGhleSdsbCBiZVxuLy8gY2hlY2tlZCBhZ2FpbnN0IGVpdGhlciB0aGUgc3RyaWN0IG9yIGxvb3NlIGNvbXBhcmF0b3IgZm9ybVxuLy8gbGF0ZXIuXG52YXIgSFlQSEVOUkFOR0UgPSBSKys7XG5zcmNbSFlQSEVOUkFOR0VdID0gJ15cXFxccyooJyArIHNyY1tYUkFOR0VQTEFJTl0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICdcXFxccystXFxcXHMrJyArXG4gICAgICAgICAgICAgICAgICAgJygnICsgc3JjW1hSQU5HRVBMQUlOXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgJ1xcXFxzKiQnO1xuXG52YXIgSFlQSEVOUkFOR0VMT09TRSA9IFIrKztcbnNyY1tIWVBIRU5SQU5HRUxPT1NFXSA9ICdeXFxcXHMqKCcgKyBzcmNbWFJBTkdFUExBSU5MT09TRV0gKyAnKScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1xcXFxzKy1cXFxccysnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcoJyArIHNyY1tYUkFOR0VQTEFJTkxPT1NFXSArICcpJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnXFxcXHMqJCc7XG5cbi8vIFN0YXIgcmFuZ2VzIGJhc2ljYWxseSBqdXN0IGFsbG93IGFueXRoaW5nIGF0IGFsbC5cbnZhciBTVEFSID0gUisrO1xuc3JjW1NUQVJdID0gJyg8fD4pPz0/XFxcXHMqXFxcXConO1xuXG4vLyBDb21waWxlIHRvIGFjdHVhbCByZWdleHAgb2JqZWN0cy5cbi8vIEFsbCBhcmUgZmxhZy1mcmVlLCB1bmxlc3MgdGhleSB3ZXJlIGNyZWF0ZWQgYWJvdmUgd2l0aCBhIGZsYWcuXG5mb3IgKHZhciBpID0gMDsgaSA8IFI7IGkrKykge1xuICBkZWJ1ZyhpLCBzcmNbaV0pO1xuICBpZiAoIXJlW2ldKVxuICAgIHJlW2ldID0gbmV3IFJlZ0V4cChzcmNbaV0pO1xufVxuXG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG5mdW5jdGlvbiBwYXJzZSh2ZXJzaW9uLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpXG4gICAgb3B0aW9ucyA9IHsgbG9vc2U6ICEhb3B0aW9ucywgaW5jbHVkZVByZXJlbGVhc2U6IGZhbHNlIH1cblxuICBpZiAodmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlcilcbiAgICByZXR1cm4gdmVyc2lvbjtcblxuICBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKVxuICAgIHJldHVybiBudWxsO1xuXG4gIGlmICh2ZXJzaW9uLmxlbmd0aCA+IE1BWF9MRU5HVEgpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHIgPSBvcHRpb25zLmxvb3NlID8gcmVbTE9PU0VdIDogcmVbRlVMTF07XG4gIGlmICghci50ZXN0KHZlcnNpb24pKVxuICAgIHJldHVybiBudWxsO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBTZW1WZXIodmVyc2lvbiwgb3B0aW9ucyk7XG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0cy52YWxpZCA9IHZhbGlkO1xuZnVuY3Rpb24gdmFsaWQodmVyc2lvbiwgb3B0aW9ucykge1xuICB2YXIgdiA9IHBhcnNlKHZlcnNpb24sIG9wdGlvbnMpO1xuICByZXR1cm4gdiA/IHYudmVyc2lvbiA6IG51bGw7XG59XG5cblxuZXhwb3J0cy5jbGVhbiA9IGNsZWFuO1xuZnVuY3Rpb24gY2xlYW4odmVyc2lvbiwgb3B0aW9ucykge1xuICB2YXIgcyA9IHBhcnNlKHZlcnNpb24udHJpbSgpLnJlcGxhY2UoL15bPXZdKy8sICcnKSwgb3B0aW9ucyk7XG4gIHJldHVybiBzID8gcy52ZXJzaW9uIDogbnVsbDtcbn1cblxuZXhwb3J0cy5TZW1WZXIgPSBTZW1WZXI7XG5cbmZ1bmN0aW9uIFNlbVZlcih2ZXJzaW9uLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpXG4gICAgb3B0aW9ucyA9IHsgbG9vc2U6ICEhb3B0aW9ucywgaW5jbHVkZVByZXJlbGVhc2U6IGZhbHNlIH1cbiAgaWYgKHZlcnNpb24gaW5zdGFuY2VvZiBTZW1WZXIpIHtcbiAgICBpZiAodmVyc2lvbi5sb29zZSA9PT0gb3B0aW9ucy5sb29zZSlcbiAgICAgIHJldHVybiB2ZXJzaW9uO1xuICAgIGVsc2VcbiAgICAgIHZlcnNpb24gPSB2ZXJzaW9uLnZlcnNpb247XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBWZXJzaW9uOiAnICsgdmVyc2lvbik7XG4gIH1cblxuICBpZiAodmVyc2lvbi5sZW5ndGggPiBNQVhfTEVOR1RIKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZlcnNpb24gaXMgbG9uZ2VyIHRoYW4gJyArIE1BWF9MRU5HVEggKyAnIGNoYXJhY3RlcnMnKVxuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTZW1WZXIpKVxuICAgIHJldHVybiBuZXcgU2VtVmVyKHZlcnNpb24sIG9wdGlvbnMpO1xuXG4gIGRlYnVnKCdTZW1WZXInLCB2ZXJzaW9uLCBvcHRpb25zKTtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy5sb29zZSA9ICEhb3B0aW9ucy5sb29zZTtcblxuICB2YXIgbSA9IHZlcnNpb24udHJpbSgpLm1hdGNoKG9wdGlvbnMubG9vc2UgPyByZVtMT09TRV0gOiByZVtGVUxMXSk7XG5cbiAgaWYgKCFtKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgVmVyc2lvbjogJyArIHZlcnNpb24pO1xuXG4gIHRoaXMucmF3ID0gdmVyc2lvbjtcblxuICAvLyB0aGVzZSBhcmUgYWN0dWFsbHkgbnVtYmVyc1xuICB0aGlzLm1ham9yID0gK21bMV07XG4gIHRoaXMubWlub3IgPSArbVsyXTtcbiAgdGhpcy5wYXRjaCA9ICttWzNdO1xuXG4gIGlmICh0aGlzLm1ham9yID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLm1ham9yIDwgMClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG1ham9yIHZlcnNpb24nKVxuXG4gIGlmICh0aGlzLm1pbm9yID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLm1pbm9yIDwgMClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG1pbm9yIHZlcnNpb24nKVxuXG4gIGlmICh0aGlzLnBhdGNoID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLnBhdGNoIDwgMClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHBhdGNoIHZlcnNpb24nKVxuXG4gIC8vIG51bWJlcmlmeSBhbnkgcHJlcmVsZWFzZSBudW1lcmljIGlkc1xuICBpZiAoIW1bNF0pXG4gICAgdGhpcy5wcmVyZWxlYXNlID0gW107XG4gIGVsc2VcbiAgICB0aGlzLnByZXJlbGVhc2UgPSBtWzRdLnNwbGl0KCcuJykubWFwKGZ1bmN0aW9uKGlkKSB7XG4gICAgICBpZiAoL15bMC05XSskLy50ZXN0KGlkKSkge1xuICAgICAgICB2YXIgbnVtID0gK2lkO1xuICAgICAgICBpZiAobnVtID49IDAgJiYgbnVtIDwgTUFYX1NBRkVfSU5URUdFUilcbiAgICAgICAgICByZXR1cm4gbnVtO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlkO1xuICAgIH0pO1xuXG4gIHRoaXMuYnVpbGQgPSBtWzVdID8gbVs1XS5zcGxpdCgnLicpIDogW107XG4gIHRoaXMuZm9ybWF0KCk7XG59XG5cblNlbVZlci5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMudmVyc2lvbiA9IHRoaXMubWFqb3IgKyAnLicgKyB0aGlzLm1pbm9yICsgJy4nICsgdGhpcy5wYXRjaDtcbiAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGgpXG4gICAgdGhpcy52ZXJzaW9uICs9ICctJyArIHRoaXMucHJlcmVsZWFzZS5qb2luKCcuJyk7XG4gIHJldHVybiB0aGlzLnZlcnNpb247XG59O1xuXG5TZW1WZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnZlcnNpb247XG59O1xuXG5TZW1WZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbihvdGhlcikge1xuICBkZWJ1ZygnU2VtVmVyLmNvbXBhcmUnLCB0aGlzLnZlcnNpb24sIHRoaXMub3B0aW9ucywgb3RoZXIpO1xuICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpXG4gICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpO1xuXG4gIHJldHVybiB0aGlzLmNvbXBhcmVNYWluKG90aGVyKSB8fCB0aGlzLmNvbXBhcmVQcmUob3RoZXIpO1xufTtcblxuU2VtVmVyLnByb3RvdHlwZS5jb21wYXJlTWFpbiA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSlcbiAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMub3B0aW9ucyk7XG5cbiAgcmV0dXJuIGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLm1ham9yLCBvdGhlci5tYWpvcikgfHxcbiAgICAgICAgIGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLm1pbm9yLCBvdGhlci5taW5vcikgfHxcbiAgICAgICAgIGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLnBhdGNoLCBvdGhlci5wYXRjaCk7XG59O1xuXG5TZW1WZXIucHJvdG90eXBlLmNvbXBhcmVQcmUgPSBmdW5jdGlvbihvdGhlcikge1xuICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpXG4gICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpO1xuXG4gIC8vIE5PVCBoYXZpbmcgYSBwcmVyZWxlYXNlIGlzID4gaGF2aW5nIG9uZVxuICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCAmJiAhb3RoZXIucHJlcmVsZWFzZS5sZW5ndGgpXG4gICAgcmV0dXJuIC0xO1xuICBlbHNlIGlmICghdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCAmJiBvdGhlci5wcmVyZWxlYXNlLmxlbmd0aClcbiAgICByZXR1cm4gMTtcbiAgZWxzZSBpZiAoIXRoaXMucHJlcmVsZWFzZS5sZW5ndGggJiYgIW90aGVyLnByZXJlbGVhc2UubGVuZ3RoKVxuICAgIHJldHVybiAwO1xuXG4gIHZhciBpID0gMDtcbiAgZG8ge1xuICAgIHZhciBhID0gdGhpcy5wcmVyZWxlYXNlW2ldO1xuICAgIHZhciBiID0gb3RoZXIucHJlcmVsZWFzZVtpXTtcbiAgICBkZWJ1ZygncHJlcmVsZWFzZSBjb21wYXJlJywgaSwgYSwgYik7XG4gICAgaWYgKGEgPT09IHVuZGVmaW5lZCAmJiBiID09PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gMDtcbiAgICBlbHNlIGlmIChiID09PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gMTtcbiAgICBlbHNlIGlmIChhID09PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gLTE7XG4gICAgZWxzZSBpZiAoYSA9PT0gYilcbiAgICAgIGNvbnRpbnVlO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBjb21wYXJlSWRlbnRpZmllcnMoYSwgYik7XG4gIH0gd2hpbGUgKCsraSk7XG59O1xuXG4vLyBwcmVtaW5vciB3aWxsIGJ1bXAgdGhlIHZlcnNpb24gdXAgdG8gdGhlIG5leHQgbWlub3IgcmVsZWFzZSwgYW5kIGltbWVkaWF0ZWx5XG4vLyBkb3duIHRvIHByZS1yZWxlYXNlLiBwcmVtYWpvciBhbmQgcHJlcGF0Y2ggd29yayB0aGUgc2FtZSB3YXkuXG5TZW1WZXIucHJvdG90eXBlLmluYyA9IGZ1bmN0aW9uKHJlbGVhc2UsIGlkZW50aWZpZXIpIHtcbiAgc3dpdGNoIChyZWxlYXNlKSB7XG4gICAgY2FzZSAncHJlbWFqb3InOlxuICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLnBhdGNoID0gMDtcbiAgICAgIHRoaXMubWlub3IgPSAwO1xuICAgICAgdGhpcy5tYWpvcisrO1xuICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncHJlbWlub3InOlxuICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLnBhdGNoID0gMDtcbiAgICAgIHRoaXMubWlub3IrKztcbiAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3ByZXBhdGNoJzpcbiAgICAgIC8vIElmIHRoaXMgaXMgYWxyZWFkeSBhIHByZXJlbGVhc2UsIGl0IHdpbGwgYnVtcCB0byB0aGUgbmV4dCB2ZXJzaW9uXG4gICAgICAvLyBkcm9wIGFueSBwcmVyZWxlYXNlcyB0aGF0IG1pZ2h0IGFscmVhZHkgZXhpc3QsIHNpbmNlIHRoZXkgYXJlIG5vdFxuICAgICAgLy8gcmVsZXZhbnQgYXQgdGhpcyBwb2ludC5cbiAgICAgIHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPSAwO1xuICAgICAgdGhpcy5pbmMoJ3BhdGNoJywgaWRlbnRpZmllcik7XG4gICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcik7XG4gICAgICBicmVhaztcbiAgICAvLyBJZiB0aGUgaW5wdXQgaXMgYSBub24tcHJlcmVsZWFzZSB2ZXJzaW9uLCB0aGlzIGFjdHMgdGhlIHNhbWUgYXNcbiAgICAvLyBwcmVwYXRjaC5cbiAgICBjYXNlICdwcmVyZWxlYXNlJzpcbiAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKVxuICAgICAgICB0aGlzLmluYygncGF0Y2gnLCBpZGVudGlmaWVyKTtcbiAgICAgIHRoaXMuaW5jKCdwcmUnLCBpZGVudGlmaWVyKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnbWFqb3InOlxuICAgICAgLy8gSWYgdGhpcyBpcyBhIHByZS1tYWpvciB2ZXJzaW9uLCBidW1wIHVwIHRvIHRoZSBzYW1lIG1ham9yIHZlcnNpb24uXG4gICAgICAvLyBPdGhlcndpc2UgaW5jcmVtZW50IG1ham9yLlxuICAgICAgLy8gMS4wLjAtNSBidW1wcyB0byAxLjAuMFxuICAgICAgLy8gMS4xLjAgYnVtcHMgdG8gMi4wLjBcbiAgICAgIGlmICh0aGlzLm1pbm9yICE9PSAwIHx8IHRoaXMucGF0Y2ggIT09IDAgfHwgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMClcbiAgICAgICAgdGhpcy5tYWpvcisrO1xuICAgICAgdGhpcy5taW5vciA9IDA7XG4gICAgICB0aGlzLnBhdGNoID0gMDtcbiAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbWlub3InOlxuICAgICAgLy8gSWYgdGhpcyBpcyBhIHByZS1taW5vciB2ZXJzaW9uLCBidW1wIHVwIHRvIHRoZSBzYW1lIG1pbm9yIHZlcnNpb24uXG4gICAgICAvLyBPdGhlcndpc2UgaW5jcmVtZW50IG1pbm9yLlxuICAgICAgLy8gMS4yLjAtNSBidW1wcyB0byAxLjIuMFxuICAgICAgLy8gMS4yLjEgYnVtcHMgdG8gMS4zLjBcbiAgICAgIGlmICh0aGlzLnBhdGNoICE9PSAwIHx8IHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApXG4gICAgICAgIHRoaXMubWlub3IrKztcbiAgICAgIHRoaXMucGF0Y2ggPSAwO1xuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW107XG4gICAgICBicmVhaztcbiAgICBjYXNlICdwYXRjaCc6XG4gICAgICAvLyBJZiB0aGlzIGlzIG5vdCBhIHByZS1yZWxlYXNlIHZlcnNpb24sIGl0IHdpbGwgaW5jcmVtZW50IHRoZSBwYXRjaC5cbiAgICAgIC8vIElmIGl0IGlzIGEgcHJlLXJlbGVhc2UgaXQgd2lsbCBidW1wIHVwIHRvIHRoZSBzYW1lIHBhdGNoIHZlcnNpb24uXG4gICAgICAvLyAxLjIuMC01IHBhdGNoZXMgdG8gMS4yLjBcbiAgICAgIC8vIDEuMi4wIHBhdGNoZXMgdG8gMS4yLjFcbiAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKVxuICAgICAgICB0aGlzLnBhdGNoKys7XG4gICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXTtcbiAgICAgIGJyZWFrO1xuICAgIC8vIFRoaXMgcHJvYmFibHkgc2hvdWxkbid0IGJlIHVzZWQgcHVibGljbHkuXG4gICAgLy8gMS4wLjAgXCJwcmVcIiB3b3VsZCBiZWNvbWUgMS4wLjAtMCB3aGljaCBpcyB0aGUgd3JvbmcgZGlyZWN0aW9uLlxuICAgIGNhc2UgJ3ByZSc6XG4gICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMClcbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gWzBdO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5wcmVyZWxlYXNlLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnByZXJlbGVhc2VbaV0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLnByZXJlbGVhc2VbaV0rKztcbiAgICAgICAgICAgIGkgPSAtMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT09IC0xKSAvLyBkaWRuJ3QgaW5jcmVtZW50IGFueXRoaW5nXG4gICAgICAgICAgdGhpcy5wcmVyZWxlYXNlLnB1c2goMCk7XG4gICAgICB9XG4gICAgICBpZiAoaWRlbnRpZmllcikge1xuICAgICAgICAvLyAxLjIuMC1iZXRhLjEgYnVtcHMgdG8gMS4yLjAtYmV0YS4yLFxuICAgICAgICAvLyAxLjIuMC1iZXRhLmZvb2JseiBvciAxLjIuMC1iZXRhIGJ1bXBzIHRvIDEuMi4wLWJldGEuMFxuICAgICAgICBpZiAodGhpcy5wcmVyZWxlYXNlWzBdID09PSBpZGVudGlmaWVyKSB7XG4gICAgICAgICAgaWYgKGlzTmFOKHRoaXMucHJlcmVsZWFzZVsxXSkpXG4gICAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbaWRlbnRpZmllciwgMF07XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtpZGVudGlmaWVyLCAwXTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbmNyZW1lbnQgYXJndW1lbnQ6ICcgKyByZWxlYXNlKTtcbiAgfVxuICB0aGlzLmZvcm1hdCgpO1xuICB0aGlzLnJhdyA9IHRoaXMudmVyc2lvbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5leHBvcnRzLmluYyA9IGluYztcbmZ1bmN0aW9uIGluYyh2ZXJzaW9uLCByZWxlYXNlLCBsb29zZSwgaWRlbnRpZmllcikge1xuICBpZiAodHlwZW9mKGxvb3NlKSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZGVudGlmaWVyID0gbG9vc2U7XG4gICAgbG9vc2UgPSB1bmRlZmluZWQ7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBuZXcgU2VtVmVyKHZlcnNpb24sIGxvb3NlKS5pbmMocmVsZWFzZSwgaWRlbnRpZmllcikudmVyc2lvbjtcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5leHBvcnRzLmRpZmYgPSBkaWZmO1xuZnVuY3Rpb24gZGlmZih2ZXJzaW9uMSwgdmVyc2lvbjIpIHtcbiAgaWYgKGVxKHZlcnNpb24xLCB2ZXJzaW9uMikpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdjEgPSBwYXJzZSh2ZXJzaW9uMSk7XG4gICAgdmFyIHYyID0gcGFyc2UodmVyc2lvbjIpO1xuICAgIGlmICh2MS5wcmVyZWxlYXNlLmxlbmd0aCB8fCB2Mi5wcmVyZWxlYXNlLmxlbmd0aCkge1xuICAgICAgZm9yICh2YXIga2V5IGluIHYxKSB7XG4gICAgICAgIGlmIChrZXkgPT09ICdtYWpvcicgfHwga2V5ID09PSAnbWlub3InIHx8IGtleSA9PT0gJ3BhdGNoJykge1xuICAgICAgICAgIGlmICh2MVtrZXldICE9PSB2MltrZXldKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3ByZScra2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICdwcmVyZWxlYXNlJztcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIHYxKSB7XG4gICAgICBpZiAoa2V5ID09PSAnbWFqb3InIHx8IGtleSA9PT0gJ21pbm9yJyB8fCBrZXkgPT09ICdwYXRjaCcpIHtcbiAgICAgICAgaWYgKHYxW2tleV0gIT09IHYyW2tleV0pIHtcbiAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMuY29tcGFyZUlkZW50aWZpZXJzID0gY29tcGFyZUlkZW50aWZpZXJzO1xuXG52YXIgbnVtZXJpYyA9IC9eWzAtOV0rJC87XG5mdW5jdGlvbiBjb21wYXJlSWRlbnRpZmllcnMoYSwgYikge1xuICB2YXIgYW51bSA9IG51bWVyaWMudGVzdChhKTtcbiAgdmFyIGJudW0gPSBudW1lcmljLnRlc3QoYik7XG5cbiAgaWYgKGFudW0gJiYgYm51bSkge1xuICAgIGEgPSArYTtcbiAgICBiID0gK2I7XG4gIH1cblxuICByZXR1cm4gKGFudW0gJiYgIWJudW0pID8gLTEgOlxuICAgICAgICAgKGJudW0gJiYgIWFudW0pID8gMSA6XG4gICAgICAgICBhIDwgYiA/IC0xIDpcbiAgICAgICAgIGEgPiBiID8gMSA6XG4gICAgICAgICAwO1xufVxuXG5leHBvcnRzLnJjb21wYXJlSWRlbnRpZmllcnMgPSByY29tcGFyZUlkZW50aWZpZXJzO1xuZnVuY3Rpb24gcmNvbXBhcmVJZGVudGlmaWVycyhhLCBiKSB7XG4gIHJldHVybiBjb21wYXJlSWRlbnRpZmllcnMoYiwgYSk7XG59XG5cbmV4cG9ydHMubWFqb3IgPSBtYWpvcjtcbmZ1bmN0aW9uIG1ham9yKGEsIGxvb3NlKSB7XG4gIHJldHVybiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5tYWpvcjtcbn1cblxuZXhwb3J0cy5taW5vciA9IG1pbm9yO1xuZnVuY3Rpb24gbWlub3IoYSwgbG9vc2UpIHtcbiAgcmV0dXJuIG5ldyBTZW1WZXIoYSwgbG9vc2UpLm1pbm9yO1xufVxuXG5leHBvcnRzLnBhdGNoID0gcGF0Y2g7XG5mdW5jdGlvbiBwYXRjaChhLCBsb29zZSkge1xuICByZXR1cm4gbmV3IFNlbVZlcihhLCBsb29zZSkucGF0Y2g7XG59XG5cbmV4cG9ydHMuY29tcGFyZSA9IGNvbXBhcmU7XG5mdW5jdGlvbiBjb21wYXJlKGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5jb21wYXJlKG5ldyBTZW1WZXIoYiwgbG9vc2UpKTtcbn1cblxuZXhwb3J0cy5jb21wYXJlTG9vc2UgPSBjb21wYXJlTG9vc2U7XG5mdW5jdGlvbiBjb21wYXJlTG9vc2UoYSwgYikge1xuICByZXR1cm4gY29tcGFyZShhLCBiLCB0cnVlKTtcbn1cblxuZXhwb3J0cy5yY29tcGFyZSA9IHJjb21wYXJlO1xuZnVuY3Rpb24gcmNvbXBhcmUoYSwgYiwgbG9vc2UpIHtcbiAgcmV0dXJuIGNvbXBhcmUoYiwgYSwgbG9vc2UpO1xufVxuXG5leHBvcnRzLnNvcnQgPSBzb3J0O1xuZnVuY3Rpb24gc29ydChsaXN0LCBsb29zZSkge1xuICByZXR1cm4gbGlzdC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5jb21wYXJlKGEsIGIsIGxvb3NlKTtcbiAgfSk7XG59XG5cbmV4cG9ydHMucnNvcnQgPSByc29ydDtcbmZ1bmN0aW9uIHJzb3J0KGxpc3QsIGxvb3NlKSB7XG4gIHJldHVybiBsaXN0LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBleHBvcnRzLnJjb21wYXJlKGEsIGIsIGxvb3NlKTtcbiAgfSk7XG59XG5cbmV4cG9ydHMuZ3QgPSBndDtcbmZ1bmN0aW9uIGd0KGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wYXJlKGEsIGIsIGxvb3NlKSA+IDA7XG59XG5cbmV4cG9ydHMubHQgPSBsdDtcbmZ1bmN0aW9uIGx0KGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wYXJlKGEsIGIsIGxvb3NlKSA8IDA7XG59XG5cbmV4cG9ydHMuZXEgPSBlcTtcbmZ1bmN0aW9uIGVxKGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wYXJlKGEsIGIsIGxvb3NlKSA9PT0gMDtcbn1cblxuZXhwb3J0cy5uZXEgPSBuZXE7XG5mdW5jdGlvbiBuZXEoYSwgYiwgbG9vc2UpIHtcbiAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgbG9vc2UpICE9PSAwO1xufVxuXG5leHBvcnRzLmd0ZSA9IGd0ZTtcbmZ1bmN0aW9uIGd0ZShhLCBiLCBsb29zZSkge1xuICByZXR1cm4gY29tcGFyZShhLCBiLCBsb29zZSkgPj0gMDtcbn1cblxuZXhwb3J0cy5sdGUgPSBsdGU7XG5mdW5jdGlvbiBsdGUoYSwgYiwgbG9vc2UpIHtcbiAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgbG9vc2UpIDw9IDA7XG59XG5cbmV4cG9ydHMuY21wID0gY21wO1xuZnVuY3Rpb24gY21wKGEsIG9wLCBiLCBsb29zZSkge1xuICB2YXIgcmV0O1xuICBzd2l0Y2ggKG9wKSB7XG4gICAgY2FzZSAnPT09JzpcbiAgICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcpIGEgPSBhLnZlcnNpb247XG4gICAgICBpZiAodHlwZW9mIGIgPT09ICdvYmplY3QnKSBiID0gYi52ZXJzaW9uO1xuICAgICAgcmV0ID0gYSA9PT0gYjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJyE9PSc6XG4gICAgICBpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnKSBhID0gYS52ZXJzaW9uO1xuICAgICAgaWYgKHR5cGVvZiBiID09PSAnb2JqZWN0JykgYiA9IGIudmVyc2lvbjtcbiAgICAgIHJldCA9IGEgIT09IGI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICcnOiBjYXNlICc9JzogY2FzZSAnPT0nOiByZXQgPSBlcShhLCBiLCBsb29zZSk7IGJyZWFrO1xuICAgIGNhc2UgJyE9JzogcmV0ID0gbmVxKGEsIGIsIGxvb3NlKTsgYnJlYWs7XG4gICAgY2FzZSAnPic6IHJldCA9IGd0KGEsIGIsIGxvb3NlKTsgYnJlYWs7XG4gICAgY2FzZSAnPj0nOiByZXQgPSBndGUoYSwgYiwgbG9vc2UpOyBicmVhaztcbiAgICBjYXNlICc8JzogcmV0ID0gbHQoYSwgYiwgbG9vc2UpOyBicmVhaztcbiAgICBjYXNlICc8PSc6IHJldCA9IGx0ZShhLCBiLCBsb29zZSk7IGJyZWFrO1xuICAgIGRlZmF1bHQ6IHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgb3BlcmF0b3I6ICcgKyBvcCk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZXhwb3J0cy5Db21wYXJhdG9yID0gQ29tcGFyYXRvcjtcbmZ1bmN0aW9uIENvbXBhcmF0b3IoY29tcCwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMgfHwgdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKVxuICAgIG9wdGlvbnMgPSB7IGxvb3NlOiAhIW9wdGlvbnMsIGluY2x1ZGVQcmVyZWxlYXNlOiBmYWxzZSB9XG5cbiAgaWYgKGNvbXAgaW5zdGFuY2VvZiBDb21wYXJhdG9yKSB7XG4gICAgaWYgKGNvbXAubG9vc2UgPT09ICEhb3B0aW9ucy5sb29zZSlcbiAgICAgIHJldHVybiBjb21wO1xuICAgIGVsc2VcbiAgICAgIGNvbXAgPSBjb21wLnZhbHVlO1xuICB9XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENvbXBhcmF0b3IpKVxuICAgIHJldHVybiBuZXcgQ29tcGFyYXRvcihjb21wLCBvcHRpb25zKTtcblxuICBkZWJ1ZygnY29tcGFyYXRvcicsIGNvbXAsIG9wdGlvbnMpO1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB0aGlzLmxvb3NlID0gISFvcHRpb25zLmxvb3NlO1xuICB0aGlzLnBhcnNlKGNvbXApO1xuXG4gIGlmICh0aGlzLnNlbXZlciA9PT0gQU5ZKVxuICAgIHRoaXMudmFsdWUgPSAnJztcbiAgZWxzZVxuICAgIHRoaXMudmFsdWUgPSB0aGlzLm9wZXJhdG9yICsgdGhpcy5zZW12ZXIudmVyc2lvbjtcblxuICBkZWJ1ZygnY29tcCcsIHRoaXMpO1xufVxuXG52YXIgQU5ZID0ge307XG5Db21wYXJhdG9yLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKGNvbXApIHtcbiAgdmFyIHIgPSB0aGlzLm9wdGlvbnMubG9vc2UgPyByZVtDT01QQVJBVE9STE9PU0VdIDogcmVbQ09NUEFSQVRPUl07XG4gIHZhciBtID0gY29tcC5tYXRjaChyKTtcblxuICBpZiAoIW0pXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBjb21wYXJhdG9yOiAnICsgY29tcCk7XG5cbiAgdGhpcy5vcGVyYXRvciA9IG1bMV07XG4gIGlmICh0aGlzLm9wZXJhdG9yID09PSAnPScpXG4gICAgdGhpcy5vcGVyYXRvciA9ICcnO1xuXG4gIC8vIGlmIGl0IGxpdGVyYWxseSBpcyBqdXN0ICc+JyBvciAnJyB0aGVuIGFsbG93IGFueXRoaW5nLlxuICBpZiAoIW1bMl0pXG4gICAgdGhpcy5zZW12ZXIgPSBBTlk7XG4gIGVsc2VcbiAgICB0aGlzLnNlbXZlciA9IG5ldyBTZW1WZXIobVsyXSwgdGhpcy5vcHRpb25zLmxvb3NlKTtcbn07XG5cbkNvbXBhcmF0b3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnZhbHVlO1xufTtcblxuQ29tcGFyYXRvci5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uKHZlcnNpb24pIHtcbiAgZGVidWcoJ0NvbXBhcmF0b3IudGVzdCcsIHZlcnNpb24sIHRoaXMub3B0aW9ucy5sb29zZSk7XG5cbiAgaWYgKHRoaXMuc2VtdmVyID09PSBBTlkpXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJylcbiAgICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCB0aGlzLm9wdGlvbnMpO1xuXG4gIHJldHVybiBjbXAodmVyc2lvbiwgdGhpcy5vcGVyYXRvciwgdGhpcy5zZW12ZXIsIHRoaXMub3B0aW9ucyk7XG59O1xuXG5Db21wYXJhdG9yLnByb3RvdHlwZS5pbnRlcnNlY3RzID0gZnVuY3Rpb24oY29tcCwgb3B0aW9ucykge1xuICBpZiAoIShjb21wIGluc3RhbmNlb2YgQ29tcGFyYXRvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhIENvbXBhcmF0b3IgaXMgcmVxdWlyZWQnKTtcbiAgfVxuXG4gIGlmICghb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpXG4gICAgb3B0aW9ucyA9IHsgbG9vc2U6ICEhb3B0aW9ucywgaW5jbHVkZVByZXJlbGVhc2U6IGZhbHNlIH1cblxuICB2YXIgcmFuZ2VUbXA7XG5cbiAgaWYgKHRoaXMub3BlcmF0b3IgPT09ICcnKSB7XG4gICAgcmFuZ2VUbXAgPSBuZXcgUmFuZ2UoY29tcC52YWx1ZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHNhdGlzZmllcyh0aGlzLnZhbHVlLCByYW5nZVRtcCwgb3B0aW9ucyk7XG4gIH0gZWxzZSBpZiAoY29tcC5vcGVyYXRvciA9PT0gJycpIHtcbiAgICByYW5nZVRtcCA9IG5ldyBSYW5nZSh0aGlzLnZhbHVlLCBvcHRpb25zKTtcbiAgICByZXR1cm4gc2F0aXNmaWVzKGNvbXAuc2VtdmVyLCByYW5nZVRtcCwgb3B0aW9ucyk7XG4gIH1cblxuICB2YXIgc2FtZURpcmVjdGlvbkluY3JlYXNpbmcgPVxuICAgICh0aGlzLm9wZXJhdG9yID09PSAnPj0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc+JykgJiZcbiAgICAoY29tcC5vcGVyYXRvciA9PT0gJz49JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPicpO1xuICB2YXIgc2FtZURpcmVjdGlvbkRlY3JlYXNpbmcgPVxuICAgICh0aGlzLm9wZXJhdG9yID09PSAnPD0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc8JykgJiZcbiAgICAoY29tcC5vcGVyYXRvciA9PT0gJzw9JyB8fCBjb21wLm9wZXJhdG9yID09PSAnPCcpO1xuICB2YXIgc2FtZVNlbVZlciA9IHRoaXMuc2VtdmVyLnZlcnNpb24gPT09IGNvbXAuc2VtdmVyLnZlcnNpb247XG4gIHZhciBkaWZmZXJlbnREaXJlY3Rpb25zSW5jbHVzaXZlID1cbiAgICAodGhpcy5vcGVyYXRvciA9PT0gJz49JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPD0nKSAmJlxuICAgIChjb21wLm9wZXJhdG9yID09PSAnPj0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc8PScpO1xuICB2YXIgb3Bwb3NpdGVEaXJlY3Rpb25zTGVzc1RoYW4gPVxuICAgIGNtcCh0aGlzLnNlbXZlciwgJzwnLCBjb21wLnNlbXZlciwgb3B0aW9ucykgJiZcbiAgICAoKHRoaXMub3BlcmF0b3IgPT09ICc+PScgfHwgdGhpcy5vcGVyYXRvciA9PT0gJz4nKSAmJlxuICAgIChjb21wLm9wZXJhdG9yID09PSAnPD0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc8JykpO1xuICB2YXIgb3Bwb3NpdGVEaXJlY3Rpb25zR3JlYXRlclRoYW4gPVxuICAgIGNtcCh0aGlzLnNlbXZlciwgJz4nLCBjb21wLnNlbXZlciwgb3B0aW9ucykgJiZcbiAgICAoKHRoaXMub3BlcmF0b3IgPT09ICc8PScgfHwgdGhpcy5vcGVyYXRvciA9PT0gJzwnKSAmJlxuICAgIChjb21wLm9wZXJhdG9yID09PSAnPj0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc+JykpO1xuXG4gIHJldHVybiBzYW1lRGlyZWN0aW9uSW5jcmVhc2luZyB8fCBzYW1lRGlyZWN0aW9uRGVjcmVhc2luZyB8fFxuICAgIChzYW1lU2VtVmVyICYmIGRpZmZlcmVudERpcmVjdGlvbnNJbmNsdXNpdmUpIHx8XG4gICAgb3Bwb3NpdGVEaXJlY3Rpb25zTGVzc1RoYW4gfHwgb3Bwb3NpdGVEaXJlY3Rpb25zR3JlYXRlclRoYW47XG59O1xuXG5cbmV4cG9ydHMuUmFuZ2UgPSBSYW5nZTtcbmZ1bmN0aW9uIFJhbmdlKHJhbmdlLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpXG4gICAgb3B0aW9ucyA9IHsgbG9vc2U6ICEhb3B0aW9ucywgaW5jbHVkZVByZXJlbGVhc2U6IGZhbHNlIH1cblxuICBpZiAocmFuZ2UgaW5zdGFuY2VvZiBSYW5nZSkge1xuICAgIGlmIChyYW5nZS5sb29zZSA9PT0gISFvcHRpb25zLmxvb3NlICYmXG4gICAgICAgIHJhbmdlLmluY2x1ZGVQcmVyZWxlYXNlID09PSAhIW9wdGlvbnMuaW5jbHVkZVByZXJlbGVhc2UpIHtcbiAgICAgIHJldHVybiByYW5nZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZS5yYXcsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyYW5nZSBpbnN0YW5jZW9mIENvbXBhcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLnZhbHVlLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSYW5nZSkpXG4gICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucyk7XG5cbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy5sb29zZSA9ICEhb3B0aW9ucy5sb29zZTtcbiAgdGhpcy5pbmNsdWRlUHJlcmVsZWFzZSA9ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZVxuXG4gIC8vIEZpcnN0LCBzcGxpdCBiYXNlZCBvbiBib29sZWFuIG9yIHx8XG4gIHRoaXMucmF3ID0gcmFuZ2U7XG4gIHRoaXMuc2V0ID0gcmFuZ2Uuc3BsaXQoL1xccypcXHxcXHxcXHMqLykubWFwKGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VSYW5nZShyYW5nZS50cmltKCkpO1xuICB9LCB0aGlzKS5maWx0ZXIoZnVuY3Rpb24oYykge1xuICAgIC8vIHRocm93IG91dCBhbnkgdGhhdCBhcmUgbm90IHJlbGV2YW50IGZvciB3aGF0ZXZlciByZWFzb25cbiAgICByZXR1cm4gYy5sZW5ndGg7XG4gIH0pO1xuXG4gIGlmICghdGhpcy5zZXQubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBTZW1WZXIgUmFuZ2U6ICcgKyByYW5nZSk7XG4gIH1cblxuICB0aGlzLmZvcm1hdCgpO1xufVxuXG5SYW5nZS5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucmFuZ2UgPSB0aGlzLnNldC5tYXAoZnVuY3Rpb24oY29tcHMpIHtcbiAgICByZXR1cm4gY29tcHMuam9pbignICcpLnRyaW0oKTtcbiAgfSkuam9pbignfHwnKS50cmltKCk7XG4gIHJldHVybiB0aGlzLnJhbmdlO1xufTtcblxuUmFuZ2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnJhbmdlO1xufTtcblxuUmFuZ2UucHJvdG90eXBlLnBhcnNlUmFuZ2UgPSBmdW5jdGlvbihyYW5nZSkge1xuICB2YXIgbG9vc2UgPSB0aGlzLm9wdGlvbnMubG9vc2U7XG4gIHJhbmdlID0gcmFuZ2UudHJpbSgpO1xuICAvLyBgMS4yLjMgLSAxLjIuNGAgPT4gYD49MS4yLjMgPD0xLjIuNGBcbiAgdmFyIGhyID0gbG9vc2UgPyByZVtIWVBIRU5SQU5HRUxPT1NFXSA6IHJlW0hZUEhFTlJBTkdFXTtcbiAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKGhyLCBoeXBoZW5SZXBsYWNlKTtcbiAgZGVidWcoJ2h5cGhlbiByZXBsYWNlJywgcmFuZ2UpO1xuICAvLyBgPiAxLjIuMyA8IDEuMi41YCA9PiBgPjEuMi4zIDwxLjIuNWBcbiAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW0NPTVBBUkFUT1JUUklNXSwgY29tcGFyYXRvclRyaW1SZXBsYWNlKTtcbiAgZGVidWcoJ2NvbXBhcmF0b3IgdHJpbScsIHJhbmdlLCByZVtDT01QQVJBVE9SVFJJTV0pO1xuXG4gIC8vIGB+IDEuMi4zYCA9PiBgfjEuMi4zYFxuICByYW5nZSA9IHJhbmdlLnJlcGxhY2UocmVbVElMREVUUklNXSwgdGlsZGVUcmltUmVwbGFjZSk7XG5cbiAgLy8gYF4gMS4yLjNgID0+IGBeMS4yLjNgXG4gIHJhbmdlID0gcmFuZ2UucmVwbGFjZShyZVtDQVJFVFRSSU1dLCBjYXJldFRyaW1SZXBsYWNlKTtcblxuICAvLyBub3JtYWxpemUgc3BhY2VzXG4gIHJhbmdlID0gcmFuZ2Uuc3BsaXQoL1xccysvKS5qb2luKCcgJyk7XG5cbiAgLy8gQXQgdGhpcyBwb2ludCwgdGhlIHJhbmdlIGlzIGNvbXBsZXRlbHkgdHJpbW1lZCBhbmRcbiAgLy8gcmVhZHkgdG8gYmUgc3BsaXQgaW50byBjb21wYXJhdG9ycy5cblxuICB2YXIgY29tcFJlID0gbG9vc2UgPyByZVtDT01QQVJBVE9STE9PU0VdIDogcmVbQ09NUEFSQVRPUl07XG4gIHZhciBzZXQgPSByYW5nZS5zcGxpdCgnICcpLm1hcChmdW5jdGlvbihjb21wKSB7XG4gICAgcmV0dXJuIHBhcnNlQ29tcGFyYXRvcihjb21wLCB0aGlzLm9wdGlvbnMpO1xuICB9LCB0aGlzKS5qb2luKCcgJykuc3BsaXQoL1xccysvKTtcbiAgaWYgKHRoaXMub3B0aW9ucy5sb29zZSkge1xuICAgIC8vIGluIGxvb3NlIG1vZGUsIHRocm93IG91dCBhbnkgdGhhdCBhcmUgbm90IHZhbGlkIGNvbXBhcmF0b3JzXG4gICAgc2V0ID0gc2V0LmZpbHRlcihmdW5jdGlvbihjb21wKSB7XG4gICAgICByZXR1cm4gISFjb21wLm1hdGNoKGNvbXBSZSk7XG4gICAgfSk7XG4gIH1cbiAgc2V0ID0gc2V0Lm1hcChmdW5jdGlvbihjb21wKSB7XG4gICAgcmV0dXJuIG5ldyBDb21wYXJhdG9yKGNvbXAsIHRoaXMub3B0aW9ucyk7XG4gIH0sIHRoaXMpO1xuXG4gIHJldHVybiBzZXQ7XG59O1xuXG5SYW5nZS5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uKHJhbmdlLCBvcHRpb25zKSB7XG4gIGlmICghKHJhbmdlIGluc3RhbmNlb2YgUmFuZ2UpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYSBSYW5nZSBpcyByZXF1aXJlZCcpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuc2V0LnNvbWUoZnVuY3Rpb24odGhpc0NvbXBhcmF0b3JzKSB7XG4gICAgcmV0dXJuIHRoaXNDb21wYXJhdG9ycy5ldmVyeShmdW5jdGlvbih0aGlzQ29tcGFyYXRvcikge1xuICAgICAgcmV0dXJuIHJhbmdlLnNldC5zb21lKGZ1bmN0aW9uKHJhbmdlQ29tcGFyYXRvcnMpIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlQ29tcGFyYXRvcnMuZXZlcnkoZnVuY3Rpb24ocmFuZ2VDb21wYXJhdG9yKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXNDb21wYXJhdG9yLmludGVyc2VjdHMocmFuZ2VDb21wYXJhdG9yLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vLyBNb3N0bHkganVzdCBmb3IgdGVzdGluZyBhbmQgbGVnYWN5IEFQSSByZWFzb25zXG5leHBvcnRzLnRvQ29tcGFyYXRvcnMgPSB0b0NvbXBhcmF0b3JzO1xuZnVuY3Rpb24gdG9Db21wYXJhdG9ycyhyYW5nZSwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKS5zZXQubWFwKGZ1bmN0aW9uKGNvbXApIHtcbiAgICByZXR1cm4gY29tcC5tYXAoZnVuY3Rpb24oYykge1xuICAgICAgcmV0dXJuIGMudmFsdWU7XG4gICAgfSkuam9pbignICcpLnRyaW0oKS5zcGxpdCgnICcpO1xuICB9KTtcbn1cblxuLy8gY29tcHJpc2VkIG9mIHhyYW5nZXMsIHRpbGRlcywgc3RhcnMsIGFuZCBndGx0J3MgYXQgdGhpcyBwb2ludC5cbi8vIGFscmVhZHkgcmVwbGFjZWQgdGhlIGh5cGhlbiByYW5nZXNcbi8vIHR1cm4gaW50byBhIHNldCBvZiBKVVNUIGNvbXBhcmF0b3JzLlxuZnVuY3Rpb24gcGFyc2VDb21wYXJhdG9yKGNvbXAsIG9wdGlvbnMpIHtcbiAgZGVidWcoJ2NvbXAnLCBjb21wLCBvcHRpb25zKTtcbiAgY29tcCA9IHJlcGxhY2VDYXJldHMoY29tcCwgb3B0aW9ucyk7XG4gIGRlYnVnKCdjYXJldCcsIGNvbXApO1xuICBjb21wID0gcmVwbGFjZVRpbGRlcyhjb21wLCBvcHRpb25zKTtcbiAgZGVidWcoJ3RpbGRlcycsIGNvbXApO1xuICBjb21wID0gcmVwbGFjZVhSYW5nZXMoY29tcCwgb3B0aW9ucyk7XG4gIGRlYnVnKCd4cmFuZ2UnLCBjb21wKTtcbiAgY29tcCA9IHJlcGxhY2VTdGFycyhjb21wLCBvcHRpb25zKTtcbiAgZGVidWcoJ3N0YXJzJywgY29tcCk7XG4gIHJldHVybiBjb21wO1xufVxuXG5mdW5jdGlvbiBpc1goaWQpIHtcbiAgcmV0dXJuICFpZCB8fCBpZC50b0xvd2VyQ2FzZSgpID09PSAneCcgfHwgaWQgPT09ICcqJztcbn1cblxuLy8gfiwgfj4gLS0+ICogKGFueSwga2luZGEgc2lsbHkpXG4vLyB+MiwgfjIueCwgfjIueC54LCB+PjIsIH4+Mi54IH4+Mi54LnggLS0+ID49Mi4wLjAgPDMuMC4wXG4vLyB+Mi4wLCB+Mi4wLngsIH4+Mi4wLCB+PjIuMC54IC0tPiA+PTIuMC4wIDwyLjEuMFxuLy8gfjEuMiwgfjEuMi54LCB+PjEuMiwgfj4xLjIueCAtLT4gPj0xLjIuMCA8MS4zLjBcbi8vIH4xLjIuMywgfj4xLjIuMyAtLT4gPj0xLjIuMyA8MS4zLjBcbi8vIH4xLjIuMCwgfj4xLjIuMCAtLT4gPj0xLjIuMCA8MS4zLjBcbmZ1bmN0aW9uIHJlcGxhY2VUaWxkZXMoY29tcCwgb3B0aW9ucykge1xuICByZXR1cm4gY29tcC50cmltKCkuc3BsaXQoL1xccysvKS5tYXAoZnVuY3Rpb24oY29tcCkge1xuICAgIHJldHVybiByZXBsYWNlVGlsZGUoY29tcCwgb3B0aW9ucyk7XG4gIH0pLmpvaW4oJyAnKTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZVRpbGRlKGNvbXAsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JylcbiAgICBvcHRpb25zID0geyBsb29zZTogISFvcHRpb25zLCBpbmNsdWRlUHJlcmVsZWFzZTogZmFsc2UgfVxuICB2YXIgciA9IG9wdGlvbnMubG9vc2UgPyByZVtUSUxERUxPT1NFXSA6IHJlW1RJTERFXTtcbiAgcmV0dXJuIGNvbXAucmVwbGFjZShyLCBmdW5jdGlvbihfLCBNLCBtLCBwLCBwcikge1xuICAgIGRlYnVnKCd0aWxkZScsIGNvbXAsIF8sIE0sIG0sIHAsIHByKTtcbiAgICB2YXIgcmV0O1xuXG4gICAgaWYgKGlzWChNKSlcbiAgICAgIHJldCA9ICcnO1xuICAgIGVsc2UgaWYgKGlzWChtKSlcbiAgICAgIHJldCA9ICc+PScgKyBNICsgJy4wLjAgPCcgKyAoK00gKyAxKSArICcuMC4wJztcbiAgICBlbHNlIGlmIChpc1gocCkpXG4gICAgICAvLyB+MS4yID09ID49MS4yLjAgPDEuMy4wXG4gICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLjAgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnO1xuICAgIGVsc2UgaWYgKHByKSB7XG4gICAgICBkZWJ1ZygncmVwbGFjZVRpbGRlIHByJywgcHIpO1xuICAgICAgaWYgKHByLmNoYXJBdCgwKSAhPT0gJy0nKVxuICAgICAgICBwciA9ICctJyArIHByO1xuICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArIHByICtcbiAgICAgICAgICAgICcgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnO1xuICAgIH0gZWxzZVxuICAgICAgLy8gfjEuMi4zID09ID49MS4yLjMgPDEuMy4wXG4gICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICtcbiAgICAgICAgICAgICcgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnO1xuXG4gICAgZGVidWcoJ3RpbGRlIHJldHVybicsIHJldCk7XG4gICAgcmV0dXJuIHJldDtcbiAgfSk7XG59XG5cbi8vIF4gLS0+ICogKGFueSwga2luZGEgc2lsbHkpXG4vLyBeMiwgXjIueCwgXjIueC54IC0tPiA+PTIuMC4wIDwzLjAuMFxuLy8gXjIuMCwgXjIuMC54IC0tPiA+PTIuMC4wIDwzLjAuMFxuLy8gXjEuMiwgXjEuMi54IC0tPiA+PTEuMi4wIDwyLjAuMFxuLy8gXjEuMi4zIC0tPiA+PTEuMi4zIDwyLjAuMFxuLy8gXjEuMi4wIC0tPiA+PTEuMi4wIDwyLjAuMFxuZnVuY3Rpb24gcmVwbGFjZUNhcmV0cyhjb21wLCBvcHRpb25zKSB7XG4gIHJldHVybiBjb21wLnRyaW0oKS5zcGxpdCgvXFxzKy8pLm1hcChmdW5jdGlvbihjb21wKSB7XG4gICAgcmV0dXJuIHJlcGxhY2VDYXJldChjb21wLCBvcHRpb25zKTtcbiAgfSkuam9pbignICcpO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlQ2FyZXQoY29tcCwgb3B0aW9ucykge1xuICBkZWJ1ZygnY2FyZXQnLCBjb21wLCBvcHRpb25zKTtcbiAgaWYgKCFvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JylcbiAgICBvcHRpb25zID0geyBsb29zZTogISFvcHRpb25zLCBpbmNsdWRlUHJlcmVsZWFzZTogZmFsc2UgfVxuICB2YXIgciA9IG9wdGlvbnMubG9vc2UgPyByZVtDQVJFVExPT1NFXSA6IHJlW0NBUkVUXTtcbiAgcmV0dXJuIGNvbXAucmVwbGFjZShyLCBmdW5jdGlvbihfLCBNLCBtLCBwLCBwcikge1xuICAgIGRlYnVnKCdjYXJldCcsIGNvbXAsIF8sIE0sIG0sIHAsIHByKTtcbiAgICB2YXIgcmV0O1xuXG4gICAgaWYgKGlzWChNKSlcbiAgICAgIHJldCA9ICcnO1xuICAgIGVsc2UgaWYgKGlzWChtKSlcbiAgICAgIHJldCA9ICc+PScgKyBNICsgJy4wLjAgPCcgKyAoK00gKyAxKSArICcuMC4wJztcbiAgICBlbHNlIGlmIChpc1gocCkpIHtcbiAgICAgIGlmIChNID09PSAnMCcpXG4gICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuMCA8JyArIE0gKyAnLicgKyAoK20gKyAxKSArICcuMCc7XG4gICAgICBlbHNlXG4gICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuMCA8JyArICgrTSArIDEpICsgJy4wLjAnO1xuICAgIH0gZWxzZSBpZiAocHIpIHtcbiAgICAgIGRlYnVnKCdyZXBsYWNlQ2FyZXQgcHInLCBwcik7XG4gICAgICBpZiAocHIuY2hhckF0KDApICE9PSAnLScpXG4gICAgICAgIHByID0gJy0nICsgcHI7XG4gICAgICBpZiAoTSA9PT0gJzAnKSB7XG4gICAgICAgIGlmIChtID09PSAnMCcpXG4gICAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArIHByICtcbiAgICAgICAgICAgICAgICAnIDwnICsgTSArICcuJyArIG0gKyAnLicgKyAoK3AgKyAxKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgKyBwciArXG4gICAgICAgICAgICAgICAgJyA8JyArIE0gKyAnLicgKyAoK20gKyAxKSArICcuMCc7XG4gICAgICB9IGVsc2VcbiAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArIHByICtcbiAgICAgICAgICAgICAgJyA8JyArICgrTSArIDEpICsgJy4wLjAnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Zygnbm8gcHInKTtcbiAgICAgIGlmIChNID09PSAnMCcpIHtcbiAgICAgICAgaWYgKG0gPT09ICcwJylcbiAgICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICtcbiAgICAgICAgICAgICAgICAnIDwnICsgTSArICcuJyArIG0gKyAnLicgKyAoK3AgKyAxKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgK1xuICAgICAgICAgICAgICAgICcgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgK1xuICAgICAgICAgICAgICAnIDwnICsgKCtNICsgMSkgKyAnLjAuMCc7XG4gICAgfVxuXG4gICAgZGVidWcoJ2NhcmV0IHJldHVybicsIHJldCk7XG4gICAgcmV0dXJuIHJldDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VYUmFuZ2VzKGNvbXAsIG9wdGlvbnMpIHtcbiAgZGVidWcoJ3JlcGxhY2VYUmFuZ2VzJywgY29tcCwgb3B0aW9ucyk7XG4gIHJldHVybiBjb21wLnNwbGl0KC9cXHMrLykubWFwKGZ1bmN0aW9uKGNvbXApIHtcbiAgICByZXR1cm4gcmVwbGFjZVhSYW5nZShjb21wLCBvcHRpb25zKTtcbiAgfSkuam9pbignICcpO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlWFJhbmdlKGNvbXAsIG9wdGlvbnMpIHtcbiAgY29tcCA9IGNvbXAudHJpbSgpO1xuICBpZiAoIW9wdGlvbnMgfHwgdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKVxuICAgIG9wdGlvbnMgPSB7IGxvb3NlOiAhIW9wdGlvbnMsIGluY2x1ZGVQcmVyZWxlYXNlOiBmYWxzZSB9XG4gIHZhciByID0gb3B0aW9ucy5sb29zZSA/IHJlW1hSQU5HRUxPT1NFXSA6IHJlW1hSQU5HRV07XG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgZnVuY3Rpb24ocmV0LCBndGx0LCBNLCBtLCBwLCBwcikge1xuICAgIGRlYnVnKCd4UmFuZ2UnLCBjb21wLCByZXQsIGd0bHQsIE0sIG0sIHAsIHByKTtcbiAgICB2YXIgeE0gPSBpc1goTSk7XG4gICAgdmFyIHhtID0geE0gfHwgaXNYKG0pO1xuICAgIHZhciB4cCA9IHhtIHx8IGlzWChwKTtcbiAgICB2YXIgYW55WCA9IHhwO1xuXG4gICAgaWYgKGd0bHQgPT09ICc9JyAmJiBhbnlYKVxuICAgICAgZ3RsdCA9ICcnO1xuXG4gICAgaWYgKHhNKSB7XG4gICAgICBpZiAoZ3RsdCA9PT0gJz4nIHx8IGd0bHQgPT09ICc8Jykge1xuICAgICAgICAvLyBub3RoaW5nIGlzIGFsbG93ZWRcbiAgICAgICAgcmV0ID0gJzwwLjAuMCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBub3RoaW5nIGlzIGZvcmJpZGRlblxuICAgICAgICByZXQgPSAnKic7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChndGx0ICYmIGFueVgpIHtcbiAgICAgIC8vIHJlcGxhY2UgWCB3aXRoIDBcbiAgICAgIGlmICh4bSlcbiAgICAgICAgbSA9IDA7XG4gICAgICBpZiAoeHApXG4gICAgICAgIHAgPSAwO1xuXG4gICAgICBpZiAoZ3RsdCA9PT0gJz4nKSB7XG4gICAgICAgIC8vID4xID0+ID49Mi4wLjBcbiAgICAgICAgLy8gPjEuMiA9PiA+PTEuMy4wXG4gICAgICAgIC8vID4xLjIuMyA9PiA+PSAxLjIuNFxuICAgICAgICBndGx0ID0gJz49JztcbiAgICAgICAgaWYgKHhtKSB7XG4gICAgICAgICAgTSA9ICtNICsgMTtcbiAgICAgICAgICBtID0gMDtcbiAgICAgICAgICBwID0gMDtcbiAgICAgICAgfSBlbHNlIGlmICh4cCkge1xuICAgICAgICAgIG0gPSArbSArIDE7XG4gICAgICAgICAgcCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZ3RsdCA9PT0gJzw9Jykge1xuICAgICAgICAvLyA8PTAuNy54IGlzIGFjdHVhbGx5IDwwLjguMCwgc2luY2UgYW55IDAuNy54IHNob3VsZFxuICAgICAgICAvLyBwYXNzLiAgU2ltaWxhcmx5LCA8PTcueCBpcyBhY3R1YWxseSA8OC4wLjAsIGV0Yy5cbiAgICAgICAgZ3RsdCA9ICc8JztcbiAgICAgICAgaWYgKHhtKVxuICAgICAgICAgIE0gPSArTSArIDE7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBtID0gK20gKyAxO1xuICAgICAgfVxuXG4gICAgICByZXQgPSBndGx0ICsgTSArICcuJyArIG0gKyAnLicgKyBwO1xuICAgIH0gZWxzZSBpZiAoeG0pIHtcbiAgICAgIHJldCA9ICc+PScgKyBNICsgJy4wLjAgPCcgKyAoK00gKyAxKSArICcuMC4wJztcbiAgICB9IGVsc2UgaWYgKHhwKSB7XG4gICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLjAgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnO1xuICAgIH1cblxuICAgIGRlYnVnKCd4UmFuZ2UgcmV0dXJuJywgcmV0KTtcblxuICAgIHJldHVybiByZXQ7XG4gIH0pO1xufVxuXG4vLyBCZWNhdXNlICogaXMgQU5ELWVkIHdpdGggZXZlcnl0aGluZyBlbHNlIGluIHRoZSBjb21wYXJhdG9yLFxuLy8gYW5kICcnIG1lYW5zIFwiYW55IHZlcnNpb25cIiwganVzdCByZW1vdmUgdGhlICpzIGVudGlyZWx5LlxuZnVuY3Rpb24gcmVwbGFjZVN0YXJzKGNvbXAsIG9wdGlvbnMpIHtcbiAgZGVidWcoJ3JlcGxhY2VTdGFycycsIGNvbXAsIG9wdGlvbnMpO1xuICAvLyBMb29zZW5lc3MgaXMgaWdub3JlZCBoZXJlLiAgc3RhciBpcyBhbHdheXMgYXMgbG9vc2UgYXMgaXQgZ2V0cyFcbiAgcmV0dXJuIGNvbXAudHJpbSgpLnJlcGxhY2UocmVbU1RBUl0sICcnKTtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBwYXNzZWQgdG8gc3RyaW5nLnJlcGxhY2UocmVbSFlQSEVOUkFOR0VdKVxuLy8gTSwgbSwgcGF0Y2gsIHByZXJlbGVhc2UsIGJ1aWxkXG4vLyAxLjIgLSAzLjQuNSA9PiA+PTEuMi4wIDw9My40LjVcbi8vIDEuMi4zIC0gMy40ID0+ID49MS4yLjAgPDMuNS4wIEFueSAzLjQueCB3aWxsIGRvXG4vLyAxLjIgLSAzLjQgPT4gPj0xLjIuMCA8My41LjBcbmZ1bmN0aW9uIGh5cGhlblJlcGxhY2UoJDAsXG4gICAgICAgICAgICAgICAgICAgICAgIGZyb20sIGZNLCBmbSwgZnAsIGZwciwgZmIsXG4gICAgICAgICAgICAgICAgICAgICAgIHRvLCB0TSwgdG0sIHRwLCB0cHIsIHRiKSB7XG5cbiAgaWYgKGlzWChmTSkpXG4gICAgZnJvbSA9ICcnO1xuICBlbHNlIGlmIChpc1goZm0pKVxuICAgIGZyb20gPSAnPj0nICsgZk0gKyAnLjAuMCc7XG4gIGVsc2UgaWYgKGlzWChmcCkpXG4gICAgZnJvbSA9ICc+PScgKyBmTSArICcuJyArIGZtICsgJy4wJztcbiAgZWxzZVxuICAgIGZyb20gPSAnPj0nICsgZnJvbTtcblxuICBpZiAoaXNYKHRNKSlcbiAgICB0byA9ICcnO1xuICBlbHNlIGlmIChpc1godG0pKVxuICAgIHRvID0gJzwnICsgKCt0TSArIDEpICsgJy4wLjAnO1xuICBlbHNlIGlmIChpc1godHApKVxuICAgIHRvID0gJzwnICsgdE0gKyAnLicgKyAoK3RtICsgMSkgKyAnLjAnO1xuICBlbHNlIGlmICh0cHIpXG4gICAgdG8gPSAnPD0nICsgdE0gKyAnLicgKyB0bSArICcuJyArIHRwICsgJy0nICsgdHByO1xuICBlbHNlXG4gICAgdG8gPSAnPD0nICsgdG87XG5cbiAgcmV0dXJuIChmcm9tICsgJyAnICsgdG8pLnRyaW0oKTtcbn1cblxuXG4vLyBpZiBBTlkgb2YgdGhlIHNldHMgbWF0Y2ggQUxMIG9mIGl0cyBjb21wYXJhdG9ycywgdGhlbiBwYXNzXG5SYW5nZS5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uKHZlcnNpb24pIHtcbiAgaWYgKCF2ZXJzaW9uKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdzdHJpbmcnKVxuICAgIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIHRoaXMub3B0aW9ucyk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNldC5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0ZXN0U2V0KHRoaXMuc2V0W2ldLCB2ZXJzaW9uLCB0aGlzLm9wdGlvbnMpKVxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuZnVuY3Rpb24gdGVzdFNldChzZXQsIHZlcnNpb24sIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIXNldFtpXS50ZXN0KHZlcnNpb24pKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFvcHRpb25zKVxuICAgIG9wdGlvbnMgPSB7fVxuXG4gIGlmICh2ZXJzaW9uLnByZXJlbGVhc2UubGVuZ3RoICYmICFvcHRpb25zLmluY2x1ZGVQcmVyZWxlYXNlKSB7XG4gICAgLy8gRmluZCB0aGUgc2V0IG9mIHZlcnNpb25zIHRoYXQgYXJlIGFsbG93ZWQgdG8gaGF2ZSBwcmVyZWxlYXNlc1xuICAgIC8vIEZvciBleGFtcGxlLCBeMS4yLjMtcHIuMSBkZXN1Z2FycyB0byA+PTEuMi4zLXByLjEgPDIuMC4wXG4gICAgLy8gVGhhdCBzaG91bGQgYWxsb3cgYDEuMi4zLXByLjJgIHRvIHBhc3MuXG4gICAgLy8gSG93ZXZlciwgYDEuMi40LWFscGhhLm5vdHJlYWR5YCBzaG91bGQgTk9UIGJlIGFsbG93ZWQsXG4gICAgLy8gZXZlbiB0aG91Z2ggaXQncyB3aXRoaW4gdGhlIHJhbmdlIHNldCBieSB0aGUgY29tcGFyYXRvcnMuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlYnVnKHNldFtpXS5zZW12ZXIpO1xuICAgICAgaWYgKHNldFtpXS5zZW12ZXIgPT09IEFOWSlcbiAgICAgICAgY29udGludWU7XG5cbiAgICAgIGlmIChzZXRbaV0uc2VtdmVyLnByZXJlbGVhc2UubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgYWxsb3dlZCA9IHNldFtpXS5zZW12ZXI7XG4gICAgICAgIGlmIChhbGxvd2VkLm1ham9yID09PSB2ZXJzaW9uLm1ham9yICYmXG4gICAgICAgICAgICBhbGxvd2VkLm1pbm9yID09PSB2ZXJzaW9uLm1pbm9yICYmXG4gICAgICAgICAgICBhbGxvd2VkLnBhdGNoID09PSB2ZXJzaW9uLnBhdGNoKVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFZlcnNpb24gaGFzIGEgLXByZSwgYnV0IGl0J3Mgbm90IG9uZSBvZiB0aGUgb25lcyB3ZSBsaWtlLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnRzLnNhdGlzZmllcyA9IHNhdGlzZmllcztcbmZ1bmN0aW9uIHNhdGlzZmllcyh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucykge1xuICB0cnkge1xuICAgIHJhbmdlID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKTtcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHJhbmdlLnRlc3QodmVyc2lvbik7XG59XG5cbmV4cG9ydHMubWF4U2F0aXNmeWluZyA9IG1heFNhdGlzZnlpbmc7XG5mdW5jdGlvbiBtYXhTYXRpc2Z5aW5nKHZlcnNpb25zLCByYW5nZSwgb3B0aW9ucykge1xuICB2YXIgbWF4ID0gbnVsbDtcbiAgdmFyIG1heFNWID0gbnVsbDtcbiAgdHJ5IHtcbiAgICB2YXIgcmFuZ2VPYmogPSBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpO1xuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZlcnNpb25zLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICBpZiAocmFuZ2VPYmoudGVzdCh2KSkgeyAvLyBzYXRpc2ZpZXModiwgcmFuZ2UsIG9wdGlvbnMpXG4gICAgICBpZiAoIW1heCB8fCBtYXhTVi5jb21wYXJlKHYpID09PSAtMSkgeyAvLyBjb21wYXJlKG1heCwgdiwgdHJ1ZSlcbiAgICAgICAgbWF4ID0gdjtcbiAgICAgICAgbWF4U1YgPSBuZXcgU2VtVmVyKG1heCwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9KVxuICByZXR1cm4gbWF4O1xufVxuXG5leHBvcnRzLm1pblNhdGlzZnlpbmcgPSBtaW5TYXRpc2Z5aW5nO1xuZnVuY3Rpb24gbWluU2F0aXNmeWluZyh2ZXJzaW9ucywgcmFuZ2UsIG9wdGlvbnMpIHtcbiAgdmFyIG1pbiA9IG51bGw7XG4gIHZhciBtaW5TViA9IG51bGw7XG4gIHRyeSB7XG4gICAgdmFyIHJhbmdlT2JqID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKTtcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2ZXJzaW9ucy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgaWYgKHJhbmdlT2JqLnRlc3QodikpIHsgLy8gc2F0aXNmaWVzKHYsIHJhbmdlLCBvcHRpb25zKVxuICAgICAgaWYgKCFtaW4gfHwgbWluU1YuY29tcGFyZSh2KSA9PT0gMSkgeyAvLyBjb21wYXJlKG1pbiwgdiwgdHJ1ZSlcbiAgICAgICAgbWluID0gdjtcbiAgICAgICAgbWluU1YgPSBuZXcgU2VtVmVyKG1pbiwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9KVxuICByZXR1cm4gbWluO1xufVxuXG5leHBvcnRzLnZhbGlkUmFuZ2UgPSB2YWxpZFJhbmdlO1xuZnVuY3Rpb24gdmFsaWRSYW5nZShyYW5nZSwgb3B0aW9ucykge1xuICB0cnkge1xuICAgIC8vIFJldHVybiAnKicgaW5zdGVhZCBvZiAnJyBzbyB0aGF0IHRydXRoaW5lc3Mgd29ya3MuXG4gICAgLy8gVGhpcyB3aWxsIHRocm93IGlmIGl0J3MgaW52YWxpZCBhbnl3YXlcbiAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKS5yYW5nZSB8fCAnKic7XG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLy8gRGV0ZXJtaW5lIGlmIHZlcnNpb24gaXMgbGVzcyB0aGFuIGFsbCB0aGUgdmVyc2lvbnMgcG9zc2libGUgaW4gdGhlIHJhbmdlXG5leHBvcnRzLmx0ciA9IGx0cjtcbmZ1bmN0aW9uIGx0cih2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucykge1xuICByZXR1cm4gb3V0c2lkZSh2ZXJzaW9uLCByYW5nZSwgJzwnLCBvcHRpb25zKTtcbn1cblxuLy8gRGV0ZXJtaW5lIGlmIHZlcnNpb24gaXMgZ3JlYXRlciB0aGFuIGFsbCB0aGUgdmVyc2lvbnMgcG9zc2libGUgaW4gdGhlIHJhbmdlLlxuZXhwb3J0cy5ndHIgPSBndHI7XG5mdW5jdGlvbiBndHIodmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG91dHNpZGUodmVyc2lvbiwgcmFuZ2UsICc+Jywgb3B0aW9ucyk7XG59XG5cbmV4cG9ydHMub3V0c2lkZSA9IG91dHNpZGU7XG5mdW5jdGlvbiBvdXRzaWRlKHZlcnNpb24sIHJhbmdlLCBoaWxvLCBvcHRpb25zKSB7XG4gIHZlcnNpb24gPSBuZXcgU2VtVmVyKHZlcnNpb24sIG9wdGlvbnMpO1xuICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucyk7XG5cbiAgdmFyIGd0Zm4sIGx0ZWZuLCBsdGZuLCBjb21wLCBlY29tcDtcbiAgc3dpdGNoIChoaWxvKSB7XG4gICAgY2FzZSAnPic6XG4gICAgICBndGZuID0gZ3Q7XG4gICAgICBsdGVmbiA9IGx0ZTtcbiAgICAgIGx0Zm4gPSBsdDtcbiAgICAgIGNvbXAgPSAnPic7XG4gICAgICBlY29tcCA9ICc+PSc7XG4gICAgICBicmVhaztcbiAgICBjYXNlICc8JzpcbiAgICAgIGd0Zm4gPSBsdDtcbiAgICAgIGx0ZWZuID0gZ3RlO1xuICAgICAgbHRmbiA9IGd0O1xuICAgICAgY29tcCA9ICc8JztcbiAgICAgIGVjb21wID0gJzw9JztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNdXN0IHByb3ZpZGUgYSBoaWxvIHZhbCBvZiBcIjxcIiBvciBcIj5cIicpO1xuICB9XG5cbiAgLy8gSWYgaXQgc2F0aXNpZmVzIHRoZSByYW5nZSBpdCBpcyBub3Qgb3V0c2lkZVxuICBpZiAoc2F0aXNmaWVzKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEZyb20gbm93IG9uLCB2YXJpYWJsZSB0ZXJtcyBhcmUgYXMgaWYgd2UncmUgaW4gXCJndHJcIiBtb2RlLlxuICAvLyBidXQgbm90ZSB0aGF0IGV2ZXJ5dGhpbmcgaXMgZmxpcHBlZCBmb3IgdGhlIFwibHRyXCIgZnVuY3Rpb24uXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZS5zZXQubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgY29tcGFyYXRvcnMgPSByYW5nZS5zZXRbaV07XG5cbiAgICB2YXIgaGlnaCA9IG51bGw7XG4gICAgdmFyIGxvdyA9IG51bGw7XG5cbiAgICBjb21wYXJhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uKGNvbXBhcmF0b3IpIHtcbiAgICAgIGlmIChjb21wYXJhdG9yLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgICAgIGNvbXBhcmF0b3IgPSBuZXcgQ29tcGFyYXRvcignPj0wLjAuMCcpXG4gICAgICB9XG4gICAgICBoaWdoID0gaGlnaCB8fCBjb21wYXJhdG9yO1xuICAgICAgbG93ID0gbG93IHx8IGNvbXBhcmF0b3I7XG4gICAgICBpZiAoZ3Rmbihjb21wYXJhdG9yLnNlbXZlciwgaGlnaC5zZW12ZXIsIG9wdGlvbnMpKSB7XG4gICAgICAgIGhpZ2ggPSBjb21wYXJhdG9yO1xuICAgICAgfSBlbHNlIGlmIChsdGZuKGNvbXBhcmF0b3Iuc2VtdmVyLCBsb3cuc2VtdmVyLCBvcHRpb25zKSkge1xuICAgICAgICBsb3cgPSBjb21wYXJhdG9yO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gSWYgdGhlIGVkZ2UgdmVyc2lvbiBjb21wYXJhdG9yIGhhcyBhIG9wZXJhdG9yIHRoZW4gb3VyIHZlcnNpb25cbiAgICAvLyBpc24ndCBvdXRzaWRlIGl0XG4gICAgaWYgKGhpZ2gub3BlcmF0b3IgPT09IGNvbXAgfHwgaGlnaC5vcGVyYXRvciA9PT0gZWNvbXApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgbG93ZXN0IHZlcnNpb24gY29tcGFyYXRvciBoYXMgYW4gb3BlcmF0b3IgYW5kIG91ciB2ZXJzaW9uXG4gICAgLy8gaXMgbGVzcyB0aGFuIGl0IHRoZW4gaXQgaXNuJ3QgaGlnaGVyIHRoYW4gdGhlIHJhbmdlXG4gICAgaWYgKCghbG93Lm9wZXJhdG9yIHx8IGxvdy5vcGVyYXRvciA9PT0gY29tcCkgJiZcbiAgICAgICAgbHRlZm4odmVyc2lvbiwgbG93LnNlbXZlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGxvdy5vcGVyYXRvciA9PT0gZWNvbXAgJiYgbHRmbih2ZXJzaW9uLCBsb3cuc2VtdmVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0cy5wcmVyZWxlYXNlID0gcHJlcmVsZWFzZTtcbmZ1bmN0aW9uIHByZXJlbGVhc2UodmVyc2lvbiwgb3B0aW9ucykge1xuICB2YXIgcGFyc2VkID0gcGFyc2UodmVyc2lvbiwgb3B0aW9ucyk7XG4gIHJldHVybiAocGFyc2VkICYmIHBhcnNlZC5wcmVyZWxlYXNlLmxlbmd0aCkgPyBwYXJzZWQucHJlcmVsZWFzZSA6IG51bGw7XG59XG5cbmV4cG9ydHMuaW50ZXJzZWN0cyA9IGludGVyc2VjdHM7XG5mdW5jdGlvbiBpbnRlcnNlY3RzKHIxLCByMiwgb3B0aW9ucykge1xuICByMSA9IG5ldyBSYW5nZShyMSwgb3B0aW9ucylcbiAgcjIgPSBuZXcgUmFuZ2UocjIsIG9wdGlvbnMpXG4gIHJldHVybiByMS5pbnRlcnNlY3RzKHIyKVxufVxuXG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbmZ1bmN0aW9uIGNvZXJjZSh2ZXJzaW9uKSB7XG4gIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKVxuICAgIHJldHVybiB2ZXJzaW9uO1xuXG4gIGlmICh0eXBlb2YgdmVyc2lvbiAhPT0gJ3N0cmluZycpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgdmFyIG1hdGNoID0gdmVyc2lvbi5tYXRjaChyZVtDT0VSQ0VdKTtcblxuICBpZiAobWF0Y2ggPT0gbnVsbClcbiAgICByZXR1cm4gbnVsbDtcblxuICByZXR1cm4gcGFyc2UoKG1hdGNoWzFdIHx8ICcwJykgKyAnLicgKyAobWF0Y2hbMl0gfHwgJzAnKSArICcuJyArIChtYXRjaFszXSB8fCAnMCcpKTsgXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAvVXNlcnMvZ25pZGFuL3NyYy93b3JrL3RydWZmbGUvbm9kZV9tb2R1bGVzL3NlbXZlci9zZW12ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInRydWZmbGUtZGVjb2RlclwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcInRydWZmbGUtZGVjb2RlclwiXG4vLyBtb2R1bGUgaWQgPSA1MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6c2Vzc2lvbjpzYWdhc1wiKTtcblxuaW1wb3J0IHsgY2FsbCwgYWxsLCBmb3JrLCB0YWtlLCBwdXQgfSBmcm9tIFwicmVkdXgtc2FnYS9lZmZlY3RzXCI7XG5cbmltcG9ydCB7IHByZWZpeE5hbWUgfSBmcm9tIFwibGliL2hlbHBlcnNcIjtcblxuaW1wb3J0ICogYXMgYXN0IGZyb20gXCJsaWIvYXN0L3NhZ2FzXCI7XG5pbXBvcnQgKiBhcyBjb250cm9sbGVyIGZyb20gXCJsaWIvY29udHJvbGxlci9zYWdhc1wiO1xuaW1wb3J0ICogYXMgc29saWRpdHkgZnJvbSBcImxpYi9zb2xpZGl0eS9zYWdhc1wiO1xuaW1wb3J0ICogYXMgZXZtIGZyb20gXCJsaWIvZXZtL3NhZ2FzXCI7XG5pbXBvcnQgKiBhcyB0cmFjZSBmcm9tIFwibGliL3RyYWNlL3NhZ2FzXCI7XG5pbXBvcnQgKiBhcyBkYXRhIGZyb20gXCJsaWIvZGF0YS9zYWdhc1wiO1xuaW1wb3J0ICogYXMgd2ViMyBmcm9tIFwibGliL3dlYjMvc2FnYXNcIjtcblxuaW1wb3J0ICogYXMgYWN0aW9ucyBmcm9tIFwiLi4vYWN0aW9uc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24qIHNhZ2EoKSB7XG4gIGRlYnVnKFwic3RhcnRpbmcgbGlzdGVuZXJzXCIpO1xuICB5aWVsZCogZm9ya0xpc3RlbmVycygpO1xuXG4gIC8vIHJlY2VpdmluZyAmIHNhdmluZyBjb250cmFjdHMgaW50byBzdGF0ZVxuICBkZWJ1ZyhcIndhaXRpbmcgZm9yIGNvbnRyYWN0IGluZm9ybWF0aW9uXCIpO1xuICBsZXQgeyBjb250ZXh0cywgc291cmNlcyB9ID0geWllbGQgdGFrZShhY3Rpb25zLlJFQ09SRF9DT05UUkFDVFMpO1xuXG4gIGRlYnVnKFwicmVjb3JkaW5nIGNvbnRyYWN0IGJpbmFyaWVzXCIpO1xuICB5aWVsZCogcmVjb3JkQ29udGV4dHMoLi4uY29udGV4dHMpO1xuXG4gIGRlYnVnKFwicmVjb3JkaW5nIGNvbnRyYWN0IHNvdXJjZXNcIik7XG4gIHlpZWxkKiByZWNvcmRTb3VyY2VzKC4uLnNvdXJjZXMpO1xuXG4gIGRlYnVnKFwid2FpdGluZyBmb3Igc3RhcnRcIik7XG4gIC8vIHdhaXQgZm9yIHN0YXJ0IHNpZ25hbFxuICBsZXQgeyB0eEhhc2gsIHByb3ZpZGVyIH0gPSB5aWVsZCB0YWtlKGFjdGlvbnMuU1RBUlQpO1xuICBkZWJ1ZyhcInN0YXJ0aW5nXCIpO1xuXG4gIC8vIHByb2Nlc3MgdHJhbnNhY3Rpb25cbiAgZGVidWcoXCJmZXRjaGluZyB0cmFuc2FjdGlvbiBpbmZvXCIpO1xuICBsZXQgZXJyID0geWllbGQqIGZldGNoVHgodHhIYXNoLCBwcm92aWRlcik7XG4gIGlmIChlcnIpIHtcbiAgICBkZWJ1ZyhcImVycm9yICVvXCIsIGVycik7XG4gICAgeWllbGQqIGVycm9yKGVycik7XG4gIH0gZWxzZSB7XG4gICAgZGVidWcoXCJ2aXNpdGluZyBBU1RzXCIpO1xuICAgIC8vIHZpc2l0IGFzdHNcbiAgICB5aWVsZCogYXN0LnZpc2l0QWxsKCk7XG5cbiAgICBkZWJ1ZyhcInJlYWR5aW5nXCIpO1xuICAgIC8vIHNpZ25hbCB0aGF0IHN0ZXBwaW5nIGNhbiBiZWdpblxuICAgIHlpZWxkKiByZWFkeSgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHByZWZpeE5hbWUoXCJzZXNzaW9uXCIsIHNhZ2EpO1xuXG5mdW5jdGlvbiogZm9ya0xpc3RlbmVycygpIHtcbiAgcmV0dXJuIHlpZWxkIGFsbChcbiAgICBbYXN0LCBjb250cm9sbGVyLCBkYXRhLCBldm0sIHNvbGlkaXR5LCB0cmFjZSwgd2ViM10ubWFwKGFwcCA9PlxuICAgICAgZm9yayhhcHAuc2FnYSlcbiAgICApXG4gICk7XG59XG5cbmZ1bmN0aW9uKiBmZXRjaFR4KHR4SGFzaCwgcHJvdmlkZXIpIHtcbiAgbGV0IHJlc3VsdCA9IHlpZWxkKiB3ZWIzLmluc3BlY3RUcmFuc2FjdGlvbih0eEhhc2gsIHByb3ZpZGVyKTtcblxuICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgcmV0dXJuIHJlc3VsdC5lcnJvcjtcbiAgfVxuXG4gIHlpZWxkKiBldm0uYmVnaW4ocmVzdWx0KTtcblxuICBsZXQgYWRkcmVzc2VzID0geWllbGQqIHRyYWNlLnByb2Nlc3NUcmFjZShyZXN1bHQudHJhY2UpO1xuICBpZiAocmVzdWx0LmFkZHJlc3MgJiYgYWRkcmVzc2VzLmluZGV4T2YocmVzdWx0LmFkZHJlc3MpID09IC0xKSB7XG4gICAgYWRkcmVzc2VzLnB1c2gocmVzdWx0LmFkZHJlc3MpO1xuICB9XG5cbiAgbGV0IGJpbmFyaWVzID0geWllbGQqIHdlYjMub2J0YWluQmluYXJpZXMoYWRkcmVzc2VzKTtcblxuICB5aWVsZCBhbGwoXG4gICAgYWRkcmVzc2VzLm1hcCgoYWRkcmVzcywgaSkgPT4gY2FsbChyZWNvcmRJbnN0YW5jZSwgYWRkcmVzcywgYmluYXJpZXNbaV0pKVxuICApO1xufVxuXG5mdW5jdGlvbiogcmVjb3JkQ29udGV4dHMoLi4uY29udGV4dHMpIHtcbiAgZm9yIChsZXQgeyBjb250cmFjdE5hbWUsIGJpbmFyeSwgc291cmNlTWFwLCBjb21waWxlciB9IG9mIGNvbnRleHRzKSB7XG4gICAgeWllbGQqIGV2bS5hZGRDb250ZXh0KGNvbnRyYWN0TmFtZSwgeyBiaW5hcnkgfSwgY29tcGlsZXIpO1xuXG4gICAgaWYgKHNvdXJjZU1hcCkge1xuICAgICAgeWllbGQqIHNvbGlkaXR5LmFkZFNvdXJjZU1hcChiaW5hcnksIHNvdXJjZU1hcCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uKiByZWNvcmRTb3VyY2VzKC4uLnNvdXJjZXMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc291cmNlRGF0YSA9IHNvdXJjZXNbaV07XG4gICAgaWYgKHNvdXJjZURhdGEgIT09IHVuZGVmaW5lZCAmJiBzb3VyY2VEYXRhICE9PSBudWxsKSB7XG4gICAgICB5aWVsZCogc29saWRpdHkuYWRkU291cmNlKFxuICAgICAgICBzb3VyY2VEYXRhLnNvdXJjZSxcbiAgICAgICAgc291cmNlRGF0YS5zb3VyY2VQYXRoLFxuICAgICAgICBzb3VyY2VEYXRhLmFzdFxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24qIHJlY29yZEluc3RhbmNlKGFkZHJlc3MsIGJpbmFyeSkge1xuICB5aWVsZCogZXZtLmFkZEluc3RhbmNlKGFkZHJlc3MsIGJpbmFyeSk7XG59XG5cbmZ1bmN0aW9uKiByZWFkeSgpIHtcbiAgeWllbGQgcHV0KGFjdGlvbnMucmVhZHkoKSk7XG59XG5cbmZ1bmN0aW9uKiBlcnJvcihlcnIpIHtcbiAgeWllbGQgcHV0KGFjdGlvbnMuZXJyb3IoZXJyKSk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3Nlc3Npb24vc2FnYXMvaW5kZXguanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6YXN0OnNhZ2FzXCIpO1xuXG5pbXBvcnQgeyBhbGwsIGNhbGwsIHJhY2UsIGZvcmssIGpvaW4sIHRha2UsIHRha2VFdmVyeSwgcHV0LCBzZWxlY3QgfSBmcm9tIFwicmVkdXgtc2FnYS9lZmZlY3RzXCI7XG5cbmltcG9ydCB7IHByZWZpeE5hbWUgfSBmcm9tIFwibGliL2hlbHBlcnNcIjtcblxuaW1wb3J0ICogYXMgZGF0YSBmcm9tIFwibGliL2RhdGEvc2FnYXNcIjtcblxuaW1wb3J0ICogYXMgYWN0aW9ucyBmcm9tIFwiLi4vYWN0aW9uc1wiO1xuXG5pbXBvcnQgYXN0IGZyb20gXCIuLi9zZWxlY3RvcnNcIjtcblxuXG5mdW5jdGlvbiAqd2Fsayhzb3VyY2VJZCwgbm9kZSwgcG9pbnRlciA9IFwiXCIsIHBhcmVudElkID0gbnVsbCkge1xuICBkZWJ1ZyhcIndhbGtpbmcgJW8gJW9cIiwgcG9pbnRlciwgbm9kZSk7XG5cbiAgeWllbGQgKmhhbmRsZUVudGVyKHNvdXJjZUlkLCBub2RlLCBwb2ludGVyLCBwYXJlbnRJZCk7XG5cbiAgaWYgKG5vZGUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIGZvciAobGV0IFtpLCBjaGlsZF0gb2Ygbm9kZS5lbnRyaWVzKCkpIHtcbiAgICAgIHlpZWxkIGNhbGwod2Fsaywgc291cmNlSWQsIGNoaWxkLCBgJHtwb2ludGVyfS8ke2l9YCwgcGFyZW50SWQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgZm9yIChsZXQgW2tleSwgY2hpbGRdIG9mIE9iamVjdC5lbnRyaWVzKG5vZGUpKSB7XG4gICAgICB5aWVsZCBjYWxsKHdhbGssIHNvdXJjZUlkLCBjaGlsZCwgYCR7cG9pbnRlcn0vJHtrZXl9YCwgbm9kZS5pZCk7XG4gICAgfVxuICB9XG5cbiAgeWllbGQgKmhhbmRsZUV4aXQoc291cmNlSWQsIG5vZGUsIHBvaW50ZXIpO1xufVxuXG5mdW5jdGlvbiAqaGFuZGxlRW50ZXIoc291cmNlSWQsIG5vZGUsIHBvaW50ZXIsIHBhcmVudElkKSB7XG4gIGlmICghKG5vZGUgaW5zdGFuY2VvZiBPYmplY3QpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZGVidWcoXCJlbnRlcmluZyAlc1wiLCBwb2ludGVyKTtcblxuICBpZiAobm9kZS5pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZGVidWcoXCIlcyByZWNvcmRpbmcgc2NvcGUgJXNcIiwgcG9pbnRlciwgbm9kZS5pZCk7XG4gICAgeWllbGQgKmRhdGEuc2NvcGUobm9kZS5pZCwgcG9pbnRlciwgcGFyZW50SWQsIHNvdXJjZUlkKTtcbiAgfVxuXG4gIHN3aXRjaCAobm9kZS5ub2RlVHlwZSkge1xuICAgIGNhc2UgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCI6XG4gICAgICBkZWJ1ZyhcIiVzIHJlY29yZGluZyB2YXJpYWJsZSAlb1wiLCBwb2ludGVyLCBub2RlKTtcbiAgICAgIHlpZWxkICpkYXRhLmRlY2xhcmUobm9kZSk7XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiAqaGFuZGxlRXhpdChzb3VyY2VJZCwgbm9kZSwgcG9pbnRlcikge1xuICBkZWJ1ZyhcImV4aXRpbmcgJXNcIiwgcG9pbnRlcik7XG5cbiAgLy8gbm8tb3AgcmlnaHQgbm93XG59XG5cbmZ1bmN0aW9uICp3YWxrU2FnYSh7c291cmNlSWQsIGFzdH0pIHtcbiAgeWllbGQgd2Fsayhzb3VyY2VJZCwgYXN0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uICp2aXNpdEFsbChpZHgpIHtcbiAgbGV0IHNvdXJjZXMgPSB5aWVsZCBzZWxlY3QoYXN0LnZpZXdzLnNvdXJjZXMpO1xuXG4gIGxldCB0YXNrcyA9IHlpZWxkIGFsbChcbiAgICBPYmplY3QuZW50cmllcyhzb3VyY2VzKVxuICAgICAgLmZpbHRlciggKFtpZCwge2FzdH1dKSA9PiAhIWFzdCApXG4gICAgICAubWFwKCAoW2lkLCB7YXN0fV0pID0+IGZvcmsoICgpID0+IHB1dChhY3Rpb25zLnZpc2l0KGlkLCBhc3QpKSkgKVxuICApO1xuXG4gIGlmICh0YXNrcy5sZW5ndGggPiAwKSB7XG4gICAgeWllbGQgam9pbiguLi50YXNrcyk7XG4gIH1cblxuICB5aWVsZCBwdXQoYWN0aW9ucy5kb25lVmlzaXRpbmcoKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogc2FnYSgpIHtcbiAgeWllbGQgcmFjZSh7XG4gICAgdmlzaXRvcjogdGFrZUV2ZXJ5KGFjdGlvbnMuVklTSVQsIHdhbGtTYWdhKSxcbiAgICBkb25lOiB0YWtlKGFjdGlvbnMuRE9ORV9WSVNJVElORylcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHByZWZpeE5hbWUoXCJhc3RcIiwgc2FnYSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2FzdC9zYWdhcy9pbmRleC5qcyIsImV4cG9ydCBjb25zdCBWSVNJVCA9IFwiVklTSVRcIjtcbmV4cG9ydCBmdW5jdGlvbiB2aXNpdChzb3VyY2VJZCwgYXN0KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogVklTSVQsXG4gICAgc291cmNlSWQsXG5hc3RcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IERPTkVfVklTSVRJTkcgPSBcIkRPTkVfVklTSVRJTkdcIjtcbmV4cG9ydCBmdW5jdGlvbiBkb25lVmlzaXRpbmcoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogRE9ORV9WSVNJVElOR1xuICB9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9hc3QvYWN0aW9ucy9pbmRleC5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjpjb250cm9sbGVyOnNhZ2FzXCIpO1xuXG5pbXBvcnQgeyBwdXQsIGNhbGwsIHJhY2UsIHRha2UsIHNlbGVjdCB9IGZyb20gXCJyZWR1eC1zYWdhL2VmZmVjdHNcIjtcblxuaW1wb3J0IHsgcHJlZml4TmFtZSB9IGZyb20gXCJsaWIvaGVscGVyc1wiO1xuXG5pbXBvcnQgKiBhcyB0cmFjZSBmcm9tIFwibGliL3RyYWNlL3NhZ2FzXCI7XG5pbXBvcnQgKiBhcyBkYXRhIGZyb20gXCJsaWIvZGF0YS9zYWdhc1wiO1xuaW1wb3J0ICogYXMgZXZtIGZyb20gXCJsaWIvZXZtL3NhZ2FzXCI7XG5pbXBvcnQgKiBhcyBzb2xpZGl0eSBmcm9tIFwibGliL3NvbGlkaXR5L3NhZ2FzXCI7XG5cbmltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSBcIi4uL2FjdGlvbnNcIjtcblxuaW1wb3J0IGNvbnRyb2xsZXIgZnJvbSBcIi4uL3NlbGVjdG9yc1wiO1xuXG5jb25zdCBDT05UUk9MX1NBR0FTID0ge1xuICBbYWN0aW9ucy5BRFZBTkNFXTogYWR2YW5jZSxcbiAgW2FjdGlvbnMuU1RFUF9ORVhUXTogc3RlcE5leHQsXG4gIFthY3Rpb25zLlNURVBfT1ZFUl06IHN0ZXBPdmVyLFxuICBbYWN0aW9ucy5TVEVQX0lOVE9dOiBzdGVwSW50byxcbiAgW2FjdGlvbnMuU1RFUF9PVVRdOiBzdGVwT3V0LFxuICBbYWN0aW9ucy5DT05USU5VRV06IGNvbnRpbnVlVW50aWxCcmVha3BvaW50LFxuICBbYWN0aW9ucy5SRVNFVF06IHJlc2V0XG59O1xuXG4vKiogQVNUIG5vZGUgdHlwZXMgdGhhdCBhcmUgc2tpcHBlZCB0byBmaWx0ZXIgb3V0IHNvbWUgbm9pc2UgKi9cbmNvbnN0IFNLSVBQRURfVFlQRVMgPSBuZXcgU2V0KFtcIkNvbnRyYWN0RGVmaW5pdGlvblwiLCBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIl0pO1xuXG5leHBvcnQgZnVuY3Rpb24qIHNhZ2EoKSB7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgZGVidWcoXCJ3YWl0aW5nIGZvciBjb250cm9sIGFjdGlvblwiKTtcbiAgICBsZXQgYWN0aW9uID0geWllbGQgdGFrZShPYmplY3Qua2V5cyhDT05UUk9MX1NBR0FTKSk7XG4gICAgZGVidWcoXCJnb3QgY29udHJvbCBhY3Rpb25cIik7XG4gICAgbGV0IHNhZ2EgPSBDT05UUk9MX1NBR0FTW2FjdGlvbi50eXBlXTtcblxuICAgIHlpZWxkIHB1dChhY3Rpb25zLmJlZ2luU3RlcChhY3Rpb24udHlwZSkpO1xuXG4gICAgeWllbGQgcmFjZSh7XG4gICAgICBleGVjOiBjYWxsKHNhZ2EsIGFjdGlvbiksXG4gICAgICBpbnRlcnJ1cHQ6IHRha2UoYWN0aW9ucy5JTlRFUlJVUFQpXG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgcHJlZml4TmFtZShcImNvbnRyb2xsZXJcIiwgc2FnYSk7XG5cbi8qKlxuICogQWR2YW5jZSB0aGUgc3RhdGUgYnkgb25lIGluc3RydWN0aW9uXG4gKi9cbmZ1bmN0aW9uKiBhZHZhbmNlKCkge1xuICAvLyBzZW5kIGFjdGlvbiB0byBhZHZhbmNlIHRyYWNlXG4gIHlpZWxkKiB0cmFjZS5hZHZhbmNlKCk7XG59XG5cbi8qKlxuICogc3RlcE5leHQgLSBzdGVwIHRvIHRoZSBuZXh0IGxvZ2ljYWwgY29kZSBzZWdtZW50XG4gKlxuICogTm90ZTogSXQgbWlnaHQgdGFrZSBtdWx0aXBsZSBpbnN0cnVjdGlvbnMgdG8gZXhwcmVzcyB0aGUgc2FtZSBzZWN0aW9uIG9mIGNvZGUuXG4gKiBcIlN0ZXBwaW5nXCIsIHRoZW4sIGlzIHN0ZXBwaW5nIHRvIHRoZSBuZXh0IGxvZ2ljYWwgaXRlbSwgbm90IHN0ZXBwaW5nIHRvIHRoZSBuZXh0XG4gKiBpbnN0cnVjdGlvbi4gU2VlIGFkdmFuY2UoKSBpZiB5b3UnZCBsaWtlIHRvIGFkdmFuY2UgYnkgb25lIGluc3RydWN0aW9uLlxuICovXG5mdW5jdGlvbiogc3RlcE5leHQoKSB7XG4gIGNvbnN0IHN0YXJ0aW5nUmFuZ2UgPSB5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LmxvY2F0aW9uLnNvdXJjZVJhbmdlKTtcblxuICB2YXIgdXBjb21pbmcsIGZpbmlzaGVkO1xuXG4gIGRvIHtcbiAgICAvLyBhZHZhbmNlIGF0IGxlYXN0IG9uY2Ugc3RlcFxuICAgIHlpZWxkKiBhZHZhbmNlKCk7XG5cbiAgICAvLyBhbmQgY2hlY2sgdGhlIG5leHQgc291cmNlIHJhbmdlXG4gICAgdHJ5IHtcbiAgICAgIHVwY29taW5nID0geWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC5sb2NhdGlvbik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdXBjb21pbmcgPSBudWxsO1xuICAgIH1cblxuICAgIGZpbmlzaGVkID0geWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuZmluaXNoZWQpO1xuXG4gICAgLy8gaWYgdGhlIG5leHQgc3RlcCdzIHNvdXJjZSByYW5nZSBpcyBzdGlsbCB0aGUgc2FtZSwga2VlcCBnb2luZ1xuICB9IHdoaWxlIChcbiAgICAhZmluaXNoZWQgJiZcbiAgICAoIXVwY29taW5nIHx8XG4gICAgICAhdXBjb21pbmcubm9kZSB8fFxuICAgICAgU0tJUFBFRF9UWVBFUy5oYXModXBjb21pbmcubm9kZS5ub2RlVHlwZSkgfHxcbiAgICAgICh1cGNvbWluZy5zb3VyY2VSYW5nZS5zdGFydCA9PSBzdGFydGluZ1JhbmdlLnN0YXJ0ICYmXG4gICAgICAgIHVwY29taW5nLnNvdXJjZVJhbmdlLmxlbmd0aCA9PSBzdGFydGluZ1JhbmdlLmxlbmd0aCkpXG4gICk7XG59XG5cbi8qKlxuICogc3RlcEludG8gLSBzdGVwIGludG8gdGhlIGN1cnJlbnQgZnVuY3Rpb25cbiAqXG4gKiBDb25jZXB0dWFsbHkgdGhpcyBpcyBlYXN5LCBidXQgZnJvbSBhIHByb2dyYW1taW5nIHN0YW5kcG9pbnQgaXQncyBoYXJkLlxuICogQ29kZSBsaWtlIGBnZXRCYWxhbmNlKG1zZy5zZW5kZXIpYCBtaWdodCBiZSBoaWdobGlnaHRlZCwgYnV0IHRoZXJlIGNvdWxkXG4gKiBiZSBhIG51bWJlciBvZiBkaWZmZXJlbnQgaW50ZXJtZWRpYXRlIHN0ZXBzIChsaWtlIGV2YWx1YXRpbmcgYG1zZy5zZW5kZXJgKVxuICogYmVmb3JlIGBnZXRCYWxhbmNlYCBpcyBzdGVwcGVkIGludG8uIFRoaXMgZnVuY3Rpb24gd2lsbCBzdGVwIGludG8gdGhlIGZpcnN0XG4gKiBmdW5jdGlvbiBhdmFpbGFibGUgKHdoZXJlIGluc3RydWN0aW9uLmp1bXAgPT0gXCJpXCIpLCBpZ25vcmluZyBhbnkgaW50ZXJtZWRpYXRlXG4gKiBzdGVwcyB0aGF0IGZhbGwgd2l0aGluIHRoZSBzYW1lIGNvZGUgcmFuZ2UuIElmIHRoZXJlJ3MgYSBzdGVwIGVuY291bnRlcmVkXG4gKiB0aGF0IGV4aXN0cyBvdXRzaWRlIG9mIHRoZSByYW5nZSwgdGhlbiBzdGVwSW50byB3aWxsIG9ubHkgZXhlY3V0ZSB1bnRpbCB0aGF0XG4gKiBzdGVwLlxuICovXG5mdW5jdGlvbiogc3RlcEludG8oKSB7XG4gIGlmICh5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LndpbGxKdW1wKSkge1xuICAgIHlpZWxkKiBzdGVwTmV4dCgpO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb24uaXNNdWx0aWxpbmUpKSB7XG4gICAgeWllbGQqIHN0ZXBPdmVyKCk7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBzdGFydGluZ0RlcHRoID0geWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC5mdW5jdGlvbkRlcHRoKTtcbiAgY29uc3Qgc3RhcnRpbmdSYW5nZSA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb24uc291cmNlUmFuZ2UpO1xuICB2YXIgY3VycmVudERlcHRoO1xuICB2YXIgY3VycmVudFJhbmdlO1xuXG4gIGRvIHtcbiAgICB5aWVsZCogc3RlcE5leHQoKTtcblxuICAgIGN1cnJlbnREZXB0aCA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQuZnVuY3Rpb25EZXB0aCk7XG4gICAgY3VycmVudFJhbmdlID0geWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC5sb2NhdGlvbi5zb3VyY2VSYW5nZSk7XG4gIH0gd2hpbGUgKFxuICAgIC8vIHRoZSBmdW5jdGlvbiBzdGFjayBoYXMgbm90IGluY3JlYXNlZCxcbiAgICBjdXJyZW50RGVwdGggPD0gc3RhcnRpbmdEZXB0aCAmJlxuICAgIC8vIHRoZSBjdXJyZW50IHNvdXJjZSByYW5nZSBiZWdpbnMgb24gb3IgYWZ0ZXIgdGhlIHN0YXJ0aW5nIHJhbmdlXG4gICAgY3VycmVudFJhbmdlLnN0YXJ0ID49IHN0YXJ0aW5nUmFuZ2Uuc3RhcnQgJiZcbiAgICAvLyBhbmQgdGhlIGN1cnJlbnQgcmFuZ2UgZW5kcyBvbiBvciBiZWZvcmUgdGhlIHN0YXJ0aW5nIHJhbmdlIGVuZHNcbiAgICBjdXJyZW50UmFuZ2Uuc3RhcnQgKyBjdXJyZW50UmFuZ2UubGVuZ3RoIDw9XG4gICAgICBzdGFydGluZ1JhbmdlLnN0YXJ0ICsgc3RhcnRpbmdSYW5nZS5sZW5ndGhcbiAgKTtcbn1cblxuLyoqXG4gKiBTdGVwIG91dCBvZiB0aGUgY3VycmVudCBmdW5jdGlvblxuICpcbiAqIFRoaXMgd2lsbCBydW4gdW50aWwgdGhlIGRlYnVnZ2VyIGVuY291bnRlcnMgYSBkZWNyZWFzZSBpbiBmdW5jdGlvbiBkZXB0aC5cbiAqL1xuZnVuY3Rpb24qIHN0ZXBPdXQoKSB7XG4gIGlmICh5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LmxvY2F0aW9uLmlzTXVsdGlsaW5lKSkge1xuICAgIHlpZWxkKiBzdGVwT3ZlcigpO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3Qgc3RhcnRpbmdEZXB0aCA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQuZnVuY3Rpb25EZXB0aCk7XG4gIHZhciBjdXJyZW50RGVwdGg7XG5cbiAgZG8ge1xuICAgIHlpZWxkKiBzdGVwTmV4dCgpO1xuXG4gICAgY3VycmVudERlcHRoID0geWllbGQgc2VsZWN0KGNvbnRyb2xsZXIuY3VycmVudC5mdW5jdGlvbkRlcHRoKTtcbiAgfSB3aGlsZSAoY3VycmVudERlcHRoID49IHN0YXJ0aW5nRGVwdGgpO1xufVxuXG4vKipcbiAqIHN0ZXBPdmVyIC0gc3RlcCBvdmVyIHRoZSBjdXJyZW50IGxpbmVcbiAqXG4gKiBTdGVwIG92ZXIgdGhlIGN1cnJlbnQgbGluZS4gVGhpcyB3aWxsIHN0ZXAgdG8gdGhlIG5leHQgaW5zdHJ1Y3Rpb24gdGhhdFxuICogZXhpc3RzIG9uIGEgZGlmZmVyZW50IGxpbmUgb2YgY29kZSB3aXRoaW4gdGhlIHNhbWUgZnVuY3Rpb24gZGVwdGguXG4gKi9cbmZ1bmN0aW9uKiBzdGVwT3ZlcigpIHtcbiAgY29uc3Qgc3RhcnRpbmdEZXB0aCA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQuZnVuY3Rpb25EZXB0aCk7XG4gIGNvbnN0IHN0YXJ0aW5nUmFuZ2UgPSB5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LmxvY2F0aW9uLnNvdXJjZVJhbmdlKTtcbiAgdmFyIGN1cnJlbnREZXB0aDtcbiAgdmFyIGN1cnJlbnRSYW5nZTtcblxuICBkbyB7XG4gICAgeWllbGQqIHN0ZXBOZXh0KCk7XG5cbiAgICBjdXJyZW50RGVwdGggPSB5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LmZ1bmN0aW9uRGVwdGgpO1xuICAgIGN1cnJlbnRSYW5nZSA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb24uc291cmNlUmFuZ2UpO1xuICB9IHdoaWxlIChcbiAgICAvLyBrZWVwIHN0ZXBwaW5nIHByb3ZpZGVkOlxuICAgIC8vXG4gICAgLy8gd2UgaGF2ZW4ndCBqdW1wZWQgb3V0XG4gICAgIShjdXJyZW50RGVwdGggPCBzdGFydGluZ0RlcHRoKSAmJlxuICAgIC8vIGVpdGhlcjogZnVuY3Rpb24gZGVwdGggaXMgZ3JlYXRlciB0aGFuIHN0YXJ0aW5nIChpZ25vcmUgZnVuY3Rpb24gY2FsbHMpXG4gICAgLy8gb3IsIGlmIHdlJ3JlIGF0IHRoZSBzYW1lIGRlcHRoLCBrZWVwIHN0ZXBwaW5nIHVudGlsIHdlJ3JlIG9uIGEgbmV3XG4gICAgLy8gbGluZS5cbiAgICAoY3VycmVudERlcHRoID4gc3RhcnRpbmdEZXB0aCB8fFxuICAgICAgY3VycmVudFJhbmdlLmxpbmVzLnN0YXJ0LmxpbmUgPT0gc3RhcnRpbmdSYW5nZS5saW5lcy5zdGFydC5saW5lKVxuICApO1xufVxuXG4vKipcbiAqIGNvbnRpbnVlVW50aWxCcmVha3BvaW50IC0gc3RlcCB0aHJvdWdoIGV4ZWN1dGlvbiB1bnRpbCBhIGJyZWFrcG9pbnRcbiAqL1xuZnVuY3Rpb24qIGNvbnRpbnVlVW50aWxCcmVha3BvaW50KCkge1xuICB2YXIgY3VycmVudExvY2F0aW9uLCBjdXJyZW50Tm9kZSwgY3VycmVudExpbmUsIGN1cnJlbnRTb3VyY2VJZDtcbiAgdmFyIGZpbmlzaGVkO1xuICB2YXIgcHJldmlvdXNMaW5lLCBwcmV2aW91c1NvdXJjZUlkO1xuXG4gIGxldCBicmVha3BvaW50cyA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmJyZWFrcG9pbnRzKTtcblxuICBsZXQgYnJlYWtwb2ludEhpdCA9IGZhbHNlO1xuXG4gIGN1cnJlbnRMb2NhdGlvbiA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmN1cnJlbnQubG9jYXRpb24pO1xuICBjdXJyZW50Tm9kZSA9IGN1cnJlbnRMb2NhdGlvbi5ub2RlLmlkO1xuICBjdXJyZW50TGluZSA9IGN1cnJlbnRMb2NhdGlvbi5zb3VyY2VSYW5nZS5saW5lcy5zdGFydC5saW5lO1xuICBjdXJyZW50U291cmNlSWQgPSBjdXJyZW50TG9jYXRpb24uc291cmNlLmlkO1xuXG4gIGRvIHtcbiAgICB5aWVsZCogc3RlcE5leHQoKTtcblxuICAgIHByZXZpb3VzTGluZSA9IGN1cnJlbnRMaW5lO1xuICAgIHByZXZpb3VzU291cmNlSWQgPSBjdXJyZW50U291cmNlSWQ7XG5cbiAgICBjdXJyZW50TG9jYXRpb24gPSB5aWVsZCBzZWxlY3QoY29udHJvbGxlci5jdXJyZW50LmxvY2F0aW9uKTtcbiAgICBmaW5pc2hlZCA9IHlpZWxkIHNlbGVjdChjb250cm9sbGVyLmZpbmlzaGVkKTtcbiAgICBkZWJ1ZyhcImZpbmlzaGVkICVvXCIsIGZpbmlzaGVkKTtcblxuICAgIGN1cnJlbnROb2RlID0gY3VycmVudExvY2F0aW9uLm5vZGUuaWQ7XG4gICAgY3VycmVudExpbmUgPSBjdXJyZW50TG9jYXRpb24uc291cmNlUmFuZ2UubGluZXMuc3RhcnQubGluZTtcbiAgICBjdXJyZW50U291cmNlSWQgPSBjdXJyZW50TG9jYXRpb24uc291cmNlLmlkO1xuXG4gICAgYnJlYWtwb2ludEhpdCA9XG4gICAgICBicmVha3BvaW50cy5maWx0ZXIoKHsgc291cmNlSWQsIGxpbmUsIG5vZGUgfSkgPT4ge1xuICAgICAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZGVidWcoXCJub2RlICVkIGN1cnJlbnROb2RlICVkXCIsIG5vZGUsIGN1cnJlbnROb2RlKTtcbiAgICAgICAgICByZXR1cm4gc291cmNlSWQgPT09IGN1cnJlbnRTb3VyY2VJZCAmJiBub2RlID09PSBjdXJyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICAvL290aGVyd2lzZSwgd2UgaGF2ZSBhIGxpbmUtc3R5bGUgYnJlYWtwb2ludDsgd2Ugd2FudCB0byBzdG9wIGF0IHRoZVxuICAgICAgICAvLypmaXJzdCogcG9pbnQgb24gdGhlIGxpbmVcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBzb3VyY2VJZCA9PT0gY3VycmVudFNvdXJjZUlkICYmXG4gICAgICAgICAgbGluZSA9PT0gY3VycmVudExpbmUgJiZcbiAgICAgICAgICAoY3VycmVudFNvdXJjZUlkICE9PSBwcmV2aW91c1NvdXJjZUlkIHx8IGN1cnJlbnRMaW5lICE9PSBwcmV2aW91c0xpbmUpXG4gICAgICAgICk7XG4gICAgICB9KS5sZW5ndGggPiAwO1xuICB9IHdoaWxlICghYnJlYWtwb2ludEhpdCAmJiAhZmluaXNoZWQpO1xufVxuXG4vKipcbiAqIHJlc2V0IC0tIHJlc2V0IHRoZSBzdGF0ZSBvZiB0aGUgZGVidWdnZXJcbiAqL1xuZnVuY3Rpb24qIHJlc2V0KCkge1xuICB5aWVsZCogZGF0YS5yZXNldCgpO1xuICB5aWVsZCogZXZtLnJlc2V0KCk7XG4gIHlpZWxkKiBzb2xpZGl0eS5yZXNldCgpO1xuICB5aWVsZCogdHJhY2UucmVzZXQoKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvY29udHJvbGxlci9zYWdhcy9pbmRleC5qcyIsImltcG9ydCBkZWJ1Z01vZHVsZSBmcm9tIFwiZGVidWdcIjtcbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjp3ZWIzOnNhZ2FzXCIpO1xuXG5pbXBvcnQgeyBhbGwsIHRha2VFdmVyeSwgYXBwbHksIGZvcmssIGpvaW4sIHRha2UsIHB1dCwgc2VsZWN0IH0gZnJvbSAncmVkdXgtc2FnYS9lZmZlY3RzJztcbmltcG9ydCB7IHByZWZpeE5hbWUgfSBmcm9tIFwibGliL2hlbHBlcnNcIjtcblxuaW1wb3J0ICogYXMgYWN0aW9ucyBmcm9tIFwiLi4vYWN0aW9uc1wiO1xuaW1wb3J0ICogYXMgc2Vzc2lvbiBmcm9tIFwibGliL3Nlc3Npb24vYWN0aW9uc1wiO1xuXG5pbXBvcnQgV2ViM0FkYXB0ZXIgZnJvbSBcIi4uL2FkYXB0ZXJcIjtcblxuZnVuY3Rpb24qIGZldGNoVHJhbnNhY3Rpb25JbmZvKGFkYXB0ZXIsIHt0eEhhc2h9KSB7XG4gIGRlYnVnKFwiaW5zcGVjdGluZyB0cmFuc2FjdGlvblwiKTtcbiAgdmFyIHRyYWNlO1xuICB0cnkge1xuICAgIHRyYWNlID0geWllbGQgYXBwbHkoYWRhcHRlciwgYWRhcHRlci5nZXRUcmFjZSwgW3R4SGFzaF0pO1xuICB9IGNhdGNoKGUpIHtcbiAgICBkZWJ1ZyhcInB1dHRpbmcgZXJyb3JcIik7XG4gICAgeWllbGQgcHV0KGFjdGlvbnMuZXJyb3IoZSkpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGRlYnVnKFwiZ290IHRyYWNlXCIpO1xuICB5aWVsZCBwdXQoYWN0aW9ucy5yZWNlaXZlVHJhY2UodHJhY2UpKTtcblxuICBsZXQgdHggPSB5aWVsZCBhcHBseShhZGFwdGVyLCBhZGFwdGVyLmdldFRyYW5zYWN0aW9uLCBbdHhIYXNoXSk7XG4gIGxldCByZWNlaXB0ID0geWllbGQgYXBwbHkoYWRhcHRlciwgYWRhcHRlci5nZXRSZWNlaXB0LCBbdHhIYXNoXSk7XG5cbiAgeWllbGQgcHV0KHNlc3Npb24uc2F2ZVRyYW5zYWN0aW9uKHR4KSk7XG4gIHlpZWxkIHB1dChzZXNzaW9uLnNhdmVSZWNlaXB0KHJlY2VpcHQpKTtcblxuICBpZiAodHgudG8gJiYgdHgudG8gIT0gXCIweDBcIikge1xuICAgIHlpZWxkIHB1dChhY3Rpb25zLnJlY2VpdmVDYWxsKHthZGRyZXNzOiB0eC50b30pKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAocmVjZWlwdC5jb250cmFjdEFkZHJlc3MpIHtcbiAgICB5aWVsZCBwdXQoYWN0aW9ucy5yZWNlaXZlQ2FsbCh7YmluYXJ5OiB0eC5pbnB1dH0pKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgXCJDb3VsZCBub3QgZmluZCBjb250cmFjdCBhc3NvY2lhdGVkIHdpdGggdHJhbnNhY3Rpb24uIFwiICtcbiAgICBcIlBsZWFzZSBtYWtlIHN1cmUgeW91J3JlIGRlYnVnZ2luZyBhIHRyYW5zYWN0aW9uIHRoYXQgZXhlY3V0ZXMgYSBcIiArXG4gICAgXCJjb250cmFjdCBmdW5jdGlvbiBvciBjcmVhdGVzIGEgbmV3IGNvbnRyYWN0LlwiXG4gICk7XG59XG5cbmZ1bmN0aW9uKiBmZXRjaEJpbmFyeShhZGFwdGVyLCB7YWRkcmVzc30pIHtcbiAgZGVidWcoXCJmZXRjaGluZyBiaW5hcnkgZm9yICVzXCIsIGFkZHJlc3MpO1xuICBsZXQgYmluYXJ5ID0geWllbGQgYXBwbHkoYWRhcHRlciwgYWRhcHRlci5nZXREZXBsb3llZENvZGUsIFthZGRyZXNzXSk7XG5cbiAgZGVidWcoXCJyZWNlaXZlZCBiaW5hcnkgZm9yICVzXCIsIGFkZHJlc3MpO1xuICB5aWVsZCBwdXQoYWN0aW9ucy5yZWNlaXZlQmluYXJ5KGFkZHJlc3MsIGJpbmFyeSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gKmluc3BlY3RUcmFuc2FjdGlvbih0eEhhc2gsIHByb3ZpZGVyKSB7XG4gIHlpZWxkIHB1dChhY3Rpb25zLmluaXQocHJvdmlkZXIpKTtcbiAgeWllbGQgcHV0KGFjdGlvbnMuaW5zcGVjdCh0eEhhc2gpKTtcblxuICBsZXQgYWN0aW9uID0geWllbGQgdGFrZSggKHt0eXBlfSkgPT5cbiAgICB0eXBlID09IGFjdGlvbnMuUkVDRUlWRV9UUkFDRSB8fCB0eXBlID09IGFjdGlvbnMuRVJST1JfV0VCM1xuICApO1xuICBkZWJ1ZyhcImFjdGlvbiAlb1wiLCBhY3Rpb24pO1xuXG4gIHZhciB0cmFjZTtcbiAgaWYgKGFjdGlvbi50eXBlID09IGFjdGlvbnMuUkVDRUlWRV9UUkFDRSkge1xuICAgIHRyYWNlID0gYWN0aW9uLnRyYWNlO1xuICAgIGRlYnVnKFwicmVjZWl2ZWQgdHJhY2VcIik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgZXJyb3I6IGFjdGlvbi5lcnJvciB9O1xuICB9XG5cbiAgbGV0IHthZGRyZXNzLCBiaW5hcnl9ID0geWllbGQgdGFrZShhY3Rpb25zLlJFQ0VJVkVfQ0FMTCk7XG4gIGRlYnVnKFwicmVjZWl2ZWQgY2FsbFwiKTtcblxuICByZXR1cm4geyB0cmFjZSwgYWRkcmVzcywgYmluYXJ5IH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiAqb2J0YWluQmluYXJpZXMoYWRkcmVzc2VzKSB7XG4gIGxldCB0YXNrcyA9IHlpZWxkIGFsbChcbiAgICBhZGRyZXNzZXMubWFwKCAoYWRkcmVzcykgPT4gZm9yayhyZWNlaXZlQmluYXJ5LCBhZGRyZXNzKSApXG4gICk7XG5cbiAgZGVidWcoXCJyZXF1ZXN0aW5nIGJpbmFyaWVzXCIpO1xuICB5aWVsZCBhbGwoXG4gICAgYWRkcmVzc2VzLm1hcCggKGFkZHJlc3MpID0+IHB1dChhY3Rpb25zLmZldGNoQmluYXJ5KGFkZHJlc3MpKSApXG4gICk7XG5cbiAgbGV0IGJpbmFyaWVzID0gW107XG4gIGJpbmFyaWVzID0geWllbGQgYWxsKFxuICAgIHRhc2tzLm1hcCh0YXNrID0+IGpvaW4odGFzaykpXG4gICk7XG5cbiAgZGVidWcoXCJiaW5hcmllcyAlb1wiLCBiaW5hcmllcyk7XG5cbiAgcmV0dXJuIGJpbmFyaWVzO1xufVxuXG5mdW5jdGlvbiAqcmVjZWl2ZUJpbmFyeShhZGRyZXNzKSB7XG4gIGxldCB7YmluYXJ5fSA9IHlpZWxkIHRha2UoKGFjdGlvbikgPT4gKFxuICAgIGFjdGlvbi50eXBlID09IGFjdGlvbnMuUkVDRUlWRV9CSU5BUlkgJiZcbiAgICBhY3Rpb24uYWRkcmVzcyA9PSBhZGRyZXNzXG4gICkpO1xuICBkZWJ1ZyhcImdvdCBiaW5hcnkgZm9yICVzXCIsIGFkZHJlc3MpO1xuXG4gIHJldHVybiBiaW5hcnk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogc2FnYSgpIHtcbiAgLy8gd2FpdCBmb3Igd2ViMyBpbml0IHNpZ25hbFxuICBsZXQge3Byb3ZpZGVyfSA9IHlpZWxkIHRha2UoYWN0aW9ucy5JTklUX1dFQjMpO1xuICBsZXQgYWRhcHRlciA9IG5ldyBXZWIzQWRhcHRlcihwcm92aWRlcik7XG5cbiAgeWllbGQgdGFrZUV2ZXJ5KGFjdGlvbnMuSU5TUEVDVCwgZmV0Y2hUcmFuc2FjdGlvbkluZm8sIGFkYXB0ZXIpO1xuICB5aWVsZCB0YWtlRXZlcnkoYWN0aW9ucy5GRVRDSF9CSU5BUlksIGZldGNoQmluYXJ5LCBhZGFwdGVyKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcHJlZml4TmFtZShcIndlYjNcIiwgc2FnYSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3dlYjMvc2FnYXMvaW5kZXguanMiLCJleHBvcnQgY29uc3QgSU5JVF9XRUIzID0gXCJJTklUX1dFQjNcIjtcbmV4cG9ydCBmdW5jdGlvbiBpbml0KHByb3ZpZGVyKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogSU5JVF9XRUIzLFxuICAgIHByb3ZpZGVyXG4gIH07XG59XG5cbmV4cG9ydCBjb25zdCBJTlNQRUNUID0gXCJJTlNQRUNUX1RSQU5TQUNUSU9OXCI7XG5leHBvcnQgZnVuY3Rpb24gaW5zcGVjdCh0eEhhc2gpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBJTlNQRUNULFxuICAgIHR4SGFzaFxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgRkVUQ0hfQklOQVJZID0gXCJGRVRDSF9CSU5BUllcIjtcbmV4cG9ydCBmdW5jdGlvbiBmZXRjaEJpbmFyeShhZGRyZXNzKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogRkVUQ0hfQklOQVJZLFxuICAgIGFkZHJlc3NcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFJFQ0VJVkVfQklOQVJZID0gXCJSRUNFSVZFX0JJTkFSWVwiO1xuZXhwb3J0IGZ1bmN0aW9uIHJlY2VpdmVCaW5hcnkoYWRkcmVzcywgYmluYXJ5KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogUkVDRUlWRV9CSU5BUlksXG4gICAgYWRkcmVzcyxcbmJpbmFyeVxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgUkVDRUlWRV9UUkFDRSA9IFwiUkVDRUlWRV9UUkFDRVwiO1xuZXhwb3J0IGZ1bmN0aW9uIHJlY2VpdmVUcmFjZSh0cmFjZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFJFQ0VJVkVfVFJBQ0UsXG4gICAgdHJhY2VcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IFJFQ0VJVkVfQ0FMTCA9IFwiUkVDRUlWRV9DQUxMXCI7XG5leHBvcnQgZnVuY3Rpb24gcmVjZWl2ZUNhbGwoe2FkZHJlc3MsIGJpbmFyeX0pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBSRUNFSVZFX0NBTEwsXG4gICAgYWRkcmVzcyxcbmJpbmFyeVxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgRVJST1JfV0VCMyA9IFwiRVJST1JfV0VCM1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGVycm9yKGVycm9yKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogRVJST1JfV0VCMyxcbiAgICBlcnJvclxuICB9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi93ZWIzL2FjdGlvbnMvaW5kZXguanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5cbmltcG9ydCBXZWIzIGZyb20gXCJ3ZWIzXCI7XG5cbmNvbnN0IGRlYnVnID0gZGVidWdNb2R1bGUoXCJkZWJ1Z2dlcjp3ZWIzOmFkYXB0ZXJcIik7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYjNBZGFwdGVyIHtcbiAgY29uc3RydWN0b3IocHJvdmlkZXIpIHtcbiAgICB0aGlzLndlYjMgPSBuZXcgV2ViMyhwcm92aWRlcik7XG4gIH1cblxuICBhc3luYyBnZXRUcmFjZSh0eEhhc2gpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoIChhY2NlcHQsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy53ZWIzLmN1cnJlbnRQcm92aWRlci5zZW5kKHtcbiAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgbWV0aG9kOiBcImRlYnVnX3RyYWNlVHJhbnNhY3Rpb25cIixcbiAgICAgICAgcGFyYW1zOiBbdHhIYXNoLCB7fV0sXG4gICAgICAgIGlkOiBuZXcgRGF0ZSgpLmdldFRpbWUoKVxuICAgICAgfSwgKGVyciwgcmVzdWx0KSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgaWYgKHJlc3VsdC5lcnJvcikgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IocmVzdWx0LmVycm9yLm1lc3NhZ2UpKTtcbiAgICAgICAgZGVidWcoXCJyZXN1bHQ6ICVvXCIsIHJlc3VsdCk7XG4gICAgICAgIGFjY2VwdChyZXN1bHQucmVzdWx0LnN0cnVjdExvZ3MpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24odHhIYXNoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKCAoYWNjZXB0LCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMud2ViMy5ldGguZ2V0VHJhbnNhY3Rpb24odHhIYXNoLCAoZXJyLCB0eCkgPT4ge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0KGVycik7XG5cbiAgICAgICAgcmV0dXJuIGFjY2VwdCh0eCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBhc3luYyBnZXRSZWNlaXB0KHR4SGFzaCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSggKGFjY2VwdCwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLndlYjMuZXRoLmdldFRyYW5zYWN0aW9uUmVjZWlwdCh0eEhhc2gsIChlcnIsIHJlY2VpcHQpID0+IHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpO1xuXG4gICAgICAgIHJldHVybiBhY2NlcHQocmVjZWlwdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogZ2V0RGVwbG95ZWRDb2RlIC0gZ2V0IHRoZSBkZXBsb3llZCBjb2RlIGZvciBhbiBhZGRyZXNzIGZyb20gdGhlIGNsaWVudFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGFkZHJlc3NcbiAgICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgIGRlcGxveWVkQmluYXJ5XG4gICAqL1xuICBhc3luYyBnZXREZXBsb3llZENvZGUoYWRkcmVzcykge1xuICAgIGRlYnVnKFwiZ2V0dGluZyBkZXBsb3llZCBjb2RlIGZvciAlc1wiLCBhZGRyZXNzKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKGFjY2VwdCwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLndlYjMuZXRoLmdldENvZGUoYWRkcmVzcywgKGVyciwgZGVwbG95ZWRCaW5hcnkpID0+IHtcbiAgICAgICAgaWYgKGVycikgZGVidWcoXCJlcnJvcjogJW9cIiwgZXJyKTtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICBkZWJ1ZyhcImdvdCBkZXBsb3llZCBjb2RlIGZvciAlc1wiLCBhZGRyZXNzKTtcbiAgICAgICAgYWNjZXB0KGRlcGxveWVkQmluYXJ5KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi93ZWIzL2FkYXB0ZXIuanMiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJ3ZWIzXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwid2ViM1wiXG4vLyBtb2R1bGUgaWQgPSA1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBjb21iaW5lUmVkdWNlcnMgfSBmcm9tIFwicmVkdXhcIjtcblxuaW1wb3J0IGRhdGEgZnJvbSBcImxpYi9kYXRhL3JlZHVjZXJzXCI7XG5pbXBvcnQgZXZtIGZyb20gXCJsaWIvZXZtL3JlZHVjZXJzXCI7XG5pbXBvcnQgc29saWRpdHkgZnJvbSBcImxpYi9zb2xpZGl0eS9yZWR1Y2Vyc1wiO1xuaW1wb3J0IHRyYWNlIGZyb20gXCJsaWIvdHJhY2UvcmVkdWNlcnNcIjtcbmltcG9ydCBjb250cm9sbGVyIGZyb20gXCJsaWIvY29udHJvbGxlci9yZWR1Y2Vyc1wiO1xuXG5pbXBvcnQgKiBhcyBhY3Rpb25zIGZyb20gXCIuL2FjdGlvbnNcIjtcblxuZXhwb3J0IGNvbnN0IFdBSVRJTkcgPSBcIldBSVRJTkdcIjtcbmV4cG9ydCBjb25zdCBBQ1RJVkUgPSBcIkFDVElWRVwiO1xuZXhwb3J0IGNvbnN0IEVSUk9SID0gXCJFUlJPUlwiO1xuXG5leHBvcnQgZnVuY3Rpb24gc3RhdHVzKHN0YXRlID0gV0FJVElORywgYWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIGFjdGlvbnMuUkVBRFk6XG4gICAgICByZXR1cm4gQUNUSVZFO1xuXG4gICAgY2FzZSBhY3Rpb25zLkVSUk9SOlxuICAgICAgcmV0dXJuIHsgZXJyb3I6IGFjdGlvbi5lcnJvciB9O1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNhY3Rpb24oc3RhdGUgPSB7fSwgYWN0aW9uKSB7XG4gIHN3aXRjaChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgYWN0aW9ucy5TQVZFX1RSQU5TQUNUSU9OOlxuICAgICAgcmV0dXJuIGFjdGlvbi50cmFuc2FjdGlvbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWNlaXB0KHN0YXRlID0ge30sIGFjdGlvbikge1xuICBzd2l0Y2goYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIGFjdGlvbnMuU0FWRV9SRUNFSVBUOlxuICAgICAgcmV0dXJuIGFjdGlvbi5yZWNlaXB0O1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuY29uc3Qgc2Vzc2lvbiA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gIHN0YXR1cyxcbiAgdHJhbnNhY3Rpb24sXG4gIHJlY2VpcHRcbn0pO1xuXG5jb25zdCByZWR1Y2VTdGF0ZSA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gIHNlc3Npb24sXG4gIGRhdGEsXG4gIGV2bSxcbiAgc29saWRpdHksXG4gIHRyYWNlLFxuICBjb250cm9sbGVyXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgcmVkdWNlU3RhdGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL3Nlc3Npb24vcmVkdWNlcnMuanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6ZGF0YTpyZWR1Y2Vyc1wiKTtcblxuaW1wb3J0IHsgY29tYmluZVJlZHVjZXJzIH0gZnJvbSBcInJlZHV4XCI7XG5cbmltcG9ydCB7IHN0YWJsZUtlY2NhazI1NiB9IGZyb20gXCJsaWIvaGVscGVyc1wiO1xuXG5pbXBvcnQgKiBhcyBhY3Rpb25zIGZyb20gXCIuL2FjdGlvbnNcIjtcblxuY29uc3QgREVGQVVMVF9TQ09QRVMgPSB7XG4gIGJ5SWQ6IHt9XG59O1xuXG5mdW5jdGlvbiBzY29wZXMoc3RhdGUgPSBERUZBVUxUX1NDT1BFUywgYWN0aW9uKSB7XG4gIHZhciBzY29wZTtcbiAgdmFyIHZhcmlhYmxlcztcblxuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBhY3Rpb25zLlNDT1BFOlxuICAgICAgc2NvcGUgPSBzdGF0ZS5ieUlkW2FjdGlvbi5pZF0gfHwge307XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJ5SWQ6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5ieUlkLFxuXG4gICAgICAgICAgW2FjdGlvbi5pZF06IHtcbiAgICAgICAgICAgIC4uLnNjb3BlLFxuXG4gICAgICAgICAgICBpZDogYWN0aW9uLmlkLFxuICAgICAgICAgICAgc291cmNlSWQ6IGFjdGlvbi5zb3VyY2VJZCxcbiAgICAgICAgICAgIHBhcmVudElkOiBhY3Rpb24ucGFyZW50SWQsXG4gICAgICAgICAgICBwb2ludGVyOiBhY3Rpb24ucG9pbnRlclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgIGNhc2UgYWN0aW9ucy5ERUNMQVJFOlxuICAgICAgc2NvcGUgPSBzdGF0ZS5ieUlkW2FjdGlvbi5ub2RlLnNjb3BlXSB8fCB7fTtcbiAgICAgIHZhcmlhYmxlcyA9IHNjb3BlLnZhcmlhYmxlcyB8fCBbXTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYnlJZDoge1xuICAgICAgICAgIC4uLnN0YXRlLmJ5SWQsXG5cbiAgICAgICAgICBbYWN0aW9uLm5vZGUuc2NvcGVdOiB7XG4gICAgICAgICAgICAuLi5zY29wZSxcblxuICAgICAgICAgICAgdmFyaWFibGVzOiBbXG4gICAgICAgICAgICAgIC4uLnZhcmlhYmxlcyxcblxuICAgICAgICAgICAgICB7IG5hbWU6IGFjdGlvbi5ub2RlLm5hbWUsIGlkOiBhY3Rpb24ubm9kZS5pZCB9XG4gICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5jb25zdCBpbmZvID0gY29tYmluZVJlZHVjZXJzKHtcbiAgc2NvcGVzXG59KTtcblxuY29uc3QgREVGQVVMVF9BU1NJR05NRU5UUyA9IHtcbiAgYnlJZDoge30sXG4gIGJ5QXN0SWQ6IHt9XG59O1xuXG5mdW5jdGlvbiBhc3NpZ25tZW50cyhzdGF0ZSA9IERFRkFVTFRfQVNTSUdOTUVOVFMsIGFjdGlvbikge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBhY3Rpb25zLkFTU0lHTjpcbiAgICAgIGRlYnVnKFwiYWN0aW9uLmFzc2lnbm1lbnRzICVPXCIsIGFjdGlvbi5hc3NpZ25tZW50cyk7XG4gICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhhY3Rpb24uYXNzaWdubWVudHMuYnlJZCkucmVkdWNlKFxuICAgICAgICAoYWNjLCBhc3NpZ25tZW50KSA9PiB7XG4gICAgICAgICAgbGV0IHsgaWQsIGFzdElkIH0gPSBhc3NpZ25tZW50OyAvL3dlIGRvbid0IG5lZWQgdGhlIHJlc3RcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYnlJZDoge1xuICAgICAgICAgICAgICAuLi5hY2MuYnlJZCxcbiAgICAgICAgICAgICAgW2lkXTogYXNzaWdubWVudFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJ5QXN0SWQ6IHtcbiAgICAgICAgICAgICAgLi4uYWNjLmJ5QXN0SWQsXG4gICAgICAgICAgICAgIFthc3RJZF06IFsuLi5uZXcgU2V0KFsuLi4oYWNjLmJ5QXN0SWRbYXN0SWRdIHx8IFtdKSwgaWRdKV1cbiAgICAgICAgICAgICAgLy93ZSB1c2UgYSBzZXQgZm9yIHVuaXF1ZW5lc3NcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBzdGF0ZVxuICAgICAgKTtcblxuICAgIGNhc2UgYWN0aW9ucy5MRUFSTl9BRERSRVNTOlxuICAgICAgbGV0IHsgZHVtbXlBZGRyZXNzLCBhZGRyZXNzIH0gPSBhY3Rpb247XG4gICAgICByZXR1cm4ge1xuICAgICAgICBieUlkOiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIC4uLk9iamVjdC5lbnRyaWVzKHN0YXRlLmJ5SWQpLm1hcCgoWywgYXNzaWdubWVudF0pID0+IHtcbiAgICAgICAgICAgIGxldCBuZXdBc3NpZ25tZW50ID0gbGVhcm5BZGRyZXNzKGFzc2lnbm1lbnQsIGR1bW15QWRkcmVzcywgYWRkcmVzcyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBbbmV3QXNzaWdubWVudC5pZF06IG5ld0Fzc2lnbm1lbnRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSlcbiAgICAgICAgKSxcbiAgICAgICAgYnlBc3RJZDogT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICB7fSxcbiAgICAgICAgICAuLi5PYmplY3QuZW50cmllcyhzdGF0ZS5ieUFzdElkKS5tYXAoKFthc3RJZF0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIFthc3RJZF06IHN0YXRlLmJ5QXN0SWRbYXN0SWRdLm1hcChcbiAgICAgICAgICAgICAgICBpZCA9PiBsZWFybkFkZHJlc3Moc3RhdGUuYnlJZFtpZF0sIGR1bW15QWRkcmVzcywgYWRkcmVzcykuaWRcbiAgICAgICAgICAgICAgICAvL3RoaXMgYWJvdmUgaW52b2x2ZXMgc29tZSByZWNvbXB1dGF0aW9uIGJ1dCBvaCB3ZWxsXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgfTtcblxuICAgIGNhc2UgYWN0aW9ucy5SRVNFVDpcbiAgICAgIHJldHVybiBERUZBVUxUX0FTU0lHTk1FTlRTO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsZWFybkFkZHJlc3MoYXNzaWdubWVudCwgZHVtbXlBZGRyZXNzLCBhZGRyZXNzKSB7XG4gIGlmIChhc3NpZ25tZW50LmR1bW15QWRkcmVzcyA9PT0gZHVtbXlBZGRyZXNzKSB7XG4gICAgLy93ZSBjYW4gYXNzdW1lIGhlcmUgdGhhdCB0aGUgb2JqZWN0IGJlaW5nXG4gICAgLy90cmFuc2Zvcm1lZCBoYXMgYSB2ZXJ5IHBhcnRpY3VsYXIgZm9ybVxuICAgIGxldCBuZXdJZE9iaiA9IHtcbiAgICAgIGFzdElkOiBhc3NpZ25tZW50LmFzdElkLFxuICAgICAgYWRkcmVzc1xuICAgIH07XG4gICAgbGV0IG5ld0lkID0gc3RhYmxlS2VjY2FrMjU2KG5ld0lkT2JqKTtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IG5ld0lkLFxuICAgICAgcmVmOiBhc3NpZ25tZW50LnJlZixcbiAgICAgIGFzdElkOiBhc3NpZ25tZW50LmFzdElkLFxuICAgICAgYWRkcmVzc1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGFzc2lnbm1lbnQ7XG4gIH1cbn1cblxuY29uc3QgREVGQVVMVF9NQVBQSU5HX0tFWVMgPSB7XG4gIGRlY29kaW5nU3RhcnRlZDogMCxcbiAgYnlJZDoge31cbn07XG5cbmZ1bmN0aW9uIG1hcHBpbmdLZXlzKHN0YXRlID0gREVGQVVMVF9NQVBQSU5HX0tFWVMsIGFjdGlvbikge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBhY3Rpb25zLk1BUF9LRVlfREVDT0RJTkc6XG4gICAgICBkZWJ1ZyhcbiAgICAgICAgXCJkZWNvZGluZyBzdGFydGVkOiAlZFwiLFxuICAgICAgICBzdGF0ZS5kZWNvZGluZ1N0YXJ0ZWQgKyAoYWN0aW9uLnN0YXJ0ZWQgPyAxIDogLTEpXG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGVjb2RpbmdTdGFydGVkOiBzdGF0ZS5kZWNvZGluZ1N0YXJ0ZWQgKyAoYWN0aW9uLnN0YXJ0ZWQgPyAxIDogLTEpLFxuICAgICAgICBieUlkOiB7IC4uLnN0YXRlLmJ5SWQgfVxuICAgICAgfTtcbiAgICBjYXNlIGFjdGlvbnMuTUFQX0tFWTpcbiAgICAgIGxldCB7IGlkLCBrZXkgfSA9IGFjdGlvbjtcbiAgICAgIGRlYnVnKFwibWFwcGluZyBpZCBhbmQga2V5OiAlcywgJW9cIiwgaWQsIGtleSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRlY29kaW5nU3RhcnRlZDogc3RhdGUuZGVjb2RpbmdTdGFydGVkLFxuICAgICAgICBieUlkOiB7XG4gICAgICAgICAgLi4uc3RhdGUuYnlJZCxcblxuICAgICAgICAgIC8vIGFkZCBuZXcga2V5IHRvIHNldCBvZiBrZXlzIGFscmVhZHkgZGVmaW5lZFxuICAgICAgICAgIFtpZF06IFtcbiAgICAgICAgICAgIC4uLm5ldyBTZXQoW1xuICAgICAgICAgICAgICAvL3NldCBmb3IgdW5pcXVlbmVzc1xuICAgICAgICAgICAgICAuLi4oc3RhdGUuYnlJZFtpZF0gfHwgW10pLFxuICAgICAgICAgICAgICBrZXlcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgXVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgY2FzZSBhY3Rpb25zLlJFU0VUOlxuICAgICAgcmV0dXJuIERFRkFVTFRfTUFQUElOR19LRVlTO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5jb25zdCBwcm9jID0gY29tYmluZVJlZHVjZXJzKHtcbiAgYXNzaWdubWVudHMsXG4gIG1hcHBpbmdLZXlzXG59KTtcblxuY29uc3QgcmVkdWNlciA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gIGluZm8sXG4gIHByb2Ncbn0pO1xuXG5leHBvcnQgZGVmYXVsdCByZWR1Y2VyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9kYXRhL3JlZHVjZXJzLmpzIiwiaW1wb3J0IHsgY29tYmluZVJlZHVjZXJzIH0gZnJvbSBcInJlZHV4XCI7XG5cbmltcG9ydCAqIGFzIGFjdGlvbnMgZnJvbSBcIi4vYWN0aW9uc1wiO1xuaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcImxpYi9oZWxwZXJzXCI7XG5cbmNvbnN0IERFRkFVTFRfQ09OVEVYVFMgPSB7XG4gIGJ5Q29udGV4dDoge30sXG4gIGJ5QmluYXJ5OiB7fVxufTtcblxuZnVuY3Rpb24gY29udGV4dHMoc3RhdGUgPSBERUZBVUxUX0NPTlRFWFRTLCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIC8qXG4gICAgICogQWRkaW5nIGEgbmV3IGNvbnRleHRcbiAgICAgKi9cbiAgICBjYXNlIGFjdGlvbnMuQUREX0NPTlRFWFQ6IHtcbiAgICAgIGNvbnN0IHsgY29udHJhY3ROYW1lLCByYXcsIGNvbXBpbGVyIH0gPSBhY3Rpb247XG4gICAgICBjb25zdCBjb250ZXh0ID0ga2VjY2FrMjU2KHJhdyk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlLFxuXG4gICAgICAgIGJ5Q29udGV4dDoge1xuICAgICAgICAgIC4uLnN0YXRlLmJ5Q29udGV4dCxcblxuICAgICAgICAgIFtjb250ZXh0XToge1xuICAgICAgICAgICAgLi4uKHN0YXRlLmJ5Q29udGV4dFtjb250ZXh0XSB8fCB7fSksXG5cbiAgICAgICAgICAgIGNvbnRyYWN0TmFtZSxcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICBjb21waWxlclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIEFkZGluZyBiaW5hcnkgZm9yIGEgY29udGV4dFxuICAgICAqL1xuICAgIGNhc2UgYWN0aW9ucy5BRERfQklOQVJZOiB7XG4gICAgICBjb25zdCB7IGNvbnRleHQsIGJpbmFyeSB9ID0gYWN0aW9uO1xuXG4gICAgICBpZiAoc3RhdGUuYnlCaW5hcnlbYmluYXJ5XSkge1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJ5Q29udGV4dDoge1xuICAgICAgICAgIC4uLnN0YXRlLmJ5Q29udGV4dCxcblxuICAgICAgICAgIFtjb250ZXh0XToge1xuICAgICAgICAgICAgLi4uc3RhdGUuYnlDb250ZXh0W2NvbnRleHRdLFxuXG4gICAgICAgICAgICBiaW5hcnlcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYnlCaW5hcnk6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5ieUJpbmFyeSxcblxuICAgICAgICAgIFtiaW5hcnldOiB7IGNvbnRleHQ6IGNvbnRleHQgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qXG4gICAgICogRGVmYXVsdCBjYXNlXG4gICAgICovXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5jb25zdCBERUZBVUxUX0lOU1RBTkNFUyA9IHtcbiAgYnlBZGRyZXNzOiB7fSxcbiAgYnlDb250ZXh0OiB7fVxufTtcblxuZnVuY3Rpb24gaW5zdGFuY2VzKHN0YXRlID0gREVGQVVMVF9JTlNUQU5DRVMsIGFjdGlvbikge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgLypcbiAgICAgKiBBZGRpbmcgYSBuZXcgYWRkcmVzcyBmb3IgY29udGV4dFxuICAgICAqL1xuICAgIGNhc2UgYWN0aW9ucy5BRERfSU5TVEFOQ0U6XG4gICAgICBsZXQgeyBhZGRyZXNzLCBjb250ZXh0LCBiaW5hcnkgfSA9IGFjdGlvbjtcblxuICAgICAgYWRkcmVzcyA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcblxuICAgICAgLy8gZ2V0IGtub3duIGFkZHJlc3NlcyBmb3IgdGhpcyBjb250ZXh0XG4gICAgICBsZXQgb3RoZXJJbnN0YW5jZXMgPSBzdGF0ZS5ieUNvbnRleHRbY29udGV4dF0gfHwgW107XG4gICAgICBsZXQgb3RoZXJBZGRyZXNzZXMgPSBvdGhlckluc3RhbmNlcy5tYXAoKHsgYWRkcmVzcyB9KSA9PiBhZGRyZXNzKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYnlBZGRyZXNzOiB7XG4gICAgICAgICAgLi4uc3RhdGUuYnlBZGRyZXNzLFxuXG4gICAgICAgICAgW2FkZHJlc3NdOiB7IGFkZHJlc3MsIGNvbnRleHQsIGJpbmFyeSB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYnlDb250ZXh0OiB7XG4gICAgICAgICAgLi4uc3RhdGUuYnlDb250ZXh0LFxuXG4gICAgICAgICAgLy8gcmVjb25zdHJ1Y3QgY29udGV4dCBpbnN0YW5jZXMgdG8gaW5jbHVkZSBuZXcgYWRkcmVzc1xuICAgICAgICAgIFtjb250ZXh0XTogQXJyYXkuZnJvbShuZXcgU2V0KG90aGVyQWRkcmVzc2VzKS5hZGQoYWRkcmVzcykpLm1hcChcbiAgICAgICAgICAgIGFkZHJlc3MgPT4gKHsgYWRkcmVzcyB9KVxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgIC8qXG4gICAgICogRGVmYXVsdCBjYXNlXG4gICAgICovXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5jb25zdCBpbmZvID0gY29tYmluZVJlZHVjZXJzKHtcbiAgY29udGV4dHMsXG4gIGluc3RhbmNlc1xufSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxsc3RhY2soc3RhdGUgPSBbXSwgYWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIGFjdGlvbnMuQ0FMTDpcbiAgICAgIGxldCBhZGRyZXNzID0gYWN0aW9uLmFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICAgIC8vd2UgZ2V0IHNvbWUgYWRkcmVzc2VzIGluIGxvd2VyY2FzZSwgc29tZSBpbiBjaGVja3N1bSBjYXNlLFxuICAgICAgLy9zbyBJJ20gbG93ZXJjYXNpbmcgdGhlbSBhbGwgZm9yIGNvbnNpc3RlbmN5XG4gICAgICByZXR1cm4gc3RhdGUuY29uY2F0KFt7IGFkZHJlc3MgfV0pO1xuXG4gICAgY2FzZSBhY3Rpb25zLkNSRUFURTpcbiAgICAgIGNvbnN0IGJpbmFyeSA9IGFjdGlvbi5iaW5hcnk7XG4gICAgICByZXR1cm4gc3RhdGUuY29uY2F0KFt7IGJpbmFyeSB9XSk7XG5cbiAgICBjYXNlIGFjdGlvbnMuUkVUVVJOOlxuICAgICAgLy9IQUNLOiBwb3AgdGhlIHN0YWNrLCBVTkxFU1MgdGhhdCB3b3VsZCBsZWF2ZSBpdCBlbXB0eSAodGhpcyB3aWxsIG9ubHlcbiAgICAgIC8vaGFwcGVuIGF0IHRoZSBlbmQgd2hlbiB3ZSB3YW50IHRvIGtlZXAgdGhlIGxhc3Qgb25lIGFyb3VuZClcbiAgICAgIHJldHVybiBzdGF0ZS5sZW5ndGggPiAxID8gc3RhdGUuc2xpY2UoMCwgLTEpIDogc3RhdGU7XG5cbiAgICBjYXNlIGFjdGlvbi5SRVNFVDpcbiAgICAgIHJldHVybiBbc3RhdGVbMF1dOyAvL2xlYXZlIHRoZSBpbml0aWFsIGNhbGwgc3RpbGwgb24gdGhlIHN0YWNrXG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbmNvbnN0IHByb2MgPSBjb21iaW5lUmVkdWNlcnMoe1xuICBjYWxsc3RhY2tcbn0pO1xuXG5jb25zdCByZWR1Y2VyID0gY29tYmluZVJlZHVjZXJzKHtcbiAgaW5mbyxcbiAgcHJvY1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHJlZHVjZXI7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbGliL2V2bS9yZWR1Y2Vycy5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9hcnJheS9mcm9tXCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGV4dGVybmFsIFwiYmFiZWwtcnVudGltZS9jb3JlLWpzL2FycmF5L2Zyb21cIlxuLy8gbW9kdWxlIGlkID0gNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgY29tYmluZVJlZHVjZXJzIH0gZnJvbSBcInJlZHV4XCI7XG5cbmltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCJsaWIvaGVscGVyc1wiO1xuXG5pbXBvcnQgKiBhcyBhY3Rpb25zIGZyb20gXCIuL2FjdGlvbnNcIjtcblxuY29uc3QgREVGQVVMVF9TT1VSQ0VTID0ge1xuICBieUlkOiB7fVxufTtcblxuZnVuY3Rpb24gc291cmNlcyhzdGF0ZSA9IERFRkFVTFRfU09VUkNFUywgYWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAvKlxuICAgICAqIEFkZGluZyBhIG5ldyBzb3VyY2VcbiAgICAgKi9cbiAgICBjYXNlIGFjdGlvbnMuQUREX1NPVVJDRTpcbiAgICAgIGxldCB7IGFzdCwgc291cmNlLCBzb3VyY2VQYXRoLCBjb21waWxlciB9ID0gYWN0aW9uO1xuXG4gICAgICBsZXQgaWQgPSBPYmplY3Qua2V5cyhzdGF0ZS5ieUlkKS5sZW5ndGg7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJ5SWQ6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5ieUlkLFxuXG4gICAgICAgICAgW2lkXToge1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBhc3QsXG4gICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICBzb3VyY2VQYXRoLFxuICAgICAgICAgICAgY29tcGlsZXJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAvKlxuICAgICAqIERlZmF1bHQgY2FzZVxuICAgICAqL1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuY29uc3QgREVGQVVMVF9TT1VSQ0VNQVBTID0ge1xuICBieUNvbnRleHQ6IHt9XG59O1xuXG5mdW5jdGlvbiBzb3VyY2VNYXBzKHN0YXRlID0gREVGQVVMVF9TT1VSQ0VNQVBTLCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIC8qXG4gICAgICogQWRkaW5nIGEgbmV3IHNvdXJjZU1hcFxuICAgICAqL1xuICAgIGNhc2UgYWN0aW9ucy5BRERfU09VUkNFTUFQOlxuICAgICAgbGV0IHsgYmluYXJ5LCBzb3VyY2VNYXAgfSA9IGFjdGlvbjtcbiAgICAgIGxldCBjb250ZXh0ID0ga2VjY2FrMjU2KGJpbmFyeSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJ5Q29udGV4dDoge1xuICAgICAgICAgIC4uLnN0YXRlLmJ5Q29udGV4dCxcblxuICAgICAgICAgIFtjb250ZXh0XToge1xuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIHNvdXJjZU1hcFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgIC8qXG4gICAgICogRGVmYXVsdCBDYXNlXG4gICAgICovXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5jb25zdCBpbmZvID0gY29tYmluZVJlZHVjZXJzKHtcbiAgc291cmNlcyxcbiAgc291cmNlTWFwc1xufSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBmdW5jdGlvbkRlcHRoKHN0YXRlID0gMCwgYWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIGFjdGlvbnMuSlVNUDpcbiAgICAgIGNvbnN0IGRlbHRhID0gc3BlbHVuayhhY3Rpb24uanVtcERpcmVjdGlvbik7XG4gICAgICByZXR1cm4gc3RhdGUgKyBkZWx0YTtcblxuICAgIGNhc2UgYWN0aW9ucy5SRVNFVDpcbiAgICAgIHJldHVybiAwO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzcGVsdW5rKGp1bXApIHtcbiAgaWYgKGp1bXAgPT0gXCJpXCIpIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIGlmIChqdW1wID09IFwib1wiKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2UgaWYgKGp1bXAgPT0gXCIyXCIpIHtcbiAgICByZXR1cm4gMjsgLy9IQUNLIFdPUktBUk9VTkRcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufVxuXG5jb25zdCBwcm9jID0gY29tYmluZVJlZHVjZXJzKHtcbiAgZnVuY3Rpb25EZXB0aFxufSk7XG5cbmNvbnN0IHJlZHVjZXIgPSBjb21iaW5lUmVkdWNlcnMoe1xuICBpbmZvLFxuICBwcm9jXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgcmVkdWNlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvc29saWRpdHkvcmVkdWNlcnMuanMiLCJpbXBvcnQgeyBjb21iaW5lUmVkdWNlcnMgfSBmcm9tIFwicmVkdXhcIjtcblxuaW1wb3J0ICogYXMgYWN0aW9ucyBmcm9tIFwiLi9hY3Rpb25zXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBpbmRleChzdGF0ZSA9IDAsIGFjdGlvbikge1xuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgY2FzZSBhY3Rpb25zLlRPQ0s6XG4gICAgICByZXR1cm4gc3RhdGUgKyAxO1xuXG4gICAgY2FzZSBhY3Rpb25zLlJFU0VUOlxuICAgICAgcmV0dXJuIDA7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5pc2hlZChzdGF0ZSA9IGZhbHNlLCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgYWN0aW9ucy5FTkRfT0ZfVFJBQ0U6XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYWN0aW9ucy5SRVNFVDpcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0ZXBzKHN0YXRlID0gbnVsbCwgYWN0aW9uKSB7XG4gIGlmIChhY3Rpb24udHlwZSA9PT0gYWN0aW9ucy5TQVZFX1NURVBTKSB7XG4gICAgcmV0dXJuIGFjdGlvbi5zdGVwcztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn1cblxuY29uc3QgaW5mbyA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gIHN0ZXBzXG59KTtcblxuY29uc3QgcHJvYyA9IGNvbWJpbmVSZWR1Y2Vycyh7XG4gIGluZGV4LFxuICBmaW5pc2hlZFxufSk7XG5cbmNvbnN0IHJlZHVjZXIgPSBjb21iaW5lUmVkdWNlcnMoe1xuICBpbmZvLFxuICBwcm9jXG59KTtcblxuZXhwb3J0IGRlZmF1bHQgcmVkdWNlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBsaWIvdHJhY2UvcmVkdWNlcnMuanMiLCJpbXBvcnQgZGVidWdNb2R1bGUgZnJvbSBcImRlYnVnXCI7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwiZGVidWdnZXI6Y29udHJvbGxlcjpyZWR1Y2Vyc1wiKTsgLy9lc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbmltcG9ydCB7IGNvbWJpbmVSZWR1Y2VycyB9IGZyb20gXCJyZWR1eFwiO1xuXG5pbXBvcnQgKiBhcyBhY3Rpb25zIGZyb20gXCIuL2FjdGlvbnNcIjtcblxuZnVuY3Rpb24gYnJlYWtwb2ludHMoc3RhdGUgPSBbXSwgYWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIGFjdGlvbnMuQUREX0JSRUFLUE9JTlQ6XG4gICAgICAvL2NoZWNrIGZvciBhbnkgZXhpc3RpbmcgaWRlbnRpY2FsIGJyZWFrcG9pbnRzIHRvIGF2b2lkIHJlZHVuZGFuY3lcbiAgICAgIGlmIChcbiAgICAgICAgc3RhdGUuZmlsdGVyKFxuICAgICAgICAgIGJyZWFrcG9pbnQgPT5cbiAgICAgICAgICAgIGJyZWFrcG9pbnQuc291cmNlSWQgPT09IGFjdGlvbi5icmVha3BvaW50LnNvdXJjZUlkICYmXG4gICAgICAgICAgICBicmVha3BvaW50LmxpbmUgPT09IGFjdGlvbi5icmVha3BvaW50LmxpbmUgJiZcbiAgICAgICAgICAgIGJyZWFrcG9pbnQubm9kZSA9PT0gYWN0aW9uLmJyZWFrcG9pbnQubm9kZSAvL21heSBiZSB1bmRlZmluZWRcbiAgICAgICAgKS5sZW5ndGggPiAwXG4gICAgICApIHtcbiAgICAgICAgLy9pZiBpdCdzIGFscmVhZHkgdGhlcmUsIGRvIG5vdGhpbmdcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy9vdGhlcndpc2UgYWRkIGl0XG4gICAgICAgIHJldHVybiBzdGF0ZS5jb25jYXQoW2FjdGlvbi5icmVha3BvaW50XSk7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgYWN0aW9ucy5SRU1PVkVfQlJFQUtQT0lOVDpcbiAgICAgIHJldHVybiBzdGF0ZS5maWx0ZXIoXG4gICAgICAgIGJyZWFrcG9pbnQgPT5cbiAgICAgICAgICBicmVha3BvaW50LnNvdXJjZUlkICE9PSBhY3Rpb24uYnJlYWtwb2ludC5zb3VyY2VJZCB8fFxuICAgICAgICAgIGJyZWFrcG9pbnQubGluZSAhPT0gYWN0aW9uLmJyZWFrcG9pbnQubGluZSB8fFxuICAgICAgICAgIGJyZWFrcG9pbnQubm9kZSAhPT0gYWN0aW9uLmJyZWFrcG9pbnQubm9kZSAvL21heSBiZSB1bmRlZmluZWRcbiAgICAgICk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgYWN0aW9ucy5SRU1PVkVfQUxMX0JSRUFLUE9JTlRTOlxuICAgICAgcmV0dXJuIFtdO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxuXG5jb25zdCByZWR1Y2VyID0gY29tYmluZVJlZHVjZXJzKHtcbiAgYnJlYWtwb2ludHNcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCByZWR1Y2VyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9jb250cm9sbGVyL3JlZHVjZXJzLmpzIiwiaW1wb3J0IGRlYnVnTW9kdWxlIGZyb20gXCJkZWJ1Z1wiO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcImRlYnVnZ2VyOnNlc3Npb246c2VsZWN0b3JzXCIpO1xuXG5pbXBvcnQgeyBjcmVhdGVTZWxlY3RvclRyZWUsIGNyZWF0ZUxlYWYgfSBmcm9tIFwicmVzZWxlY3QtdHJlZVwiO1xuXG5pbXBvcnQgZXZtIGZyb20gXCJsaWIvZXZtL3NlbGVjdG9yc1wiO1xuaW1wb3J0IHNvbGlkaXR5IGZyb20gXCJsaWIvc29saWRpdHkvc2VsZWN0b3JzXCI7XG5cbmNvbnN0IHNlc3Npb24gPSBjcmVhdGVTZWxlY3RvclRyZWUoe1xuICAvKipcbiAgICogc2Vzc2lvbi5pbmZvXG4gICAqL1xuICBpbmZvOiB7XG5cbiAgICAvKipcbiAgICAgKiBzZXNzaW9uLmluZm8uYWZmZWN0ZWRJbnN0YW5jZXNcbiAgICAgKi9cbiAgICBhZmZlY3RlZEluc3RhbmNlczogY3JlYXRlTGVhZihcbiAgICAgIFtldm0uaW5mby5pbnN0YW5jZXMsIGV2bS5pbmZvLmNvbnRleHRzLCBzb2xpZGl0eS5pbmZvLnNvdXJjZXMsIHNvbGlkaXR5LmluZm8uc291cmNlTWFwc10sXG5cbiAgICAgIChpbnN0YW5jZXMsIGNvbnRleHRzLCBzb3VyY2VzLCBzb3VyY2VNYXBzKSA9PiBPYmplY3QuYXNzaWduKHt9LFxuICAgICAgICAuLi5PYmplY3QuZW50cmllcyhpbnN0YW5jZXMpLm1hcChcbiAgICAgICAgICAoW2FkZHJlc3MsIHtjb250ZXh0fV0pID0+IHtcbiAgICAgICAgICAgIGRlYnVnKFwiaW5zdGFuY2VzICVPXCIsIGluc3RhbmNlcyk7XG4gICAgICAgICAgICBkZWJ1ZyhcImNvbnRleHRzICVPXCIsIGNvbnRleHRzKTtcbiAgICAgICAgICAgIGxldCB7IGNvbnRyYWN0TmFtZSwgYmluYXJ5IH0gPSBjb250ZXh0c1tjb250ZXh0XTtcbiAgICAgICAgICAgIGxldCB7IHNvdXJjZU1hcCB9ID0gc291cmNlTWFwc1tjb250ZXh0XSB8fCB7fTtcblxuICAgICAgICAgICAgbGV0IHsgc291cmNlIH0gPSBzb3VyY2VNYXAgP1xuICAgICAgICAgICAgICAvLyBsb29rIGZvciBzb3VyY2UgSUQgYmV0d2VlbiBzZWNvbmQgYW5kIHRoaXJkIGNvbG9ucyAoSEFDSylcbiAgICAgICAgICAgICAgc291cmNlc1tzb3VyY2VNYXAubWF0Y2goL15bXjpdKzpbXjpdKzooW146XSspOi8pWzFdXSA6XG4gICAgICAgICAgICAgIHt9O1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBbYWRkcmVzc106IHtcbiAgICAgICAgICAgICAgICBjb250cmFjdE5hbWUsIHNvdXJjZSwgYmluYXJ5XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICApXG4gICAgKVxuXG4gIH0sXG5cblxuICAvKipcbiAgICogc2Vzc2lvbi50cmFuc2FjdGlvbiAobmFtZXNwYWNlKVxuICAgKi9cbiAgdHJhbnNhY3Rpb246IHtcblxuICAgIC8qKlxuICAgICAqIHNlc3Npb24udHJhbnNhY3Rpb24gKHNlbGVjdG9yKVxuICAgICAqIGNvbnRhaW5zIHRoZSB3ZWIzIHRyYW5zYWN0aW9uIG9iamVjdFxuICAgICAqL1xuICAgIF86IChzdGF0ZSkgPT4gc3RhdGUuc2Vzc2lvbi50cmFuc2FjdGlvbixcblxuICAgIC8qKlxuICAgICAqIHNlc3Npb24udHJhbnNhY3Rpb24ucmVjZWlwdFxuICAgICAqIGNvbnRhaW5zIHRoZSB3ZWIzIHJlY2VpcHQgb2JqZWN0XG4gICAgICovXG4gICAgcmVjZWlwdDogKHN0YXRlKSA9PiBzdGF0ZS5zZXNzaW9uLnJlY2VpcHQsXG5cbiAgfVxuICBcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBzZXNzaW9uO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGxpYi9zZXNzaW9uL3NlbGVjdG9ycy9pbmRleC5qcyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM3REE7Ozs7Ozs7Ozs7OztBQ0lBO0FBWUE7QUFRQTtBQVFBO0FBQ0E7QUFqQ0E7QUFDQTtBQURBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDbkNBOzs7Ozs7QUNBQTs7Ozs7O0FDQUE7Ozs7OztBQ0FBOzs7Ozs7QUNBQTs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBQTtBQUNBOzs7QUFFQTtBQUNBO0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTs7O0FBQ0E7QUFDQTs7Ozs7OztBQVhBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFMQTtBQUhBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQVRBO0FBQ0E7QUFXQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFDQTtBQUtBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFEQTtBQU1BO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUxBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUdBO0FBQ0E7QUFLQTs7O0FBR0E7QUFDQTtBQUtBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUtBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFLQTs7OztBQUlBO0FBQ0E7QUFLQTs7Ozs7Ozs7O0FBU0E7QUFDQTtBQWFBOzs7Ozs7O0FBT0E7QUFJQTtBQTVSQTtBQXhCQTtBQUNBO0FBeVRBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMVZBO0FBQ0E7OztBQUVBO0FBQ0E7QUFBQTtBQUNBOzs7QUFDQTtBQUNBOzs7QUFDQTtBQUNBOzs7QUFSQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFGQTtBQUlBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUlBOzs7OztBQUtBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBdENBO0FBQ0E7QUEyQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFLQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBS0E7QUFDQTtBQVdBOzs7Ozs7QUFNQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXRFQTtBQXlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRkE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBckNBO0FBZEE7QUFDQTtBQXNEQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBS0E7Ozs7QUFJQTtBQUNBO0FBS0E7OztBQUdBO0FBQ0E7QUFJQTs7Ozs7QUFLQTtBQUdBO0FBREE7QUFDQTtBQUlBOzs7QUFHQTtBQWhEQTtBQUNBO0FBa0RBOzs7QUFHQTtBQUNBOzs7OztBQUtBO0FBR0E7QUFEQTtBQUNBO0FBSUE7QUFiQTtBQXpIQTtBQUNBO0FBeUlBOzs7Ozs7QUNoVEE7Ozs7Ozs7Ozs7OztBQ0NBO0FBUUE7QUFRQTtBQUtBO0FBS0E7QUFLQTtBQUtBO0FBckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUN2Q0E7Ozs7Ozs7Ozs7OztBQ0NBO0FBU0E7QUFPQTtBQVFBO0FBU0E7QUFRQTtBQTFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7Ozs7OztBQy9DQTs7Ozs7Ozs7Ozs7OztBQ0FBO0FBQ0E7OztBQUVBO0FBQ0E7QUFBQTtBQUNBOzs7QUFDQTtBQUNBOzs7QUFDQTtBQUNBOzs7QUFSQTtBQUNBO0FBU0E7OztBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7OztBQUdBO0FBSkE7QUFDQTtBQU1BOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUdBOzs7OztBQUtBO0FBQ0E7QUFHQTs7Ozs7QUFLQTtBQUNBO0FBS0E7Ozs7O0FBS0E7QUFDQTtBQXJDQTtBQWRBO0FBQ0E7QUEyREE7Ozs7Ozs7Ozs7Ozs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUdBOzs7OztBQUtBO0FBQ0E7QUFHQTs7Ozs7OztBQU9BO0FBL0NBO0FBQ0E7QUFvREE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hDQTtBQUlBO0FBaU5BO0FBSUE7QUFXQTtBQUNBO0FBcFBBO0FBQ0E7OztBQUVBO0FBQ0E7QUFBQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQURBO0FBQ0E7Ozs7O0FBYkE7QUFDQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFNQTtBQUpBO0FBWUE7QUFDQTtBQUNBO0FBakJBO0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRkE7QUFIQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFEQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBdktBO0FBeUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUM3UEE7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7QUNDQTtBQVFBO0FBS0E7QUFLQTtBQUtBO0FBS0E7QUFLQTtBQUtBO0FBS0E7QUFNQTtBQVFBO0FBUUE7QUFsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdEVBO0FBQ0E7OztBQUVBO0FBQ0E7QUFBQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBOzs7OztBQWJBO0FBQ0E7QUFhQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQWFBOzs7QUFHQTtBQUNBO0FBVUE7OztBQUdBO0FBT0E7QUFEQTtBQXpDQTtBQWlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFPQTtBQUNBO0FBRUE7QUFIQTtBQURBO0FBVkE7QUFDQTtBQXVCQTs7Ozs7QUFLQTtBQUtBO0FBQ0E7QUFDQTtBQUhBO0FBNUNBO0FBQ0E7QUFtREE7OztBQUdBO0FBQ0E7OztBQUdBO0FBSkE7QUFDQTtBQU1BOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUdBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBdkJBO0FBQ0E7QUE0QkE7OztBQUdBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7QUFHQTtBQUpBO0FBQ0E7QUFNQTs7O0FBR0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7Ozs7QUFLQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBS0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7Ozs7O0FBS0E7QUFLQTtBQUNBO0FBTEE7QUFZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBR0E7Ozs7O0FBS0E7QUFBQTtBQUlBO0FBQUE7QUFDQTtBQUNBO0FBREE7QUFBQTtBQUNBO0FBRkE7QUFBQTtBQUFBO0FBQUE7QUFLQTtBQUNBO0FBR0E7QUFDQTtBQWRBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFlQTs7Ozs7QUFLQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFBQTtBQUFBO0FBQUE7QUFqSkE7QUF2Q0E7QUFDQTtBQTZMQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFKQTtBQXhTQTtBQUNBO0FBK1NBOzs7Ozs7QUN4WEE7Ozs7OztBQ0FBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ1NBO0FBY0E7QUF5QkE7QUFDQTtBQWpEQTtBQUNBOzs7QUFFQTtBQUNBOzs7OztBQUhBO0FBQ0E7QUFJQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7Ozs7Ozs7Ozs7OztBQ25FQTtBQVdBO0FBUUE7QUFTQTtBQVNBO0FBUUE7QUFLQTtBQW5EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqQ0E7QUFtQ0E7QUFTQTtBQUlBO0FBQ0E7QUF6RUE7QUFDQTs7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFSQTtBQUNBO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzVEQTtBQW1CQTtBQWNBO0FBUUE7QUEwREE7QUFJQTtBQUNBO0FBM0hBO0FBQ0E7OztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBREE7QUFDQTs7Ozs7QUFaQTtBQUNBO0FBWUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUM3SEE7QUFVQTtBQVNBO0FBVUE7QUFRQTtBQVFBO0FBT0E7QUFyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDNUNBO0FBSUE7QUF1REE7QUFJQTtBQUNBO0FBM0VBO0FBQ0E7OztBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQVRBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUM3RUE7QUFVQTtBQVNBO0FBUUE7QUE1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5QkE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7Ozs7O0FBUkE7QUFDQTtBQVFBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFuQkE7QUFuQkE7QUFDQTtBQXlDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBNURBO0FBQ0E7QUE4REE7Ozs7OztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDSEE7QUFDQTs7O0FBQUE7QUFDQTs7O0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7Ozs7O0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBOzs7O0FBSUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFqQkE7QUFrQkE7QUFDQTtBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQXpFQTtBQUNBO0FBREE7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBQTtBQUNBOzs7QUFFQTtBQUNBOzs7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTs7O0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTs7Ozs7OztBQVZBO0FBQ0E7QUFVQTs7O0FBR0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFDQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBMUJBO0FBMkJBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFRQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUlBO0FBck1BO0FBQUE7Ozs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDTkE7QUFDQTs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDT0E7QUF5Q0E7QUFDQTtBQWxEQTtBQUNBOzs7QUFHQTtBQUNBO0FBQUE7QUFDQTs7O0FBQUE7QUFDQTs7Ozs7QUFOQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBTkE7QUFDQTtBQVFBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDL0VBOzs7Ozs7QUNBQTs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDbkZBO0FBQ0E7Ozs7Ozs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNoUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUN6SkE7Ozs7OztBQ0FBOzs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNuc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDN0NBOzs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDdjBDQTs7Ozs7Ozs7Ozs7O0FDaUJBO0FBQ0E7QUFsQkE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBOzs7OztBQWZBO0FBQ0E7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2REE7QUFnQkE7QUFDQTtBQS9FQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBWEE7QUFDQTtBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3BGQTtBQVNBO0FBVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNlQTtBQUNBO0FBOUJBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFkQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDN0xBO0FBdUJBO0FBOEJBO0FBQ0E7QUE5R0E7QUFDQTs7O0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQVRBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3JIQTtBQVFBO0FBUUE7QUFRQTtBQVNBO0FBUUE7QUFTQTtBQW5EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hEQTtBQUNBOzs7QUFDQTtBQUNBOzs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWJBO0FBY0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFRQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVVBO0FBeERBO0FBQUE7Ozs7OztBQ05BOzs7Ozs7Ozs7Ozs7O0FDY0E7QUFhQTtBQVNBO0FBQ0E7QUFyQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUFBO0FBQ0E7OztBQUNBO0FBQ0E7QUFEQTtBQUNBOzs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQ0E7QUFRQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNURBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7Ozs7O0FBUEE7QUFDQTtBQU9BO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBSEE7QUFEQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFIQTtBQUhBO0FBREE7QUFDQTtBQWVBO0FBQ0E7QUF4Q0E7QUEwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUZBO0FBSUE7QUFFQTtBQUNBO0FBSEE7QUFMQTtBQVdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFFQTtBQUdBO0FBQ0E7QUFFQTtBQUZBO0FBREE7QUFNQTtBQW5CQTtBQUNBO0FBc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFsREE7QUFvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQVBBO0FBRkE7QUFDQTtBQWVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFsQ0E7QUFvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3RUE7QUFDQTtBQTNIQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBOzs7OztBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7OztBQUdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFMQTtBQUhBO0FBSEE7QUFlQTtBQUNBO0FBQ0E7OztBQUdBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFIQTtBQUhBO0FBQ0E7QUFTQTtBQUNBO0FBRUE7QUFIQTtBQVhBO0FBaUJBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQTFEQTtBQTREQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFKQTtBQVBBO0FBQ0E7QUFnQkE7OztBQUdBO0FBQ0E7QUFsQ0E7QUFvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXBCQTtBQXNCQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7Ozs7OztBQzVKQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDK0VBO0FBQ0E7QUFoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTs7Ozs7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBSEE7QUFEQTtBQUNBO0FBYUE7OztBQUdBO0FBQ0E7QUEzQkE7QUE2QkE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBSEE7QUFEQTtBQUNBO0FBVUE7OztBQUdBO0FBQ0E7QUF2QkE7QUF5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7Ozs7Ozs7Ozs7OztBQzlHQTtBQWFBO0FBYUE7QUFDQTtBQS9CQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBOzs7Ozs7Ozs7Ozs7O0FDcERBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTs7Ozs7QUFMQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaENBO0FBa0NBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoREE7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBQ0E7Ozs7O0FBTkE7QUFDQTtBQU1BO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFEQTtBQURBO0FBS0E7QUFDQTtBQTNCQTtBQUNBO0FBaUNBOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBYkE7QUFDQTtBQTFDQTtBQUNBO0FBMERBOzs7O0EiLCJzb3VyY2VSb290IjoiIn0=