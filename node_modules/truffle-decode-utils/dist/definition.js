"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const evm_1 = require("./evm");
const lodash_clonedeep_1 = __importDefault(require("lodash.clonedeep"));
var Definition;
(function (Definition) {
    function typeIdentifier(definition) {
        return definition.typeDescriptions.typeIdentifier;
    }
    Definition.typeIdentifier = typeIdentifier;
    /**
     * returns basic type class for a variable definition node
     * e.g.:
     *  `t_uint256` becomes `uint`
     *  `t_struct$_Thing_$20_memory_ptr` becomes `struct`
     */
    function typeClass(definition) {
        return typeIdentifier(definition).match(/t_([^$_0-9]+)/)[1];
    }
    Definition.typeClass = typeClass;
    /**
     * e.g. uint48 -> 6
     * @return size in bytes for explicit type size, or `null` if not stated
     */
    function specifiedSize(definition) {
        let specified = typeIdentifier(definition).match(/t_[a-z]+([0-9]+)/);
        if (!specified) {
            return null;
        }
        let num = parseInt(specified[1]);
        switch (typeClass(definition)) {
            case "int":
            case "uint":
                return num / 8;
            case "bytes":
                return num;
            default:
            // debug("Unknown type for size specification: %s", typeIdentifier(definition));
        }
    }
    Definition.specifiedSize = specifiedSize;
    function storageSize(definition, referenceDeclaration) {
        switch (typeClass(definition)) {
            case "bool":
                return 1;
            case "address":
                return 20;
            case "int":
            case "uint": {
                return specifiedSize(definition) || 32; // default of 256 bits
            }
            case "enum": {
                if (referenceDeclaration) {
                    const numValues = referenceDeclaration.members.length;
                    // numValues <= 2^n - 1
                    // numValues + 1 <= 2^n
                    // log(numValues + 1) <= n (n is bits)
                    return Math.ceil(Math.log2(numValues + 1) / 8);
                }
                else {
                    return 0;
                }
            }
            case "bytes": {
                return specifiedSize(definition) || evm_1.EVM.WORD_SIZE;
            }
            case "string":
            case "bytes":
            case "array":
                return evm_1.EVM.WORD_SIZE;
            case "struct":
            //
            case "mapping":
                // HACK just to reserve slot. mappings have no size as such
                return evm_1.EVM.WORD_SIZE;
        }
    }
    Definition.storageSize = storageSize;
    function requireStartOfSlot(definition) {
        return isArray(definition) || isStruct(definition) || isMapping(definition);
    }
    Definition.requireStartOfSlot = requireStartOfSlot;
    function isArray(definition) {
        return typeIdentifier(definition).match(/^t_array/) != null;
    }
    Definition.isArray = isArray;
    function isDynamicArray(definition) {
        return isArray(definition) && ((definition.typeName && definition.typeName.length === null) ||
            definition.length === null);
    }
    Definition.isDynamicArray = isDynamicArray;
    function isStruct(definition) {
        return typeIdentifier(definition).match(/^t_struct/) != null;
    }
    Definition.isStruct = isStruct;
    function isMapping(definition) {
        return typeIdentifier(definition).match(/^t_mapping/) != null;
    }
    Definition.isMapping = isMapping;
    function isEnum(definition) {
        return typeIdentifier(definition).match(/^t_enum/) != null;
    }
    Definition.isEnum = isEnum;
    function isContract(definition) {
        return typeIdentifier(definition).match(/^t_contract/) != null;
    }
    Definition.isContract = isContract;
    function isReference(definition) {
        return typeIdentifier(definition).match(/_(memory|storage)(_ptr)?$/) != null;
    }
    Definition.isReference = isReference;
    function isContractType(definition) {
        // checks whether the given node is a contract *type*, rather than whether
        // it's a contract
        return typeIdentifier(definition).match(/^t_type\$_t_contract/) != null;
    }
    Definition.isContractType = isContractType;
    function referenceType(definition) {
        return typeIdentifier(definition).match(/_([^_]+)(_ptr)?$/)[1];
    }
    Definition.referenceType = referenceType;
    function baseDefinition(definition) {
        if (definition.typeName && typeof definition.typeName.baseType === "object") {
            return definition.typeName.baseType;
        }
        let baseIdentifier = typeIdentifier(definition)
            // first dollar sign     last dollar sign
            //   `---------.       ,---'
            .match(/^[^$]+\$_(.+)_\$[^$]+$/)[1];
        //              `----' greedy match
        // HACK - internal types for memory or storage also seem to be pointers
        if (baseIdentifier.match(/_(memory|storage)$/) != null) {
            baseIdentifier = `${baseIdentifier}_ptr`;
        }
        // another HACK - we get away with it becausewe're only using that one property
        let result = lodash_clonedeep_1.default(definition);
        result.typeDescriptions.typeIdentifier = baseIdentifier;
        return result;
    }
    Definition.baseDefinition = baseDefinition;
})(Definition = exports.Definition || (exports.Definition = {}));
//# sourceMappingURL=definition.js.map