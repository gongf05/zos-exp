"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const bn_js_1 = __importDefault(require("bn.js"));
var Conversion;
(function (Conversion) {
    /**
     * @param bytes - undefined | string | number | BN | Uint8Array
     * @return {BN}
     */
    function toBN(bytes) {
        if (bytes == undefined) {
            return undefined;
        }
        else if (typeof bytes == "string") {
            return new bn_js_1.default(bytes, 16);
        }
        else if (typeof bytes == "number" || bn_js_1.default.isBN(bytes)) {
            return new bn_js_1.default(bytes);
        }
        else if (bytes.reduce) {
            return bytes.reduce((num, byte) => num.muln(0x100).addn(byte), new bn_js_1.default(0));
        }
    }
    Conversion.toBN = toBN;
    /**
     * @param bytes - Uint8Array
     * @return {BN}
     */
    function toSignedBN(bytes) {
        if (bytes[0] < 0b10000000) { // first bit is 0
            return toBN(bytes);
        }
        else {
            return toBN(bytes.map((b) => 0xff - b)).addn(1).neg();
        }
    }
    Conversion.toSignedBN = toSignedBN;
    /**
     * @param bytes - Uint8Array | BN
     * @param length - number | boolean - desired byte length (pad with zeroes)
     * @param trim - boolean - omit leading zeroes
     * @return {string}
     */
    function toHexString(bytes, length = 0, trim = false) {
        if (typeof length == "boolean") {
            trim = length;
            length = 0;
        }
        if (bn_js_1.default.isBN(bytes)) {
            bytes = toBytes(bytes);
        }
        const pad = (s) => `${"00".slice(0, 2 - s.length)}${s}`;
        //                                          0  1  2  3  4
        //                                 0  1  2  3  4  5  6  7
        // bytes.length:        5  -  0x(          e5 c2 aa 09 11 )
        // length (preferred):  8  -  0x( 00 00 00 e5 c2 aa 09 11 )
        //                                `--.---'
        //                                     offset 3
        if (bytes.length < length) {
            let prior = bytes;
            bytes = new Uint8Array(length);
            bytes.set(prior, length - prior.length);
        }
        // debug("bytes: %o", bytes);
        let string = bytes.reduce((str, byte) => `${str}${pad(byte.toString(16))}`, "");
        if (trim) {
            string = string.replace(/^(00)+/, "");
        }
        if (string.length == 0) {
            string = "00";
        }
        return `0x${string}`;
    }
    Conversion.toHexString = toHexString;
    function toBytes(number, length = 0) {
        let bytes = new Uint8Array(0);
        if (typeof number === "number") {
            if (number < 0) {
                return bytes;
            }
            bytes = new Uint8Array(number);
        }
        else if (typeof number === "string") {
            if (number === "") {
                return bytes;
            }
            let hex = number;
            if (hex.startsWith("0x")) {
                hex = hex.slice(2);
            }
            if (hex.length % 2 == 1) {
                hex = `0${hex}`;
            }
            bytes = new Uint8Array(hex.match(/.{2}/g)
                .map((byte) => parseInt(byte, 16)));
            if (bytes.length < length) {
                let prior = bytes;
                bytes = new Uint8Array(length);
                bytes.set(prior, length - prior.length);
            }
        }
        else {
            // BN
            if (number.ltn(0)) {
                return bytes;
            }
            bytes = new Uint8Array(number.toArrayLike(Buffer));
        }
        return bytes;
    }
    Conversion.toBytes = toBytes;
    /**
     * recursively converts big numbers into something nicer to look at
     */
    function cleanBNs(value) {
        if (bn_js_1.default.isBN(value)) {
            return value.toString();
        }
        else if (value && value.map != undefined) {
            return value.map((inner) => cleanBNs(inner));
        }
        else if (value && typeof value == "object") {
            return Object.assign({}, ...Object.entries(value)
                .map(([key, inner]) => ({ [key]: cleanBNs(inner) })));
        }
        else {
            return value;
        }
    }
    Conversion.cleanBNs = cleanBNs;
    /**
     * recursively converts decoder-native mapping values to JS Map objects
     *
     * detects int and uint Solidity types and uses BNs as keys in such
     * situations
     *
     * all other keys are just kept as strings right now
     */
    function cleanMappings(value) {
        // HACK detect mappings as any object with certain *truthy* properties,
        // where `type` has explicit value `"mapping"`
        //
        // note that this means we can't decode a Solidity struct of this form.
        const isMapping = ({ type, members, keyType }) => type === "mapping" && keyType && members;
        // converts integer mapping keys to BN, unless string representation is hex
        const convertKey = (keyType, key) => keyType.match(/int/) && key.slice(0, 2) != "0x"
            ? new bn_js_1.default(key, 10)
            : key;
        // converts a mapping representation into a JS Map
        // Only converts integer types to BN right now, leaving other keys alone
        const toMap = ({ keyType, members }) => {
            return new Map([
                ...Object.entries(members)
                    .map(([key, value]) => ([convertKey(keyType, key), cleanMappings(value)]))
            ]);
        };
        // BNs are treated like primitives; must take precedence over generic obj
        if (bn_js_1.default.isBN(value)) {
            return value;
        }
        // detect mapping
        else if (value && typeof value === "object" && isMapping(value)) {
            return toMap(value);
        }
        // detect arrays or anything with `.map()`, and recurse
        else if (value && value.map != undefined) {
            return value.map((inner) => cleanMappings(inner));
        }
        // detect objects and recurse
        else if (value && typeof value == "object") {
            return Object.assign({}, ...Object.entries(value).map(([key, inner]) => ({ [key]: cleanMappings(inner) })));
        }
        // catch-all: no-change
        else {
            return value;
        }
    }
    Conversion.cleanMappings = cleanMappings;
})(Conversion = exports.Conversion || (exports.Conversion = {}));
//# sourceMappingURL=conversion.js.map