"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const async_eventemitter_1 = __importDefault(require("async-eventemitter"));
const web3_1 = __importDefault(require("web3"));
const bn_js_1 = __importDefault(require("bn.js"));
const references = __importStar(require("../allocate/references"));
const decode_1 = __importDefault(require("../decode"));
const truffle_decode_utils_1 = require("truffle-decode-utils");
const abi_decoder_1 = __importDefault(require("abi-decoder"));
;
;
;
;
;
;
;
;
function getContractNode(contract) {
    for (let j = 0; j < contract.ast.nodes.length; j++) {
        const contractNode = contract.ast.nodes[j];
        if (contractNode.nodeType === "ContractDefinition" && contractNode.name === contract.contractName) {
            return contractNode;
        }
    }
    return undefined;
}
exports.getContractNode = getContractNode;
function getContractNodeId(contract) {
    const node = getContractNode(contract);
    return node ? node.id : 0;
}
class TruffleContractDecoder extends async_eventemitter_1.default {
    constructor(contract, inheritedContracts, provider) {
        super();
        this.contracts = {};
        if (provider.startsWith("http:\/\/") || provider.startsWith("https:\/\/")) {
            this.web3 = new web3_1.default(new web3_1.default.providers.HttpProvider(provider));
        }
        else if (provider.startsWith("ws:\/\/")) {
            this.web3 = new web3_1.default(new web3_1.default.providers.WebsocketProvider(provider));
        }
        this.contract = contract; //cloneDeep(contract);
        this.inheritedContracts = inheritedContracts; //cloneDeep(inheritedContracts);
        this.contractNetwork = Object.keys(this.contract.networks)[0];
        this.contractAddress = this.contract.networks[this.contractNetwork].address;
        this.contracts[getContractNodeId(this.contract)] = this.contract;
        abi_decoder_1.default.addABI(this.contract.abi);
        this.inheritedContracts.forEach((inheritedContract) => {
            this.contracts[getContractNodeId(inheritedContract)] = inheritedContract;
            abi_decoder_1.default.addABI(inheritedContract.abi);
        });
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            [this.referenceDeclarations, this.referenceVariables] = references.getReferenceDeclarations([this.contract, ...this.inheritedContracts]);
            this.eventDefinitions = references.getEventDefinitions([this.contract, ...this.inheritedContracts]);
            const ids = Object.keys(this.eventDefinitions);
            this.eventDefinitionIdsByName = {};
            for (let i = 0; i < ids.length; i++) {
                const id = parseInt(ids[i]);
                this.eventDefinitionIdsByName[this.eventDefinitions[id].name] = id;
            }
            this.stateVariableReferences = references.getContractStateVariables(this.contract, this.contracts, this.referenceDeclarations);
        });
    }
    state(block = "latest") {
        return __awaiter(this, void 0, void 0, function* () {
            let result = {
                name: this.contract.contractName,
                balance: new bn_js_1.default(yield this.web3.eth.getBalance(this.contractAddress)),
                variables: {}
            };
            const nodeIds = Object.keys(this.stateVariableReferences);
            for (let i = 0; i < nodeIds.length; i++) {
                const variable = this.stateVariableReferences[parseInt(nodeIds[i])];
                if (!variable.isChildVariable) {
                    const info = {
                        scopes: {},
                        state: {
                            stack: [],
                            storage: {},
                            memory: new Uint8Array(0)
                        },
                        mappingKeys: {},
                        referenceDeclarations: this.referenceDeclarations,
                        referenceVariables: this.referenceVariables,
                        variables: this.stateVariableReferences
                    };
                    const val = yield decode_1.default(variable.definition, variable.pointer, info, this.web3, this.contractAddress);
                    result.variables[variable.definition.name] = {
                        name: variable.definition.name,
                        type: truffle_decode_utils_1.Definition.typeClass(variable.definition),
                        value: val
                    };
                }
            }
            return result;
        });
    }
    variable(name, block = "latest") {
        return __awaiter(this, void 0, void 0, function* () {
            return undefined;
        });
    }
    mapping(mappingId, keys) {
        return __awaiter(this, void 0, void 0, function* () {
            const contractAddress = this.contract.networks[this.contractNetwork].address;
            const mappingReference = this.stateVariableReferences[mappingId];
            const definition = mappingReference.definition.typeName.valueType;
            let result = [];
            for (let i = 0; i < keys.length; i++) {
                let state = {
                    variables: {},
                    slot: {
                        offset: new bn_js_1.default(0),
                        index: truffle_decode_utils_1.EVM.WORD_SIZE - 1
                    }
                };
                const path = {
                    key: keys[i],
                    path: mappingReference.pointer.storage.from.slot,
                    offset: new bn_js_1.default(0)
                };
                references.allocateDefinition(definition, state, this.referenceDeclarations, path);
                const nodeIds = Object.keys(state.variables);
                for (let i = 0; i < nodeIds.length; i++) {
                    const variable = state.variables[parseInt(nodeIds[i])];
                    if (!variable.isChildVariable) {
                        const info = {
                            scopes: {},
                            state: {
                                stack: [],
                                storage: {},
                                memory: new Uint8Array(0)
                            },
                            mappingKeys: {},
                            referenceDeclarations: this.referenceDeclarations,
                            variables: this.stateVariableReferences
                        };
                        const val = yield decode_1.default(variable.definition, variable.pointer, info, this.web3, contractAddress);
                        result.push(val);
                    }
                }
            }
            return result;
        });
    }
    watchMappingKeys(mappingId, keys) {
        //
    }
    unwatchMappingKeys(mappingId, keys) {
        //
    }
    decodeTransaction(transaction) {
        const decodedData = abi_decoder_1.default.decodeMethod(transaction.input);
        return decodedData;
    }
    decodeLog(log) {
        const decodedLogs = this.decodeLogs([log]);
        return decodedLogs[0];
    }
    decodeLogs(logs) {
        const decodedLogs = abi_decoder_1.default.decodeLogs(logs);
        return decodedLogs;
    }
    decodeEvent(event) {
        let contractEvent = {
            logIndex: event.logIndex,
            name: event.event,
            blockHash: event.blockHash,
            blockNumber: event.blockNumber,
            transactionHash: event.transactionHash,
            transactionIndex: event.transactionIndex,
            variables: {}
        };
        const eventDefinition = this.eventDefinitions[this.eventDefinitionIdsByName[contractEvent.name]];
        if (typeof eventDefinition.parameters !== "undefined" && typeof eventDefinition.parameters.parameters !== "undefined") {
            const argumentDefinitions = eventDefinition.parameters.parameters;
            for (let i = 0; i < argumentDefinitions.length; i++) {
                const definition = argumentDefinitions[i];
                if (definition.nodeType === "VariableDeclaration") {
                    contractEvent.variables[definition.name] = {
                        name: definition.name,
                        type: truffle_decode_utils_1.Definition.typeClass(definition),
                        value: event.returnValues[definition.name] // TODO: this should be a decoded value, it currently is a string always
                    };
                }
            }
        }
        return contractEvent;
    }
    events(name = null, block = "latest") {
        return __awaiter(this, void 0, void 0, function* () {
            const web3Contract = new this.web3.eth.Contract(this.contract.abi, this.contractAddress);
            const events = yield web3Contract.getPastEvents(name, {
                fromBlock: block,
                toBlock: block
            });
            let contractEvents = [];
            for (let i = 0; i < events.length; i++) {
                contractEvents.push(this.decodeEvent(events[i]));
            }
            return contractEvents;
        });
    }
    onEvent(name, callback) {
        //this.web3.eth.subscribe(name);
    }
    removeEventListener(name) {
    }
}
exports.default = TruffleContractDecoder;
//# sourceMappingURL=contract-decoder.js.map