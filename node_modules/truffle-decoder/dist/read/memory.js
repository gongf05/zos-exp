"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const bn_js_1 = __importDefault(require("bn.js"));
const DecodeUtils = __importStar(require("truffle-decode-utils"));
/**
 * read word from memory
 *
 * requires `byte` to be a multiple of WORD_SIZE (32)
 *
 * @param memory - Uint8Array
 * @param offset - number
 * @return {BN}
 */
function read(memory, offset) {
    return readBytes(memory, offset, DecodeUtils.EVM.WORD_SIZE);
}
exports.read = read;
/**
 * read <length> amount of bytes from memory, starting at <offset>
 *
 * @param memory - Uint8Array
 * @param offset - number
 * @param length - number
 */
function readBytes(memory, offset, length) {
    const offsetBN = DecodeUtils.Conversion.toBN(offset);
    let lengthBN = DecodeUtils.Conversion.toBN(length);
    if (offsetBN.toNumber() >= memory.length) {
        return new Uint8Array(lengthBN ? lengthBN.toNumber() : 0);
    }
    if (lengthBN == undefined) {
        return new Uint8Array(memory.buffer, offsetBN.toNumber());
    }
    // grab `length` bytes no matter what, here fill this array
    var bytes = new Uint8Array(lengthBN.toNumber());
    // if we're reading past the end of memory, truncate the length to read
    let excess = offsetBN.add(lengthBN).subn(memory.length).toNumber();
    if (excess > 0) {
        lengthBN = new bn_js_1.default(memory.length).sub(offsetBN);
    }
    let existing = new Uint8Array(memory.buffer, offsetBN.toNumber(), lengthBN.toNumber());
    bytes.set(existing);
    return bytes;
}
exports.readBytes = readBytes;
/**
 * Split memory into chunks
 */
function chunk(memory, size = DecodeUtils.EVM.WORD_SIZE) {
    let chunks = [];
    for (let i = 0; i < memory.length; i += size) {
        let chunk = readBytes(memory, i, size);
        chunks.push(chunk);
    }
    return chunks;
}
exports.chunk = chunk;
//# sourceMappingURL=memory.js.map