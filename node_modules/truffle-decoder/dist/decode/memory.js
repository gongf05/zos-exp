"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const debug = debug_1.default("decoder:decode:memory");
const read_1 = __importDefault(require("../read"));
const DecodeUtils = __importStar(require("truffle-decode-utils"));
const value_1 = __importDefault(require("./value"));
const index_1 = __importDefault(require("./index"));
const memory_1 = require("../read/memory");
function decodeMemoryReference(definition, pointer, info) {
    return __awaiter(this, void 0, void 0, function* () {
        const { state } = info;
        // debug("pointer %o", pointer);
        let rawValue = yield read_1.default(pointer, state);
        if (rawValue == undefined) {
            return undefined;
        }
        let rawValueNumber = DecodeUtils.Conversion.toBN(rawValue).toNumber();
        var bytes;
        switch (DecodeUtils.Definition.typeClass(definition)) {
            case "bytes":
            case "string":
                bytes = yield read_1.default({
                    memory: { start: rawValueNumber, length: DecodeUtils.EVM.WORD_SIZE }
                }, state); // bytes contain length in the last byte
                let childPointer = {
                    memory: { start: rawValueNumber + DecodeUtils.EVM.WORD_SIZE, length: bytes[DecodeUtils.EVM.WORD_SIZE - 1] }
                };
                return yield value_1.default(definition, childPointer, info);
            case "array":
                bytes = DecodeUtils.Conversion.toBN(yield read_1.default({
                    memory: { start: rawValueNumber, length: DecodeUtils.EVM.WORD_SIZE },
                }, state)).toNumber(); // bytes contain array length
                bytes = yield read_1.default({ memory: {
                        start: rawValueNumber + DecodeUtils.EVM.WORD_SIZE, length: bytes * DecodeUtils.EVM.WORD_SIZE
                    } }, state); // now bytes contain items
                let baseDefinition = DecodeUtils.Definition.baseDefinition(definition);
                // HACK replace erroneous `_storage_` type identifiers with `_memory_`
                baseDefinition = Object.assign({}, baseDefinition, { typeDescriptions: Object.assign({}, baseDefinition.typeDescriptions, { typeIdentifier: baseDefinition.typeDescriptions.typeIdentifier
                            .replace(/_storage_/g, "_memory_") }) });
                return yield Promise.all(memory_1.chunk(bytes, DecodeUtils.EVM.WORD_SIZE)
                    .map((chunk) => index_1.default(baseDefinition, {
                    literal: chunk
                }, info)));
            case "struct":
                const { scopes } = info;
                // Declaration reference usually appears in `typeName`, but for
                // { nodeType: "FunctionCall", kind: "structConstructorCall" }, this
                // reference appears to live in `expression`
                const referencedDeclaration = (definition.typeName)
                    ? definition.typeName.referencedDeclaration
                    : definition.expression.referencedDeclaration;
                let variables = (scopes[referencedDeclaration] || {}).variables;
                const decodeMember = ({ name, id }, i) => __awaiter(this, void 0, void 0, function* () {
                    let memberDefinition = scopes[id].definition;
                    let memberPointer = {
                        memory: {
                            start: rawValueNumber + i * DecodeUtils.EVM.WORD_SIZE,
                            length: DecodeUtils.EVM.WORD_SIZE
                        }
                    };
                    // HACK replace erroneous `_storage_` type identifiers with `_memory_`
                    memberDefinition = Object.assign({}, memberDefinition, { typeDescriptions: Object.assign({}, memberDefinition.typeDescriptions, { typeIdentifier: memberDefinition.typeDescriptions.typeIdentifier
                                .replace(/_storage_/g, "_memory_") }) });
                    let decoded;
                    try {
                        decoded = yield index_1.default(memberDefinition, memberPointer, info);
                    }
                    catch (err) {
                        decoded = err;
                    }
                    return {
                        [name]: decoded
                    };
                });
                const decodings = (variables || []).map(decodeMember);
                return Object.assign({}, ...yield Promise.all(decodings));
            default:
                // debug("Unknown memory reference type: %s", DecodeUtils.typeIdentifier(definition));
                return undefined;
        }
    });
}
exports.default = decodeMemoryReference;
//# sourceMappingURL=memory.js.map