"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const debug = debug_1.default("decoder:decode:storage");
const read_1 = __importDefault(require("../read"));
const DecodeUtils = __importStar(require("truffle-decode-utils"));
const index_1 = __importDefault(require("./index"));
const value_1 = __importDefault(require("./value"));
const bn_js_1 = __importDefault(require("bn.js"));
const lodash_clonedeep_1 = __importDefault(require("lodash.clonedeep"));
function prefixPointer(child, parentSlot) {
    let result = lodash_clonedeep_1.default(child);
    let obj = result.storage.from.slot;
    while (obj.path && typeof obj.path.path !== "undefined") {
        obj = obj.path;
    }
    obj.path = lodash_clonedeep_1.default(parentSlot);
    /*let obj2 = result.storage.to.slot;
    while (typeof obj2.path !== "undefined") {
      obj2 = obj2.path;
    }
  
    obj2.path = clonedeep(parentSlot);*/
    return result;
}
function decodeStorageReference(definition, pointer, info, web3, contractAddress) {
    return __awaiter(this, void 0, void 0, function* () {
        var data;
        var length;
        const { state } = info;
        switch (DecodeUtils.Definition.typeClass(definition)) {
            case "array": {
                // debug("storage array! %o", pointer);
                if (DecodeUtils.Definition.isDynamicArray(definition)) {
                    data = yield read_1.default(pointer, state, web3, contractAddress);
                    if (!data) {
                        return undefined;
                    }
                    length = DecodeUtils.Conversion.toBN(data).toNumber();
                }
                else {
                    length = definition.typeName
                        ? parseInt(definition.typeName.length.value)
                        : parseInt(definition.length.value);
                }
                // debug("length %o", length);
                const baseDefinition = DecodeUtils.Definition.baseDefinition(definition);
                const referenceId = baseDefinition.referencedDeclaration ||
                    (baseDefinition.typeName ? baseDefinition.typeName.referencedDeclaration : undefined);
                let baseSize;
                if (typeof referenceId !== "undefined" && typeof info.referenceDeclarations !== "undefined") {
                    const referenceDeclaration = info.referenceDeclarations[referenceId];
                    baseSize = DecodeUtils.Definition.storageSize(baseDefinition, referenceDeclaration);
                }
                else {
                    baseSize = DecodeUtils.Definition.storageSize(baseDefinition);
                }
                const perWord = Math.floor(DecodeUtils.EVM.WORD_SIZE / baseSize);
                // debug("baseSize %o", baseSize);
                // debug("perWord %d", perWord);
                const offset = (i) => {
                    if (perWord == 1) {
                        return i;
                    }
                    return Math.floor(i * baseSize / DecodeUtils.EVM.WORD_SIZE);
                };
                const index = (i) => {
                    if (perWord == 1) {
                        return DecodeUtils.EVM.WORD_SIZE - baseSize;
                    }
                    const position = perWord - i % perWord - 1;
                    return position * baseSize;
                };
                let from = {
                    slot: Object.assign({}, pointer.storage.from.slot),
                    index: pointer.storage.from.index
                };
                // debug("pointer: %o", pointer);
                let ranges = [];
                let currentReference = {
                    slot: {
                        path: from.slot || undefined,
                        offset: new bn_js_1.default(0),
                        hashPath: DecodeUtils.Definition.isDynamicArray(definition)
                    },
                    index: DecodeUtils.EVM.WORD_SIZE - 1
                };
                for (let i = 0; i < length; i++) {
                    currentReference.index -= baseSize - 1;
                    if (currentReference.index < 0) {
                        currentReference.slot.offset = currentReference.slot.offset.addn(1);
                        currentReference.index = DecodeUtils.EVM.WORD_SIZE - baseSize;
                    }
                    let childRange = {
                        from: {
                            slot: {
                                path: currentReference.slot.path,
                                offset: currentReference.slot.offset.clone(),
                                hashPath: currentReference.slot.hashPath
                            },
                            index: currentReference.index
                        },
                        length: baseSize
                    };
                    currentReference.index -= 1;
                    ranges.push(childRange);
                }
                const decodePromises = ranges.map((childRange, idx) => {
                    // debug("childFrom %d, %o", idx, childFrom);
                    return index_1.default(DecodeUtils.Definition.baseDefinition(definition), {
                        storage: childRange
                    }, info, web3, contractAddress);
                });
                return yield Promise.all(decodePromises);
            }
            case "bytes":
            case "string": {
                data = yield read_1.default(pointer, state, web3, contractAddress);
                if (data == undefined) {
                    return undefined;
                }
                // debug("data %O", data);
                let lengthByte = data[DecodeUtils.EVM.WORD_SIZE - 1];
                if (!lengthByte) {
                    lengthByte = 0;
                }
                if (lengthByte % 2 == 0) {
                    // string lives in word, length is last byte / 2
                    length = lengthByte / 2;
                    // debug("in-word; length %o", length);
                    if (length == 0) {
                        return "";
                    }
                    return value_1.default(definition, { storage: {
                            from: { slot: pointer.storage.from.slot, index: 0 },
                            to: { slot: pointer.storage.from.slot, index: length - 1 }
                        } }, info, web3, contractAddress);
                }
                else {
                    length = DecodeUtils.Conversion.toBN(data).subn(1).divn(2).toNumber();
                    // debug("new-word, length %o", length);
                    return value_1.default(definition, {
                        storage: {
                            from: {
                                slot: {
                                    path: pointer.storage.from.slot,
                                    offset: new bn_js_1.default(0),
                                    hashPath: true
                                },
                                index: 0
                            },
                            length
                        }
                    }, info, web3, contractAddress);
                }
            }
            case "struct": {
                const { scopes } = info;
                const referencedDeclaration = (definition.typeName)
                    ? definition.typeName.referencedDeclaration
                    : definition.referencedDeclaration;
                // TODO: this is ugly, this should be one conformed method, will fix at some later point
                if (typeof scopes[referencedDeclaration] !== "undefined") {
                    // debugger way
                    const variables = (scopes[referencedDeclaration] || {}).variables || [];
                    let slot;
                    if (pointer.storage != undefined) {
                        slot = pointer.storage.from.slot;
                    }
                    else {
                        slot = DecodeUtils.Allocation.normalizeSlot(DecodeUtils.Conversion.toBN(yield read_1.default(pointer, state, web3, contractAddress)));
                    }
                    const allocation = DecodeUtils.Allocation.allocateDeclarations(variables, scopes, slot);
                    return Object.assign({}, ...yield Promise.all(Object.entries(allocation.children).map(([id, childPointer]) => __awaiter(this, void 0, void 0, function* () {
                        let decoded;
                        try {
                            decoded = yield index_1.default(scopes[id].definition, { storage: childPointer }, info, web3, contractAddress);
                        }
                        catch (err) {
                            decoded = err;
                        }
                        return {
                            [childPointer.name]: decoded
                        };
                    }))));
                }
                else {
                    // seese's way
                    let result = {
                        name: definition.name,
                        type: info.referenceDeclarations[referencedDeclaration].name,
                        members: {}
                    };
                    const members = info.referenceDeclarations[referencedDeclaration].members;
                    const referenceVariable = info.referenceVariables[referencedDeclaration];
                    for (let i = 0; i < members.length; i++) {
                        const variableRef = referenceVariable.members[members[i].id];
                        const pointer = prefixPointer(variableRef.pointer, info.variables[definition.id].pointer.storage.from.slot);
                        const val = yield index_1.default(members[i], pointer, info, web3, contractAddress);
                        result.members[members[i].name] = {
                            name: members[i].name,
                            type: DecodeUtils.Definition.typeClass(members[i]),
                            value: val
                        };
                    }
                    return result;
                }
            }
            case "enum": {
                data = yield read_1.default(pointer, state, web3, contractAddress);
                if (data == undefined) {
                    return undefined;
                }
                const numRepresentation = DecodeUtils.Conversion.toBN(data).toNumber();
                const referenceId = definition.referencedDeclaration ||
                    (definition.typeName ? definition.typeName.referencedDeclaration : undefined);
                const enumDeclaration = info.referenceDeclarations[referenceId];
                const decodedValue = enumDeclaration.members[numRepresentation].name;
                return {
                    type: enumDeclaration.name,
                    value: enumDeclaration.name + "." + decodedValue
                };
            }
            case "mapping": {
                const result = {
                    name: definition.name,
                    type: "mapping",
                    id: definition.id,
                    keyType: DecodeUtils.Definition.typeClass(definition.typeName.keyType),
                    valueType: DecodeUtils.Definition.typeClass(definition.typeName.valueType),
                    members: {}
                };
                const baseSlot = pointer.storage.from.slot;
                if (info.mappingKeys && typeof info.mappingKeys[definition.id] !== "undefined") {
                    const keys = info.mappingKeys[definition.id];
                    for (const key of keys) {
                        const keyValue = DecodeUtils.Conversion.toBytes(key);
                        const valuePointer = {
                            storage: {
                                from: {
                                    slot: {
                                        key: key,
                                        path: baseSlot || undefined,
                                        offset: new bn_js_1.default(0)
                                    },
                                    index: 0
                                },
                                to: {
                                    slot: {
                                        key: key,
                                        path: baseSlot || undefined,
                                        offset: new bn_js_1.default(0)
                                    },
                                    index: 31
                                }
                            }
                        };
                        // debug("keyPointer %o", keyPointer);
                        let memberName;
                        if (typeof key === "string") {
                            memberName = key;
                        }
                        else {
                            memberName = keyValue.toString();
                        }
                        result.members[memberName] =
                            yield index_1.default(definition.typeName.valueType, valuePointer, info, web3, contractAddress);
                    }
                }
                return result;
            }
            default: {
                // debug("Unknown storage reference type: %s", DecodeUtils.typeIdentifier(definition));
                return undefined;
            }
        }
    });
}
exports.default = decodeStorageReference;
//# sourceMappingURL=storage.js.map